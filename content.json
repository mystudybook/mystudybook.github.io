{"posts":[{"title":"MVP Pattern","text":"MVC模式(Model-View-Controller)：MVC模式在開發UI中是一種非常受歡迎的設計模式。 MVC主要想法為：將程式劃分為模型（Model）、視圖（View）和控制器（Controller） Model：主要負責管理資料邏輯。Model拿到資料後將資料交給View。 在此可以直接與資料庫、API 或其他資料來源交互。 在此不執行遊戲邏輯或是執行運算。 View：負責顯示資料。 它從Model中獲取資料，並將這些資料呈現給使用者。View僅關注如何顯示資料。 Controller：充當Model和View之間的溝通的橋樑。 它接收使用者的輸入，呼叫Model來處理這些輸入，然後選擇適當的View來顯示處理結果。 可以把它想像為大腦，它處理遊戲資料並在執行期間計算資料是如何改變的。 MVC模式符合單一職責原則，每個部分都只負責自己的部分。 在Unity中，UI Toolkit或是Unity UI很自然地負責擔任View 缺點 MVC模式中三者相互依賴，一但更新了其中一個，另外兩個也須跟著修改。 Controller的程式碼會隨著功能的添加越來越臃腫。 import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.esm.min.mjs'; mermaid.initialize({ startOnLoad: true }); .node.default { font-size: 0.75em; } graph TD A[ User ] -->| Interacts with | B[ View ] B -->| Sends user input to | C[ Controller ] C -->| Updates | D[ Model ] D -->| Notifies changes to | B[ View ] B -->| Displays data from | D[ Model ] MVP模式(Model-View-Presenter)：MVP是MVC的一種變體 MVP將Controller改爲Presenter，並改變了通信方向。當Model拿到資料之後，不直接給View更新，而是交給Presenter，之後Presenter再把資料交給View，View再更新畫面。 View：只負責收到使用者回饋，之後呼叫Presenter拿取資料，並在接收到資料時，更新畫面。 Model：被動的接收到Presenter命令，拿取資料，並回傳給Presenter。 Presenter：Model和View之間的的橋樑，與View和Model溝通。 從三者相互依賴變成都只依賴Presenter M &lt;=&gt; P &lt;=&gt; V 之間雙向通信但View與Model不通信 Presenter的程式碼會隨著功能的添加越來越臃腫。 graph TD A[ User ] -->| Interacts with | B[ View ] B -->| Sends user input to | C[ Presenter ] C -->| Updates | D[ Model ] D -->| Notifies changes to | C[ Presenter ] C -->| Updates | B[ View ] B -->| Displays data from | C[ Presenter ] 使用MVP模式製作生命條UI：Health類 在此Health類的身份是Model，保存真正的生命資料 含有一個HealthChanged event，每當有更改生命值的動作時，都會呼叫這個event。 Health類只負責增加，減少生命值，符合符合單一職責原則123456789101112131415161718192021222324252627282930313233343536373839404142public class Health : MonoBehaviour{ public event Action HealthChanged; private const int minHealth = 0; private const int maxHealth = 100; private int currentHealth; public int CurrentHealth { get =&gt; currentHealth; set =&gt; currentHealth = value; } public int MinHealth =&gt; minHealth; public int MaxHealth =&gt; maxHealth; public void Increment(int amount) { currentHealth += amount; currentHealth = Mathf.Clamp(currentHealth, minHealth, maxHealth); UpdateHealth(); } public void Decrement(int amount) { currentHealth -= amount; currentHealth = Mathf.Clamp(currentHealth, minHealth, maxHealth); UpdateHealth(); } public void Restore() { currentHealth = maxHealth; UpdateHealth(); } private void UpdateHealth() { HealthChanged?.Invoke(); }} HealthPresenter類 HealthPresenter類含有Health類的依賴，用來操控Health 其他物件不會直接操控Health類，而是透過HealthPresenter類暴露的Damage與Heal以及Reset來操控12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class HealthPresenter : MonoBehaviour{ // 在MVP中的Model [SerializeField] private Health health; // 在MVP中的View [SerializeField] private Slider healthSlider; private void Start() { if (health != null) { health.HealthChanged += OnHealthChanged; } UpdateView(); } private void OnDestroy() { if (health != null) { health.HealthChanged -= OnHealthChanged; } } public void Damage(int amount) { health?.Decrement(amount); } public void Heal(int amount) { health?.Increment(amount); } public void Reset() { health?.Restore(); } public void UpdateView() { if (health == null) return; if (healthSlider != null &amp;&amp; health.MaxHealth != 0) { healthSlider.value = (float)health.CurrentHealth / health.MaxHealth; } } private void OnHealthChanged() { UpdateView(); }} ClickDamage類：為使用HealthPresenter的類 不直接操控 Model (Health)與 View (healthSlider)而是透過HealthPresenter1234567891011121314151617181920212223242526[RequireComponent(typeof(HealthPresenter), typeof(Collider))]public class ClickDamage : MonoBehaviour{ private Collider collider; private HealthPresenter healthPresenter; [SerializeField] private LayerMask layerToClick; [SerializeField] private int damageValue = 10; private void Start() { collider = GetComponent&lt;Collider&gt;(); healthPresenter = GetComponent&lt;HealthPresenter&gt;(); } private void Update() { if (Input.GetMouseButtonDown(0)) { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); if (Physics.Raycast(ray, Mathf.Infinity, layerToClick)) { healthPresenter?.Damage(damageValue); } } }} Reference: https://github.com/Unity-Technologies/game-programming-patterns-demo/tree/main/Assets/12%20MVPhttps://github.com/push-pop/Unity-MVVM/blob/main/Docs/Architechture.md","link":"/2024/05/27/2024-05-27-mvp-pattern/"},{"title":"2D車輪關節(Wheel Joint 2D)","text":"2D車輪關節(Wheel Joint 2D)：是一種物理關節，可以用它來模擬轉動的車輪， 可以為它施加馬達動力(motor power)， 它使用了懸吊彈簧(suspension spring)來保持與車輛主體(main body of the vehicle)的距離。 這種關節可用來模擬車輪(wheels)和懸掛系統(suspension)。其目的是保持兩個點在一條延伸到無限遠的直線上，同時使它們重疊(overlap)。這兩個點可以是兩個Rigidbody2D組件，也可以是一個Rigidbody2D組件和世界中的一個固定位置（通過將Connected Rigidbody設置為None來連接到世界中的固定位置）。 簡單的說：2D車輪關節(Wheel Joint 2D)，讓兩個點保持在同一條直線上，而這條直線是可以延伸到無限遠的。同時，當沒有外力作用時，這兩個點會保持在一起(即重疊)。 Wheel Joint 2D類似於Slider Joint 2D（無馬達動力或限制約束）和Hinge Joint 2D（無限制約束）的組合。這種關節對兩個連接的剛體(rigid body)物件施加線性力(linear force)，使它們保持在線上，並施加角度馬達(angular motor)以使物件在線上旋轉(rotate)，同時用彈簧(spring)來模擬車輪懸掛(wheel suspension)。 Play Unity Test on itch.io 設置Maximum Motor Speed（最大馬達速度）與Maximum Motor Force（最大馬達動力）控制角馬達速度，讓兩個剛體物體旋轉。Maximum Motor Force（最大馬達動力）：設置角馬達的最大扭矩。 即馬達所能施加的最大旋轉力。這個最大扭矩的設置對於控制車輪的轉動速度和力量非常重要。例如： 如果 Maximum Motor Force 設置得太小，馬達可能無法提供足夠的扭矩來驅動車輪，特別是在遇到障礙或需要加速的情況下。 如果 Maximum Motor Force 設置得太大，馬達可能會施加過大的扭矩，導致車輪快速旋轉，可能會影響車輛的穩定性模擬懸掛可以設置車輪懸掛的硬度和運動，以模擬不同程度的懸掛效果。例如，模擬硬且幾乎不動的懸掛： 設置高頻率（Frequency）（1,000,000是最高值）== 硬懸掛。 設置高阻尼比（Damping Ratio）（1是最高值）== 幾乎不動的懸掛。 若要模擬有彈性且自由運動的懸掛，可以使用以下設置： 設置低頻率 == 鬆弛的懸掛。 設置低阻尼比 == 可動的懸掛。 保持零相對線性距離(zero relative linear distance)：在兩個剛體物體的錨點之間指定的線上保持零相對線性距離。保持角速度(angular speed)：在兩個剛體物體的錨點之間保持角速度（通過Maximum Motor Speed選項設置速度，通過Maximum Motor Force設置最大扭矩）。 應用場景 這種關節適用於構建需要像是通過旋轉樞軸連接，但不能脫離指定線的物理對象。例如：模擬具有馬達驅動的車輪。 屬性 功能 Enable Collision 啟用這個屬性後，可以偵測碰撞。 Connected Rigid Body 指定此關節連接到的其他遊戲物件(GameObject)。如果將此設置為「None」，則關節的另一端固定在由「Connected Anchor」設置定義的空間點。 Auto Configure Connected Anchor 啟用此屬性以自動設置此關節連接到的遊戲物件的錨點(Anchor)位置。如果啟用此屬性，則不需要為「Connected Anchor」屬性輸入座標。 Anchor 定義此遊戲物件的2D剛體(Rigidbody2D)上的關節(joint)端點連接的位置（以x、y座標表示）。 Connected Anchor 定義這個關節(joint)端點要連接到另一個遊戲物件的2D剛體(Rigidbody2D)上的位置（以x、y座標表示）。 Suspension 選擇此選項以展開此屬性的設置。 Damping Ratio(阻尼比) 控制彈簧(spring)振盪(oscillation)的關節設置。較高的阻尼比意味著彈簧會更快停止振盪 Frequency 設定遊戲物件接近所需分離距離時彈簧振盪的頻率（以每秒週期數為單位）。範圍為0到1,000,000，值越高，彈簧越硬，也就是說越不容易來回振動。注意：將頻率設置為零會創建最硬的彈簧類型關節(即不振動) Angle 設定懸掛系統(suspension)的世界(World)運動角度 Use Motor 啟用此選項以對關節應用馬達動力。 Motor 選擇此選項以展開此屬性的設置。 Motor Speed 設定馬達要達到的目標速度（每秒度數）。 Maximum Motor Force 設定馬達在嘗試達到目標速度時可以施加的最大扭矩(torque)（或旋轉力(rotation)）。 Break Action 設置當超過力(force)臨界值或達到扭矩臨界值(torque threshold)時採取的動作。 Break Force 設置力的臨界值，當超過時這個關節就會執行選擇的Break Action。預設值為Infinity，表示不執行Break Action。 Break Torque 設置扭矩的臨界值，當超過時這個關節就會執行選擇的Break Action。預設值為Infinity，表示不執行Break Action。 Damping Ratio(阻尼比)：描述系統在受到擾動後振盪及衰減的情形。阻尼比越大，物件受力振盪後越快恢復原狀。 無阻尼：= 0 ， 對應沒有阻尼的簡諧運動。 欠阻尼：&lt; 1 ， 指數遞減且振盪 過阻尼：&gt; 1 ， 沒有振盪的指數遞減 臨界阻尼：= 1 ， 介於過阻尼及欠阻尼之間，是許多工程應用想要的結果 https://zh.wikipedia.org/zh-tw/%E9%98%BB%E5%B0%BC%E6%AF%94 Reference：https://docs.unity3d.com/Manual/class-WheelJoint2D.html","link":"/2024/05/29/2024-05-29-wheel-joint-2d/"},{"title":"MVVM Pattern","text":"MVVM模式(Model–View–ViewModel)：MVVM將程式劃分為 Model ， View 與 ViewModel ，它透過觀察者模式將 View 與 ViewModel 連接在一起， 在 ViewModel 中進行資料綁定(data binding)。當 View Model 的狀態改變時自動通知 View。 Model：主要負責管理資料邏輯。 View：負責顯示資料以及與使用者互動。 ViewModel：是連接 Model 和 View 的橋樑。與 MVC中的 Controller 和 MVP 中的 Presenter 不同在於 ViewModel 它會綁定(Binder) View 要顯示的資料，當資料改變時，自動通知 View 要更新UI。 通常使用資料綁定(Data Binding)機制來實現這一點 import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.esm.min.mjs'; mermaid.initialize({ startOnLoad: true }); .node.default { font-size: 0.75em; } graph TD A[ View ] B[ ViewModel ] C[ Model ] A -->| User Interaction | B B -->| Notify Changes | A B | Data Binding | A B -->| Calls | C C -->| Data | B Unity中，UGUI沒有內建Data Binding，需要自己實作一個，以下是一個簡單的範例 定義一個 Model 12345public class Model{ public string Name { get; set; } public string Job { get; set;}} 定義一個Model Service，其職責為從PlayerPrefs拿資料，或是將資料寫入PlayerPrefs 123456789101112131415161718192021222324public class ModelService{ public Model GetData() { Model m = new Model() { Name = PlayerPrefs.GetString(&quot;name&quot;), Job = PlayerPrefs.GetString(&quot;job&quot;), }; return m; } public void SaveName(string name) { PlayerPrefs.SetString(&quot;name&quot;, name); } public void SaveJob(string job) { PlayerPrefs.SetString(&quot;job&quot;, job); }} 定義一個BindableProperty類，它含有一個OnValueChanged事件，當Value的值發生變化(通過set方法)時，就會呼叫 OnValueChanged ，從而通知有註冊這個事件的物件。 123456789101112131415161718192021222324252627282930public class BindableProperty&lt;T&gt;{ public delegate void ValueChangedHandler(T oldValue, T newValue); public event ValueChangedHandler OnValueChanged; private T _value; public T Value { get { return _value; } set { if (!object.Equals(_value, value)) { T oldValue = _value; _value = value; // 通知值發生改變 OnValueChanged?.Invoke(oldValue, _value); } } } public override string ToString() { return (Value != null ? Value.ToString() : &quot;null&quot;); }} 接下來定義一個 ViewModel ， 這個 ViewModel 將負責為 View 提供資料，但它不知曉 View 的任何資訊，與 View 解耦，專注於資料的處理 1234567891011121314151617181920212223242526272829303132333435363738394041public class ViewModel{ public BindableProperty&lt;string&gt; Name = new BindableProperty&lt;string&gt;(); public BindableProperty&lt;string&gt; Job = new BindableProperty&lt;string&gt;(); private ModelService service = new ModelService(); public ViewModel() {} public void GetModel() { Model m = service.GetData(); Name.Value = m.Name; Job.Value = m.Job; Debug.Log(m.Name + &quot; &quot; + m.Job); } public void SaveModel() { // do some check string name = Name.Value; string job = Job.Value; if (name == null || name.Length &gt; 0) { return; } if (job == null || job.Length &gt; 0) { return; } service.SaveName(Name.Value); service.SaveJob(Job.Value); }} 最後定義一個 View ，這個 View 包含了要操控的UI元件，因此繼承了MonoBehaviour，它不處理資料邏輯，只負責顯示格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class View : MonoBehaviour{ public TMP_InputField nameInputField; public TextMeshProUGUI nameMessageText; public TMP_InputField jobInputField; public TextMeshProUGUI jobMessageText; public TextMeshProUGUI resultText; public Button applyButton; public ViewModel viewModel; private void Start() { viewModel = new ViewModel(); viewModel.Name.OnValueChanged += OnNameChanged; nameInputField.onValueChanged.AddListener(OnNameInputChanged); viewModel.Job.OnValueChanged += OnJobChanged; jobInputField.onValueChanged.AddListener(OnJobInputChanged); applyButton.onClick.AddListener(OnApplyButtonClick); viewModel.GetModel(); } private void OnDestroy() { viewModel.Name.OnValueChanged -= OnNameChanged; nameInputField.onValueChanged.RemoveListener(OnNameInputChanged); viewModel.Job.OnValueChanged -= OnJobChanged; jobInputField.onValueChanged.RemoveListener(OnJobInputChanged); applyButton.onClick.RemoveListener(OnApplyButtonClick); } private void OnNameChanged(string oldVal, string newVal) { nameMessageText.text = newVal; } private void OnNameInputChanged(string value) { viewModel.Name.Value = value; } private void OnJobChanged(string oldVal, string newVal) { jobMessageText.text = newVal; } private void OnJobInputChanged(string value) { viewModel.Job.Value = value; } private void OnApplyButtonClick() { resultText.text = viewModel.Name.Value + &quot;, &quot; + viewModel.Job.Value + &quot; have been saved&quot;; viewModel.SaveModel(); }} 程式碼： https://github.com/mystudybook/Unity-MVVM Reference: https://www.cnblogs.com/OceanEyes/p/unity3d_framework_designing_get_started_with_mvvm_part1.html","link":"/2024/06/09/2024-06-09-mvvm-pattern/"},{"title":"Unity MonoBehavior","text":"MonoBehaviour 是 Unity 中最重要的基類之一，用於控制遊戲物件(GameObject)的行為。並提供了一系列生命週期方法，這些方法在遊戲物件生命週期的不同階段會被調用。此外，還提供了一些輔助方法，用於執行常見任務，例如訪問遊戲物件和組件(Component)。 生命週期方法 (Lifecycle methods)MonoBehaviour 提供了一系列生命週期方法，這些方法在遊戲物件生命週期的不同階段會被調用。這些方法包括 Awake：此方法在遊戲物件(GameObject)實體被建立時呼叫一次。 通常用來：在APP開始前初始化遊戲物件狀態和屬性，例如設置變量、添加組件(Component)等。 Unity會在所有啟用的遊戲物件都實體化之後，才呼叫Awake，所以可以呼叫FindWithTag，而不用擔心找不到啟用的遊戲物件。 Awake不可以使用協程(Awake cannot act as a coroutine) 注意：Unity 不會保證用特定的順序調用每個遊戲物件的 Awake 方法。因此，不可以假設一個遊戲物件的 Awake 方法會在另一個遊戲物件的 Awake方法之前或之後調用。 正確的方式是在 Awake 中設置自身的屬性和取得其他物件的引用，而在 Start 方法中處理需要依賴其他遊戲物件的屬性和引用。 注意：如果如果遊戲物件是啟用(Enable)但是腳本(Script)並沒有被啟用，Awake依然會被執行。 OnEnable：啟用時才會呼叫，在Awake之後執行，每次啟用都會呼叫 通常在此註冊事件 Start：此方法在遊戲物件的所有組件都已初始化且第一幀渲染之前調用一次。 當這個遊戲物件處於 Disabled 就不會呼叫，直到該物件第一次被啟用時，才呼叫。 通常用來：處理開始遊戲物件開始的遊戲邏輯。 是在Awake與OnEnable之後呼叫 Start可以使用協程 (Coroutine) Update：此方法在遊戲的每一幀調用。 當物件為啟用時才會呼叫Update 通常用來：更新遊戲物件的狀態和處理使用者輸入。 FixedUpdate：此方法在固定的時間間隔調用，通常每 0.02 秒調用一次。 通常用來：在此方法更新遊戲物件的物理模擬。 當使用剛體(Rigidbody)的時候，最好在FixedUpdate中操作 LateUpdate：此方法在所有的 Update 方法之後調用。 它是更新依賴於 Update 方法結果的遊戲邏輯的理想場所。 例如：攝影機跟隨(follow camera)就很適合放在此，因為它需要跟隨那些可能在 Update 中已經移動過的物件。 OnDisable：與OnEnable類似，但是是非啟用時才會呼叫，每次非啟用都會呼叫 通常在此取消註冊事件 當遊戲物件為disable時，不會呼叫Update，FixedUpdate，LateUpdate等相關更新方法。 當遊戲物件為disable時，物件仍然在場景(Scene)中，該物件仍不會被釋放。 OnDestroy：此方法在遊戲物件被銷毀時調用一次。物件從場景(Scene)中被移除了，該物件所佔用的記憶體可以被釋放。 當原先場景關閉，載入新的場景時，也會觸發OnDestroy方法 通常用來：清理遊戲物件使用的資源。 如果如果遊戲物件是啟用(Enable)但是腳本(Script)並沒有被啟用，移除該物件時，OnDestroy依然會被執行。 注意：如果使用者是在手機平台上，那麼當使用者暫停你的APP時，作業系統(OS)可能會終止你的APP，而不會觸發 OnDestroy 方法，因此不要依賴此方法來保存APP的狀態。請將每次應用程序失去焦點視為APP退出，並使用 MonoBehaviour.OnApplicationFocus 來保存資料。 注意：在Unity中預設是不會控制Script的執行順序，Unity的執行會先將所有腳本的Awake執行完之後，才去執行所有腳本的Start，如果真的需要依賴順序你需要到ProjectSetting中的Script Exceution Order去設定順序，數字越小的越先執行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System.Collections;using System.Collections.Generic;using UnityEngine;public class A : MonoBehaviour{ // 最先呼叫 private void Awake() { Debug.Log($&quot;{nameof(A)} is Awake&quot;); } // 啟用時才會呼叫，在Awake之後執行，每次啟用都會呼叫 private void OnEnable() { Debug.Log($&quot;{nameof(A)} is OnEnable&quot;); } // 在第一幀開始前執行 void Start() { Debug.Log($&quot;{nameof(A)} is Start&quot;); } // 每一幀執行 void Update() { Debug.Log($&quot;{nameof(A)} is Update&quot;); } // 在 Update 之後執行，也是每一幀執行 private void LateUpdate() { Debug.Log($&quot;{nameof(A)} is LateUpdate&quot;); } // 固定時間呼叫 private void FixedUpdate() { Debug.Log($&quot;{nameof(A)} is FixedUpdate&quot;); } // 非啟用時才會呼叫，每次非啟用都會呼叫 private void OnDisable() { Debug.Log($&quot;{nameof(A)} is OnDisable&quot;); } // 目前Component銷毀時才會呼叫 private void OnDestroy() { Debug.Log($&quot;{nameof(A)} is OnDestroy&quot;); }} Reference: https://docs.unity3d.com/ScriptReference/MonoBehaviour.Awake.html https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnEnable.html https://docs.unity3d.com/ScriptReference/MonoBehaviour.Start.html https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnDisable.html https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnDestroy.html","link":"/2024/06/11/2024-06-11-unity-MonoBehaviour/"},{"title":"2D樞紐關節 (Hinge Joint 2D)","text":"2D樞紐/鉸鏈關節(Hinge Joint 2D) 是 Unity 中的一個 2D 物理組件。 它可以讓遊戲物件(GameObject)圍繞一個特定的點旋轉 這個關節可以讓兩個點重疊，這兩個點可以是 兩個2D剛體(Rigidbody 2D)物件，或是 一個2D剛體物件另一個為一個世界空間中固定的點。若要連接到世界空間中固定的點可以透過將 Connected Rigidbody 設為 None 這個關節可以向連接的兩個點施加一個線性力(linear force) 通常用於模擬門、槓桿或鐘擺等旋轉機制。 2D樞紐/鉸鏈關節(Hinge Joint 2D)具有三個約束條件，這些條件都是可選的 保持兩個2D剛體(Rigidbody 2D)物件上的兩個錨點(anchor point)之間的相對線性距離(relative linear distance) 此約束確保錨點之間的距離保持不變。 保持兩個2D剛體(Rigidbody 2D)遊戲物件上的兩個錨點之間的角速度(angular speed) 可以使用Maximum Motor Force屬性限制最大扭矩(maximum torque)來限制角速度。 保持角度(angle)在指定的弧度(arc)範圍內 此約束確保角度在一定範圍內。 可以使用這個關節來建構需要像旋轉樞軸行為的物理遊戲物件。例如： 翹翹板的樞軸(see-saw pivot)：水平部分連接到基座。使用關節的角度(Angle)限制來模擬翹翹板的最高點和最低點。 剪刀(scissors)的樞軸：剪刀用鉸鏈連接在一起。使用關節的角度限制來模擬剪刀的閉合和最大打開。 簡單的車輪連接到車體：車輪的樞軸點在車輪的中心與車體相連。你可以使用2D樞紐/鉸鏈關節(Hinge Joint 2D) 的馬達(motor)來旋轉車輪。 Play HingeJoint2D on itch.io 屬性 功能 Enable Collision 啟用這個屬性後，可以偵測碰撞。 Connected Rigidbody 指定此關節連接到的其他遊戲物件(GameObject)。如果將此設置為「None」，則關節的另一端固定在由「Connected Anchor」設置定義的空間點。 Auto Configure Connected Anchor 啟用此屬性以自動設置此2D鉸鏈關節(Hinge Joint 2D)連接到的遊戲物件的錨點(Anchor)位置。如果啟用此屬性，則不需要為「Connected Anchor」屬性輸入座標。 Anchor 定義此遊戲物件的2D剛體(Rigidbody2D)上的關節(joint)端點連接的位置（以x、y座標表示）。 Connected Anchor 定義這個關節(joint)端點要連接到另一個遊戲物件的2D剛體(Rigidbody2D)上的位置（以x、y座標表示）。 Use Motor 啟用此選項以對關節應用馬達動力。 Motor 選擇此選項以展開此屬性的設置。 Motor Speed 設定馬達要達到的目標速度（每秒度數）。 Maximum Motor Force 設定馬達在嘗試達到目標速度時可以施加的最大扭矩(torque)（或旋轉力(rotation)）。 Use Limits 啟用此選項以限制旋轉的角度(rotation angle)。 Angle Limits 選擇此選項以展開對角度限制的設置。當Use Limits啟用時，就會應用這些限制。 Lower Angle 設定旋轉圓弧(rotation arc)下端(lower end)允許的極限。 Upper Angle 設定旋轉圓弧(rotation arc)上端(upper end)允許的極限。 Break Action 設置當超過力(force)臨界值或達到扭矩臨界值(torque threshold)時採取的動作。 Break Force 設置力的臨界值，當超過時這個關節就會執行選擇的Break Action。預設值為Infinity，表示不執行Break Action。 Break Torque 設置扭矩的臨界值，當超過時這個關節就會執行選擇的Break Action。預設值為Infinity，表示不執行Break Action。 Reference https://docs.unity3d.com/Manual/class-HingeJoint2D.html","link":"/2024/06/12/2024-06-12-hinge-joint-2d/"},{"title":"關閉 Chrome的 Web Security","text":"在前後端分離的狀況下，很容易就會遇到跨域的問題，為了開發測試方便，我們可以暫時禁用Chrome的安全設定，以方便我們測試開發。 在Mac上使用以下指令來關閉 Chrome的安全設定 1open -n -a &quot;Google Chrome&quot; --args --user-data-dir=/tmp/temp_chrome_user_data_dir http://localhost:8080/ --disable-web-security 當出現 你正在使用不受支援的命令列標嫩：--disable-web-security•這可能會危及穩定性與安全性。 字樣，表示你已經成功關閉Chrome的安全設定了。 Reference: https://stackoverflow.com/questions/3102819/disable-same-origin-policy-in-chrome","link":"/2024/06/13/2024-06-13-disable-web-security/"},{"title":"在前端直接將檔案上傳到AWS S3","text":"在自己架設的伺服器中，如果要把檔案上傳到AWS S3，一種常見的做法是先將檔案上傳到自身伺服器然後再上傳到AWS S3，但是這樣太耗費資源了。幸好AWS S3有方式可以讓你在前端直接將檔案上傳到S3中，以下說明如何設定前端的HTML，讓檔案直接上傳。 首先你要有可以存取Bucket的 AWSAccessKeyId 與 AWSSecretAccessKey 以下資料皆來自https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-post-example.html AWSAccessKeyId AKIAIOSFODNN7EXAMPLE AWSSecretAccessKey wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY Bucket sigv4examplebucket HTML FORM以下是HTML Form的例子 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 將form的 action ，設為 action=&quot;https://&lt;你的Bucket名稱&gt;.s3.amazonaws.com/&quot; ， 如下--&gt; &lt;form action=&quot;http://sigv4examplebucket.s3.amazonaws.com/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; Key to upload: &lt;!-- 這個 key 將設定 S3 Object Key， 例如設為： user/user1/myfile.csv，之後在AWS S3上面看到的就是 user/user1/myfile.csv --&gt; &lt;input type=&quot;input&quot; name=&quot;key&quot; value=&quot;user/user1/myfile.csv&quot; /&gt;&lt;br /&gt; &lt;!-- 這個 acl 將設定 S3 ACL， 如設為：public-read 表示可以被公開讀取，也可以設為 private ，表示是私有的--&gt; &lt;input type=&quot;hidden&quot; name=&quot;acl&quot; value=&quot;public-read&quot; /&gt; &lt;!-- 這個 success_action_redirect 將設定 上傳成功之後，要導向到哪個網頁，如設為：http://localhost:8080/uploaded.html --&gt; &lt;input type=&quot;hidden&quot; name=&quot;success_action_redirect&quot; value=&quot;http://localhost:8080/uploaded.html&quot; /&gt; Content-Type: &lt;!-- 這個 Content-Type 將限定要上傳的檔案類型，可以不設定 --&gt; &lt;!-- &lt;input type=&quot;input&quot; name=&quot;Content-Type&quot; value=&quot;image/jpeg&quot; /&gt;&lt;br /&gt; --&gt; &lt;!-- 這個 x-amz-meta-uuid 應由後端產生一組隨機的字串，讓AWS S3做驗證 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;x-amz-meta-uuid&quot; value=&quot;14365123651274&quot; /&gt; &lt;!-- 這個 x-amz-server-side-encryption 說明使用哪種加密方式，例如 AES256 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;x-amz-server-side-encryption&quot; value=&quot;AES256&quot; /&gt; &lt;!-- 這個 X-Amz-Credential 由 &lt;AWSAccessKeyId&gt;/&lt;日期&gt;/&lt;Bucket-Region&gt;/&lt;RegionService&gt;/&lt;Signing&gt; 組成，RegionService和Signing是固定的就是s3和aws4_request--&gt; &lt;input type=&quot;text&quot; name=&quot;X-Amz-Credential&quot; value=&quot;AKIAIOSFODNN7EXAMPLE/20151229/us-east-1/s3/aws4_request&quot; /&gt; &lt;!-- 這個 X-Amz-Algorithm說明建立這個Request的簽名使用哪種演算法，例如 AWS4-HMAC-SHA256 --&gt; &lt;input type=&quot;text&quot; name=&quot;X-Amz-Algorithm&quot; value=&quot;AWS4-HMAC-SHA256&quot; /&gt; &lt;!-- 這個 X-Amz-Date 說明建立這個Request的簽名的日期，為可選的，需要為 ISO 8601 basic format (YYYYMMDD'T'HHMMSS'Z') 格式 --&gt; &lt;input type=&quot;text&quot; name=&quot;X-Amz-Date&quot; value=&quot;20151229T000000Z&quot; /&gt; Tags for File: &lt;!-- 這個 x-amz-meta-tag 是可選的 --&gt; &lt;!-- &lt;input type=&quot;input&quot; name=&quot;x-amz-meta-tag&quot; value=&quot;&quot; /&gt;&lt;br /&gt; --&gt; &lt;!-- 這個 Policy 為Base64編碼的字串，在下面說明 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;Policy&quot; value='&lt;Base64-encoded policy string&gt;' /&gt; &lt;!-- 這個 X-Amz-Signature 是簽名，包含AWSSecretAccessKey的值，應由後端產生，在下面說明 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;X-Amz-Signature&quot; value=&quot;&lt;Signature-value&gt;&quot; /&gt; File: &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Upload to Amazon S3&quot; /&gt; &lt;/form&gt; &lt;/html&gt; Base64-encoded policy stringPolicy 應由後端產生，他是一個JSON物件，以下是一個例子 123456789101112131415{ &quot;expiration&quot;: &quot;2015-12-30T12:00:00.000Z&quot;, &quot;conditions&quot;: [ {&quot;bucket&quot;: &quot;sigv4examplebucket&quot;}, [&quot;starts-with&quot;, &quot;$key&quot;, &quot;user/user1/&quot;], {&quot;acl&quot;: &quot;public-read&quot;}, {&quot;success_action_redirect&quot;: &quot;http://localhost:8080/uploaded.html&quot;}, // [&quot;starts-with&quot;, &quot;$Content-Type&quot;, &quot;image/&quot;], {&quot;x-amz-meta-uuid&quot;: &quot;14365123651274&quot;}, {&quot;x-amz-server-side-encryption&quot;: &quot;AES256&quot;}, // [&quot;starts-with&quot;, &quot;$x-amz-meta-tag&quot;, &quot;&quot;], {&quot;x-amz-credential&quot;: &quot;AKIAIOSFODNN7EXAMPLE/20151229/us-east-1/s3/aws4_request&quot;}, {&quot;x-amz-algorithm&quot;: &quot;AWS4-HMAC-SHA256&quot;}, {&quot;x-amz-date&quot;: &quot;20151229T000000Z&quot; } ]} expiration 表示這個上傳的Request可用的期限 conditions 設定條件，在檔案上傳前AWS S3會檢查一下，是否和HTML Form中的相符合 bucket Bucket 名稱，此範例為 sigv4examplebucket “starts-with”, “$key” 要放在這個Bucket的 Prefix，此範例為user/user1/ ，在HTML Form中的 key 需要符合在此設定的前綴祠才可以，如 user/user1/myfile.csv acl 設定 S3 ACL， 如設為：public-read 表示可以被公開讀取，也可以設為 private ，表示是私有的 success_action_redirect 上傳成功之後，要導向到哪個網頁，如設為：http://localhost:8080/uploaded.html x-amz-meta-uuid 後端產生的UUID x-amz-server-side-encryption 說明使用哪種加密方式， AES256 “starts-with”, “$Content-Type” 上傳的 content type，可以不設定 x-amz-credential 由 /&lt;日期&gt;/// 組成，RegionService和Signing是固定的就是s3和aws4_request x-amz-algorithm 說明建立這個Request的簽名使用哪種演算法，例如 AWS4-HMAC-SHA256 x-amz-date 建立這個Request的簽名的日期，為可選的，需要為 ISO 8601 basic format (YYYYMMDD’T’HHMMSS’Z’) 格式 注意，如果你在HTML Form中沒有設定某些參數，那麼在Policy中也不要設定，例如我在HTML Form中沒有設定 [&quot;starts-with&quot;, &quot;$Content-Type&quot;, &quot;image/&quot;] 和 [&quot;starts-with&quot;, &quot;$x-amz-meta-tag&quot;, &quot;&quot;]，那麼在 Policy中也不要設定。 之後由後端使用Base64將這段字串編碼，這個Base64字串編碼就是要放在 HTML Form 中的 Policy，以下是Java產生的範例 1234567891011121314151617JSONObject j = new JSONObject();j.put(&quot;expiration&quot;, &quot;2015-12-30T12:00:00.000Z&quot;);j.put(&quot;conditions&quot;, new JSONArray() .put(new JSONObject().put(&quot;bucket&quot;, &quot;sigv4examplebucket&quot;)) .put(new JSONArray().put(&quot;starts-with&quot;).put(&quot;$key&quot;).put(&quot;user/user1/&quot;)) .put(new JSONObject().put(&quot;acl&quot;, &quot;private&quot;)) .put(new JSONObject().put(&quot;success_action_redirect&quot;, &quot;http://localhost:8080&quot;)) .put(new JSONObject().put(&quot;x-amz-meta-uuid&quot;, &quot;14365123651274&quot;)) .put(new JSONObject().put(&quot;x-amz-server-side-encryption&quot;, &quot;AES256&quot;)) .put(new JSONObject().put(&quot;x-amz-credential&quot;, &quot;AKIAIOSFODNN7EXAMPLE/20151229/us-east-1/s3/aws4_request&quot;)) .put(new JSONObject().put(&quot;x-amz-algorithm&quot;, &quot;AWS4-HMAC-SHA256&quot;)) .put(new JSONObject().put(&quot;x-amz-date&quot;, &quot;20151229T000000Z&quot;)));// 這個 Policy 就是要放在 HTML Form 中的 PolicyString policy = Base64.getEncoder().encodeToString(j.toString().getBytes()); Signature-value最後產生 Signature ，Java 可以直接使用有人提供的產生方式，來自 https://gist.github.com/phstudy/3523576726d74a0410f8 12345678910// 在 AccessSecretKey前面要加上 AWS4String accessSecretKey = &quot;AWS4&quot; + &quot;wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY&quot;;String date = &quot;20151229&quot;;String region = &quot;us-east-1&quot;;String regionService = &quot;s3&quot;;String signing = &quot;aws4_request&quot;;String stringToSign = policy;// 這個 signature 字串，就是要放在 HTML Form 中的 X-Amz-SignatureString signature = getSignatureV4(accessSecretKey, date, region, regionService, signing, stringToSign); 以上動作完成之後，還需要為你的Bucket設定 Cross-origin resource sharing (CORS) 12345678910111213141516[ { &quot;AllowedHeaders&quot;: [ &quot;*&quot; ], &quot;AllowedMethods&quot;: [ &quot;POST&quot;, &quot;GET&quot;, &quot;PUT&quot; ], &quot;AllowedOrigins&quot;: [ &quot;http://www.mywebsite.com/&quot; ], &quot;ExposeHeaders&quot;: [] }] Bucket沒有設定Cross-origin resource sharing (CORS)會出現 CORS policy 錯誤 1Access to XMLHttpRequest at 'https://&lt;你的bucket&gt;.s3.amazonaws.com/' from origin 'https://你的網站.com ' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. 如果是還在測試開發的話，可以先將Chrome的web-security關閉，Mac使用以下指令，其他設定可以參考： disable-same-origin-policy-in-chrome 1open -n -a &quot;Google Chrome&quot; --args --user-data-dir=/tmp/temp_chrome_user_data_dir http://localhost:8080/ --disable-web-security Reference: https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-post-example.html https://docs.aws.amazon.com/directconnect/latest/APIReference/CommonParameters.html https://gist.github.com/phstudy/3523576726d74a0410f8 https://stackoverflow.com/questions/3102819/disable-same-origin-policy-in-chrome","link":"/2024/06/13/2024-06-13-browser-base-upload-to-aws-s3/"},{"title":"UV坐標","text":"UV 是一種紋理坐標系統，與物體的空間坐標 (x, y, z) 屬於不同的坐標系。 UV 座標是用來映射紋理到物體表面，它與物體坐標之間存在映射關係，但這種關係不一定是線性或唯一的。 (x, y, z) 是世界或局部空間座標，表示物體在 3D 空間中的位置（Transform 座標），使用笛卡兒坐標系 (U, V) 是 2D 紋理座標，通常在 0~1 範圍內，用來對應貼圖的像素 假設紋理大小是 512x512 但我們不會用 512x512 去做映射，因為 UV 座標的範圍是 0 到 1 之間，所以 512x512 大小的圖片就會被轉換為 uv(0/512,0/512) 至 (512/512,512/512)。這麼做的話即使你的紋理不是 512x512，而是 1024x1024 或其他大小，UV 仍然適用，因為它們代表的是 相對位置，而不是像素座標。 當我們想要檢查 Mesh 的頂點索引、 UV 座標，或三角形組成方式，我們可以使用 MeshFilter 來取得 Mesh 使用 mesh.triangles 可以查看三角形索引 mesh.triangles 是一個 整數陣列，每 3 個數字代表一個三角形的 3 個頂點索引。 這些索引對應到 mesh.vertices 陣列中的頂點。 使用 mesh.vertices 找到 頂點的 3D 位置 mesh.vertices 是一個 Vector3[] 陣列，存放 Mesh 的每個頂點在 世界空間中的 3D 座標。 這些頂點的 順序對應 mesh.triangles 的索引 使用 mesh.uv 來查看 UV 座標 mesh.uv 是一個 Vector2[] 陣列，存放 Mesh 每個頂點對應的 UV 座標。 UV 是 貼圖座標，範圍通常是 (0,0) 到 (1,1)，但如果是 貼圖 Atlas 或特殊映射方式，可能會超出這個範圍。 接下來我們建立一個 Quad 並設定他的 Materail 試試看。 建立一個 512x512 的圖片 建立一個 Material ， 將其設為 Unlit/Texture ，在把 512x512 的圖片放到這個 Material 中。 建立一個 Quad ， 並將剛剛建立的 Material 賦給這個 Quad Unity 中 Quad（矩形）通常有 4 個頂點，在 Unity 內部，它其實是由兩個三角形組成的。 在 Quad GameObject 上建立一個 Script123456789101112131415161718192021222324252627282930313233343536public class Test : MonoBehaviour{ Mesh mesh; public Vector2[] uvs; private void Awake() { uvs = new Vector2[4]; uvs[0] = new Vector2(0f, 0.75f); // 左下 uvs[1] = new Vector2(0.25f, 0.75f); // 右下 uvs[2] = new Vector2(0f, 1); // 左上 uvs[3] = new Vector2(0.25f, 1); // 右上 mesh = GetComponent&lt;MeshFilter&gt;().mesh; for (int i = 0; i &lt; mesh.vertexCount; i++) { Debug.Log($&quot;頂點索引 {i} 的 3D 位置: {mesh.vertices[i]}&quot;); } for (int i = 0; i &lt; mesh.triangles.Length; i += 3) { Debug.Log($&quot;三角形 {i / 3}: {mesh.triangles[i]}, {mesh.triangles[i + 1]}, {mesh.triangles[i + 2]}&quot;); } } private void LateUpdate() { mesh.SetUVs(0, uvs); }} 執行，會發現顯示的是紅色1的區塊，這是因為我們設定了以下 UV 座標，對照下圖可以清楚看到 (0,0.75) , (0.25,0.75) , (0,1) , (0.25,1) 就是 紅色1 的區塊。 uvs[0] = new Vector2(0f, 0.75f); // 左下 uvs[1] = new Vector2(0.25f, 0.75f); // 右下 uvs[2] = new Vector2(0f, 1); // 左上 uvs[3] = new Vector2(0.25f, 1); // 右上 使用 mesh.triangles 可以查看三角形索引1234for (int i = 0; i &lt; mesh.triangles.Length; i += 3){ Debug.Log($&quot;三角形 {i / 3}: {mesh.triangles[i]}, {mesh.triangles[i + 1]}, {mesh.triangles[i + 2]}&quot;);} 會印出 三角形 0: 0, 3, 1 三角形 1: 3, 0, 2這表示有兩個三角形， 第一個三角形 0 的頂點索引是 0, 3, 1 第二個三角形 0 的頂點索引是 3, 0, 2 之後我們可以使用 mesh.vertices 找到 頂點的 3D 位置1234for (int i = 0; i &lt; mesh.vertexCount; i++){ Debug.Log($&quot;頂點索引 {i} 的 3D 位置: {mesh.vertices[i]}&quot;);} 會印出 頂點索引 0 的 3D 位置: (-0.50, -0.50, 0.00) 頂點索引 1 的 3D 位置: (0.50, -0.50, 0.00) 頂點索引 2 的 3D 位置: (-0.50, 0.50, 0.00) 頂點索引 3 的 3D 位置: (0.50, 0.50, 0.00) 將 Quad 放到坐標系上看就很清楚了 參考 https://blog.csdn.net/valaki/article/details/122910129?spm=1001.2014.3001.5501","link":"/2024/06/15/2024-06-15-uv/"},{"title":"FormerlySerializedAs","text":"FormerlySerializedAs 是 Unity 中的一個屬性(attribute)，用於處理欄位的重新命名。當重新命名一個序列化的欄位時，Unity 通常會失去對舊名的參考，導致序列化出現問題。使用 FormerlySerializedAs 可以告诉 Unity 欄位之前的名稱，從而正確地反序列化。 以下為修改範例：在 BaseEntity 類別中有一個 HP 欄位以及一個 ItemData 欄位，並且已經在 Inspector 上更改過它們的值 1234567891011public class BaseEntity : MonoBehaviour{ public int HP = 0; public Item ItemData;}public class Item : MonoBehaviour{ // ...} 此時，想要更改欄位的名稱，如果直接重新命名這些欄位的話，在 Inspector 會丟失這些值， 使用 FormerlySerializedAs 告訴 Unity 欄位之前叫什麼。當編譯後，Unity 會幫我們將值對應到對應到新的欄位上。 12345678public class BaseEntity : MonoBehaviour{ [FormerlySerializedAs(&quot;HP&quot;)] public int Hp = 0; [FormerlySerializedAs(&quot;ItemData&quot;)] public Item Item;} 確認更新之後沒問題，可將 FormerlySerializedAs 刪除，但記得要在大家都更新完之後再做刪除的動作。 Reference: https://docs.unity3d.com/ScriptReference/Serialization.FormerlySerializedAsAttribute.html","link":"/2024/06/16/2024-06-16-formerlyserializedas/"},{"title":"預製物件(Prefab)","text":"PrefabUnity 中的預製物件(Prefab)，讓你可以儲存一個遊戲物件(GameObject)，這個預製物件(Prefab)會包含該遊戲物件的所有組件(Component)，屬性值(property values)，以及它的子遊戲物件，並且可以建立，更改它的設定，就像是一個可重用的資源(Asset)。預製物件資源(Prefab Asset)就像是一個模板(template)，讓你在場景中(Scene)添加預製物件實體(Prefab instance) 任何在 Prefab Asset 的更改，都會自動反應(reflected)到該預製物件的實體上。 預製物件中也可以含有預製物件，這稱為 Nest Prefabs Unity 2018.3b 以後的版本支援 Nest Prefabs 預製物件的實體值可以被覆蓋(override)，讓每個預製物件的實體可以有不同的行為 如果在執行期間(runtime)才加入的遊戲物件，那麼這個遊戲物件可以把它變為預製物件，例如子彈，NPC等只會在遊戲期間出現的物件 當你想要在你的遊戲專案中重用遊戲物件(GameObject)，例如非玩家角色(non-player character (NPC))，或是一些道具，應該把這個遊戲物件變為預製物件(Prefab)，因為Unity的Prefab System會自動幫你同步遊戲物件的資料，讓這些有相同預製物件的實體有同樣的資料。以下常見使用預製物件的例子 環境資源(Environmental Assets)：例如在關卡中心顯示多次的樹。 非玩家角色(NPCs)：例如某種機器人，出現在關卡中多次，他們以透過覆蓋(override)在移動速度，發出聲音上有所不同。 拋射物(Projectiles)：如子彈，箭等，像是海盜船的砲台開火時，要產生一個砲彈實體 主要玩家角色：玩家在每個不同的場景中都會出現在一個開始點上，因此很適將它變為預製物件 建立 Prefab Asset在 Unity 中建立預製物件資源(Prefab Asset)的方式非常簡單，在Unity編輯器中，將在 Hierarchy window 中的物件使用滑鼠左鍵拖曳到下方的 Project window 即可。操作完成的同時會發現原先的遊戲物件變為淡藍色的，表示它變為預製物件(Prefab instance)了 Reference: https://docs.unity3d.com/Manual/Prefabs.html","link":"/2024/06/17/2024-06-17-prefab/"},{"title":"ScriptableObject 基礎","text":"ScriptableObject 是一個資料容器(Data container)，它透過共享通用資料的方式來減少對重複資料的記憶體佔用，進而降低你APP的記憶體使用量。 如果你的預製物件(Prefab)中儲存了一些不會改變的資料，那麼很適合把它們改為使用 ScriptableObject ，因為每當你實體化(instantiate)一個預製物件(Prefab)時，這個實體會保存自己的一份資料，當實體化很多個實體時，會有很多重複的資料佔用很多記憶體，因此你可以使用 ScriptableObject 可以把資料儲存起來，然後讓所有的預製物件(Prefab)存取這個 ScriptableObject 。 ScriptableObject 和 MonoBehaviour 一樣，繼承了 UnityEngine.Object ，但是與 MonoBehaviour 不同在於你不能把 ScriptableObject 附加(attach)到一個 GameObject 上，也不能進行 GatComponent 等對 GameObject 的操作，相反你需要把它儲存為資源(Asset)。 在使用Unity編輯器時，你可以把資料放在 ScriptableObject ，在執行時也可以調整其中的資料，但是你不可以把它當作遊戲存檔的工具。 使用 ScriptableObject 主要情況是在編輯時期修改 ScriptableObject 的資料，在執行時這些資料會被當作資源(Asset)使用。 使用方式建立一個類並繼承 ScriptableObject，你可以使用 CreateAssetMenu 屬性(attribute)，讓你方便在編輯器中使用，以下是一個範例： 12345678[CreateAssetMenu(fileName = &quot;Data&quot;, menuName = &quot;ScriptableObjects/SpawnManagerScriptableObject&quot;, order = 1)]public class SpawnManagerScriptableObject : ScriptableObject{ public string prefabName; public int numberOfPrefabsToCreate; public Vector3[] spawnPoints;} 之後，你可以在 Assets -&gt; Create -&gt; ScriptableObjects -&gt; SpawnManagerScriptableObject 中建立新的 ScriptableObject 實體。 你可以更改該實體的名稱與它的屬性。 接下來你可以在 MonoBehaviour 中使用這個 ScriptableObject 實體，如下 1234567891011121314151617181920212223242526272829303132333435using UnityEngine;public class Spawner : MonoBehaviour{ // 要實體化 Prefab 的參考 public GameObject entityToSpawn; // 一個 ScriptableObject 的參考 public SpawnManagerScriptableObject spawnManagerValues; // 記錄了實體化了多少個實體 int instanceNumber = 1; void Start() { SpawnEntities(); } void SpawnEntities() { int currentSpawnPointIndex = 0; for (int i = 0; i &lt; spawnManagerValues.numberOfPrefabsToCreate; i++) { // 使用 ScriptableObject 中的資料 GameObject currentEntity = Instantiate(entityToSpawn, spawnManagerValues.spawnPoints[currentSpawnPointIndex], Quaternion.identity); currentEntity.name = spawnManagerValues.prefabName + instanceNumber; currentSpawnPointIndex = (currentSpawnPointIndex + 1) % spawnManagerValues.spawnPoints.Length; instanceNumber++; } }} 在Unity編輯器中，使用拖拉的方式將剛剛建立好的 ScriptableObject 實體拖拉到對應的位置上，另外 Box Prefab 是一個簡單的Square 最後在執行Unity，就可以看到Unity使用剛剛建立出來 ScriptableObject 資料去產生 Box 物件。 此外除了在編輯器中建立 實體，在執行期間也可以透過 CreateInstance 來建立。 1ScriptableObject.CreateInstance&lt;MyScriptableObjectClass&gt;(); MonoBehaviour 與 ScriptableObject 的比較 MonoBehaviour ScriptableObject MonoBehaviour 接收所有來自 Unity 的 callback，像是 Start ， Awake ， Update ， OnEnable ，OnDisabl ， OnCollisonEnter 等 ScriptableObject 只接收一些： Awake ， OnEnable ， OnDestroy 與 OnDisable 。 在 Editor 中的話還有 OnValidate 與 Reset MonoBehaviour 必須要 附加(attach)到 GameObject 上 ScriptableObject 不能附加到 GameObject 上，需要在專案(Project Level)中將它們儲存為 asset 檔案，在其他腳本中參考這些 ScriptableObject asset 當儲存 MonoBehaviour 時，會將它們的資料儲存到 Scenes 與 Prefabs 中 每個 ScriptableObject 實體都會被保存為專案層級(Project level)的獨立檔案中 一般在 Play Mode 中修改 MonoBehaviour 中的值之後離開 Play Mode 的話，這些值會被重新設定(Reset) 當離開 Play Mode 後， ScriptableObject 則不會重新設定。此外當編譯發布之後，執行期間 ScriptableObject 修改的值不會被保存，而是為發布時的值 在 ScriptableObject 中只有以下的 callback 會被呼叫 Awake ： 與 MonoBehaviour 的類似，只有在 ScriptableObject 開始時會被呼叫。當遊戲執行(launched)或是有參考到這個 ScriptableObject asset 的 Scene 被載入時會呼叫。 OnEnable ： 在 Awake 之後呼叫，當 ScriptableObject 被載入(Loaded)或是實體化(Instantiated)時會被呼叫。當 ScriptableObject.CreateInstance 或是 script 被重新編譯(recompilation)時 OnEnable 會被呼叫。 OnDisable ： 當載入的 Scene 不再參考這個 ScriptableObject asset 時，就會呼叫 OnDisable ， 它會在 OnDestory 之前被呼叫。此外在 script 重新編譯進入 Play Mode 時，也會呼叫，此時會出現 OnDisable 出現在 OnEnable 的情況。 OnDestory ： 當 ScriptableObject 在 編輯器中刪除，或是重程式碼中刪除時，會呼叫 OnDestory 。如果是在執行期間建立的 ScriptableObject 在APP離開或是離開 Play Mode 時也會呼叫。 以下 callback 只在編輯器中呼叫 OnValidate ： 當值在 Inspector 中改變值，才會呼叫。可以在這邊確保你的編輯器輸入的資料是合適的範圍(如 0 ~ 1)。 Reset ： 當點擊 Inspector 中的 Reset 按鈕時，會呼叫。 返回 ScriptableObject 系列 Reference: https://docs.unity3d.com/Manual/class-ScriptableObject.html","link":"/2024/06/19/2024-06-19-scriptableobject/"},{"title":"ScriptableObject as Event","text":"ScriptableObject 可以用來作為事件系統的一部分。這種方法可以幫助我們在不同的 MonoBehaviour 之間進行通信，而不需要它們彼此知道對方的存在，從而實現鬆耦合。 為觀察者模式(Observer Pattern)的一種實作 首先要建立 GameEvent 與 GameEventListener 。它們兩個互相依賴 GameEvent 含有一個 GameEventListener 列表用來保存要聽取該事件的聽眾， 使用 RegisterListener 來註冊聽眾 使用 UnregisterListener 將聽眾移出 使用 Raise 觸發聽眾註冊的事件123456789101112131415161718192021222324[CreateAssetMenu(menuName = &quot;ScriptableObjects/GameEvent&quot;, order = 1)]public class GameEvent : ScriptableObject{ private readonly List&lt;GameEventListener&gt; eventListeners = new List&lt;GameEventListener&gt;(); public void Raise() { for (int i = eventListeners.Count - 1; i &gt;= 0; i--) eventListeners[i].OnEventRaised(); } public void RegisterListener(GameEventListener listener) { if (!eventListeners.Contains(listener)) eventListeners.Add(listener); } public void UnregisterListener(GameEventListener listener) { if (eventListeners.Contains(listener)) eventListeners.Remove(listener); }} GameEventListener 含有一個要監聽的事件參考 Event 含有一個當監聽到後，要做出的回應 Response OnEnable 中將自己註冊到 Event 中 OnDisable 中將自己從 Event 中移出 OnEventRaised 中呼叫回應的方法 1234567891011121314151617181920212223public class GameEventListener : MonoBehaviour{ [Tooltip(&quot;Event to register with.&quot;)] public GameEvent Event; [Tooltip(&quot;Response to invoke when Event is raised.&quot;)] public UnityEvent Response; private void OnEnable() { Event.RegisterListener(this); } private void OnDisable() { Event.UnregisterListener(this); } public void OnEventRaised() { Response.Invoke(); }} 接著在 Unity 編輯器中建立一個 ScriptableObject 實體，並命名為 ClickEvent 建立一個 DoSomethingWhenClick 的遊戲物件(GameObject) ，並添加以下腳本，這個遊戲物件有一個公開方法 JustDoIt，當事件發生時，要被呼叫。 1234567public class DoSomethingWhenClick : MonoBehaviour{ public void JustDoIt() { Debug.Log(&quot;Just Do It&quot;); }} 建立一個 EventListener 的 GameObject，將 GameEventListener 腳本添加到這個 EventListener GameObject 中。 接下來將前面建立的 ScriptableObject 實體 ClickEvent ，拖放到，EventListener 中的 Event 欄位，表示這個 EventListener 要監聽的事件是 ClickEvent 然後設定聽到之後要做的事。將 DoSomethingWhenClick 遊戲物件放到 Response 欄位，並設定要執行該物件的公開方法 JustDoIt 接著建立事件發起的物件，這邊建立兩個， RaiseClickableCircle 與 RaiseClickableButWithUnityEvent RaiseClickableCircle 的腳本如下，它主要是直接使用 GameEvent 作為參考，其缺點是只能用一個 Event 12345678910public class RaiseClickableCircle : MonoBehaviour{ public GameEvent ClickGameEvent; void OnMouseDown() { ClickGameEvent.Raise(); }} RaiseClickableButWithUnityEvent 幾乎與 RaiseClickableCircle 一模一樣，差別在於是使用 UnityEvent ，這樣可以放置多個 Event，當觸發 Raise 時在裡面的 Event 都會觸發。 123456789public class RaiseClickableButWithUnityEvent : MonoBehaviour{ public UnityEvent ClickEvent; void OnMouseDown() { ClickEvent.Invoke(); }} 最後執行，並點擊畫面上的圓形或是方形，可以發現都會觸發 DoSomethingWhenClick 的 JustDoIt 方法，而 RaiseClickableButWithUnityEvent ， RaiseClickableCircle 與 DoSomethingWhenClick 完全不知曉對方的存在。 使用基於事件架構(event-based architecture)的好處是，它不會每一幀都在執行，只有在當事件發生時才會執行，因此效率會比在 MonoBehaviour 的 Update 方法中執行好。 返回 ScriptableObject 系列 Reference: https://unity.com/cn/how-to/architect-game-code-scriptable-objects#architect-other-systems","link":"/2024/06/20/2024-06-20-scriptableobject-as-event/"},{"title":"State Pattern","text":"狀態模式(State pattern)： 當物件的內部狀態改變時，物件的行為也會隨之改變，即物件會根據當前狀態執行不同的行為。 每個狀態的行為是獨立定義的。添加新狀態不會影響現有狀態的行為。 在遊戲中會需要不斷地追蹤遊戲中的各種狀態，例如玩家走路(Walking)，跳躍(Jumping)，待命(Idle或Standing)等。若你把它畫成流程圖(flowchart)可能會發現 一次只有一個狀態會被啟用(Active) 狀態會依據不同的條件去轉換到另外一個狀態 當轉換發生時，新的狀態會成為啟用狀態(Active state) 這種狀態轉換圖被稱為有限狀態機(Finite state machine，FSM) 以下是一個使用Enum去實作的簡單有限狀態機： 123456public enum PlayerControllerState{ Idle, Walk, Jump} 在這個Controller類中，使用switch轉換狀態，很快你會發現當狀態越來越多後，Controller會變得一團亂，例如增加幾個狀態，就必須要不斷的更改Controller： 123456789101112131415161718192021222324252627282930313233343536public class UnrefactoredPlayerController : MonoBehaviour{ private PlayerControllerState state; private void Update() { GetInput(); switch (state) { case PlayerControllerState.Idle: Idle(); break; case PlayerControllerState.Walk: Walk(); break; case PlayerControllerState.Jump: Jump(); break; } } private void GetInput() { // 處理行走和跳躍控制 } private void Walk() { // 行走邏輯 } private void Idle() { // 待命邏輯 } private void Jump() { // 跳躍邏輯 }} 使用狀態模式，在遊戲中，你可以想像處理角色狀態需要： 當條件滿足時，第一次進入(Enter)這個狀態時需要處理一些事。 在遊戲迴圈中根據這個狀態不斷的更新(Update)角色的值。 當條件不滿足或是滿足某些離開條件時，離開(Exit)這個狀態時，要在離開前處理一些事。因此根據這樣的流程定義一個抽象介面(Interface)，IState並定義它有以下方法： Enter：第一次進入這個狀態時需要做的邏輯 Update： 在每一幀中需要執行的邏輯(有時也稱Exceute或Tick)。它會根據這個狀態在每一幀中不斷的更新角色的值。 Exit：在離開這個狀態前要做的邏輯123456789101112131415public interface IState{ public void Enter() { // 當第一次進入狀態時運行的邏輯 } public void Update() { // 每幀邏輯，包括轉換到新狀態的條件 } public void Exit() { // 當離開狀態時運行的邏輯 }} 行走狀態：在這個狀態中，Update()會不斷地移動這個角色，另外也會判斷是否要切換到其他狀態。 123456789101112131415161718192021222324252627282930313233343536373839public class WalkState : IState{ private Color meshColor = Color.blue; public Color MeshColor { get =&gt; meshColor; set =&gt; meshColor = value; } private PlayerController player; // 可以在建構子中傳遞任何需要的參數 public WalkState(PlayerController player) { this.player = player; } public void Enter() { //Debug.Log(&quot;Entering Walk State&quot;); } public void Update() { // 如果不再在地面上，轉換到跳躍狀態 if (!player.IsGrounded) { player.PlayerStateMachine.TransitionTo(player.PlayerStateMachine.jumpState); } // 如果速度降到最低臨界值以內，轉換到待命狀態 if (Mathf.Abs(player.CharController.velocity.x) &lt; 0.1f &amp;&amp; Mathf.Abs(player.CharController.velocity.z) &lt; 0.1f) { player.PlayerStateMachine.TransitionTo(player.PlayerStateMachine.idleState); } } public void Exit() { //Debug.Log(&quot;Exiting Walk State&quot;); }} 待命狀態 12345678910111213141516171819202122232425262728293031323334353637public class IdleState : IState{ private PlayerController player; private Color meshColor = Color.gray; public Color MeshColor { get =&gt; meshColor; set =&gt; meshColor = value; } public IdleState(PlayerController player) { this.player = player; } public void Enter() { Debug.Log(&quot;Entering Idle State&quot;); } public void Update() { // 如果不再在地面上，轉換到跳躍狀態 if (!player.IsGrounded) { player.PlayerStateMachine.TransitionTo(player.PlayerStateMachine.jumpState); } // 如果速度超過臨界值，轉換到移動狀態 if (Mathf.Abs(player.CharController.velocity.x) &gt; 0.1f || Mathf.Abs(player.CharController.velocity.z) &gt; 0.1f) { player.PlayerStateMachine.TransitionTo(player.PlayerStateMachine.walkState); } } public void Exit() { Debug.Log(&quot;Exiting Idle State&quot;); }} StateMachine負責管理這些狀態 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class StateMachine{ public IState CurrentState { get; private set; } // 目前狀態 // 狀態物件的引用 public WalkState walkState; public JumpState jumpState; public IdleState idleState; // 用於通知其他物件狀態改變的事件 public event Action&lt;IState&gt; stateChanged; // 由於沒有繼承 MonoBehaviour，因此需要通過建構子將 PlayerController 傳入 public StateMachine(PlayerController player) { // 建立每個狀態的實體並傳遞 PlayerController this.walkState = new WalkState(player); this.jumpState = new JumpState(player); this.idleState = new IdleState(player); } // 設置初始狀態 public void Initialize(IState state) { CurrentState = state; state.Enter(); // 通知其他物件狀態已改變 stateChanged?.Invoke(state); } // 退出目前狀態並進入另一個狀態 public void TransitionTo(IState nextState) { CurrentState.Exit(); CurrentState = nextState; nextState.Enter(); // 通知其他物件狀態已改變 stateChanged?.Invoke(nextState); } public void Update() { if (CurrentState != null) { CurrentState.Update(); } }} 在Controller中使用StateMachine 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125[RequireComponent(typeof(PlayerInput), typeof(CharacterController))]public class PlayerController : MonoBehaviour{ [SerializeField] private PlayerInput playerInput; private StateMachine playerStateMachine; [Header(&quot;Movement&quot;)] [Tooltip(&quot;Horizontal speed&quot;)] [SerializeField] private float moveSpeed = 5f; [Tooltip(&quot;Rate of change for move speed&quot;)] [SerializeField] private float acceleration = 10f; [Tooltip(&quot;Max height to jump&quot;)] [SerializeField] private float jumpHeight = 1.25f; [Tooltip(&quot;Custom gravity for player&quot;)] [SerializeField] private float gravity = -15f; [Tooltip(&quot;Time between jumps&quot;)] [SerializeField] private float jumpTimeout = 0.1f; [SerializeField] private bool isGrounded = true; // 是否在地面上 [SerializeField] private float groundedRadius = 0.5f; // 檢查是否在地面的半徑 [SerializeField] private float groundedOffset = 0.15f; [SerializeField] private LayerMask groundLayers; public CharacterController CharController =&gt; charController; public bool IsGrounded =&gt; isGrounded; public StateMachine PlayerStateMachine =&gt; playerStateMachine; private CharacterController charController; private float targetSpeed; private float verticalVelocity; private float jumpCooldown; private void Awake() { playerInput = GetComponent&lt;PlayerInput&gt;(); charController = GetComponent&lt;CharacterController&gt;(); // 初始化狀態機 playerStateMachine = new StateMachine(this); } private void Start() { playerStateMachine.Initialize(playerStateMachine.idleState); // 設置初始狀態為 idleState } private void Update() { // 使用目前狀態更新角色資料 playerStateMachine.Update(); } private void LateUpdate() { CalculateVertical(); Move(); } private void Move() { Vector3 inputVector = playerInput.InputVector; if (inputVector == Vector3.zero) { targetSpeed = 0; } float currentHorizontalSpeed = new Vector3(charController.velocity.x, 0.0f, charController.velocity.z).magnitude; float tolerance = 0.1f; if (currentHorizontalSpeed &lt; targetSpeed - tolerance || currentHorizontalSpeed &gt; targetSpeed + tolerance) { targetSpeed = Mathf.Lerp(currentHorizontalSpeed, targetSpeed, Time.deltaTime * acceleration); targetSpeed = Mathf.Round(targetSpeed * 1000f) / 1000f; } else { targetSpeed = moveSpeed; } charController.Move((inputVector.normalized * targetSpeed * Time.deltaTime) + new Vector3(0f, verticalVelocity, 0f) * Time.deltaTime); } private void CalculateVertical() { if (isGrounded) { if (verticalVelocity &lt; 0f) { verticalVelocity = -2f; } if (playerInput.IsJumping &amp;&amp; jumpCooldown &lt;= 0f) { verticalVelocity = Mathf.Sqrt(jumpHeight * -2f * gravity); } if (jumpCooldown &gt;= 0f) { jumpCooldown -= Time.deltaTime; } } else { jumpCooldown = jumpTimeout; playerInput.IsJumping = false; } verticalVelocity += gravity * Time.deltaTime; Vector3 spherePosition = new Vector3(transform.position.x, transform.position.y + groundedOffset, transform.position.z); isGrounded = Physics.CheckSphere(spherePosition, 0.5f, groundLayers, QueryTriggerInteraction.Ignore); } private void OnDrawGizmosSelected() { Color transparentGreen = new Color(0.0f, 1.0f, 0.0f, 0.35f); Color transparentRed = new Color(1.0f, 0.0f, 0.0f, 0.35f); Gizmos.color = isGrounded ? transparentGreen : transparentRed; Gizmos.DrawSphere(new Vector3(transform.position.x, transform.position.y + groundedOffset, transform.position.z), groundedRadius); }} Reference: https://github.com/Unity-Technologies/game-programming-patterns-demo/tree/main/Assets/10%20State/Scripts","link":"/2024/05/27/2024-05-27-state-pattern/"},{"title":"ScriptableObject as shared variable","text":"ScriptableObject 可以作為遊戲變數在各個 MonoBehaviour 之間分享資料，此外，透過這種方式還可以減少 MonoBehaviour 物件之間互相參考的耦合度。 下面將使用 ScriptableObject 建立玩家生命數值，並在不同的 MonoBehaviour之間使用 首先建立一個繼承 ScriptableObject 的類 FloatVariable 1234567891011121314151617181920212223242526272829[CreateAssetMenu(menuName = &quot;ScriptableObjects/FloatVariable&quot;, order = 1)]public class FloatVariable : ScriptableObject{#if UNITY_EDITOR [Multiline] public string DeveloperDescription = &quot;&quot;;#endif public float Value; public void SetValue(float value) { Value = value; } public void SetValue(FloatVariable value) { Value = value.Value; } public void ApplyChange(float amount) { Value += amount; } public void ApplyChange(FloatVariable amount) { Value += amount.Value; }} 接下來建立兩個 FloatVariable 實體， HP 與 MaxHP 然後建立繼承 MonoBehaviour 的 Player 類 123456789101112131415161718192021public class Player : MonoBehaviour{ public FloatVariable CurrentHP; public FloatVariable MaxHP; public float StartingHP; public bool ResetHP; private void Start() { if (ResetHP) { CurrentHP.SetValue(StartingHP); } } // 暴露給外部，這邊會綁定按鈕的 On Click 事件 public void Hurt() { CurrentHP.ApplyChange(-10); }} 在 Unity 編輯器中，將剛剛建立的 HP 與 MaxHP 設定到 Player 上 接著建立一個 HPView 1234567891011121314public class HPView : MonoBehaviour{ public TextMeshProUGUI CurrentHPText; public TextMeshProUGUI MaxHPText; public FloatVariable CurrentHP; public FloatVariable MaxHP; private void Update() { CurrentHPText.text = CurrentHP.Value.ToString(); MaxHPText.text = MaxHP.Value.ToString(); }} 在 Unity 編輯器中，將 HP 與 MaxHP 設定到 HPView 上， 將 Player.Hurt() 設定給按鈕的 On Click 。 最後執行，在畫面上可以按下按鈕，觸發 Player.Hurt() ，可以觀察到 CurrentHPText 的變化 並且可以發現這兩個 MonoBehaviour： Player 和 HPView 互相不知道彼此的存在，實現了鬆耦合(loosely coupled)。 返回 ScriptableObject 系列 Reference: https://www.youtube.com/watch?v=raQ3iHhE_Kk https://unity.com/cn/how-to/architect-game-code-scriptable-objects#architect-other-systems https://home.gamer.com.tw/creationDetail.php?sn=4819112","link":"/2024/06/20/2024-06-20-scriptableobject-as-shared-variable/"},{"title":"ScriptableObject as Runtime Set","text":"RuntimeSet 的做法是將 ScriptableObject 作為一個分享集合容器，在執行期間，將物件放入，讓其他要使用它的物件可以透過這個分享容器拿到。 以下的例子中，將建立一個 GameObjectRuntimeSet ，這個 GameObjectRuntimeSet 將會在執行時持有 Circle 物件集合，而 Circle 物件將由 CreateObject 建立，而 ObjectMonitor 負責查看 GameObjectRuntimeSet 中有多少 Circle 物件 以下建立一個通用抽象類 RuntimeSet 它繼承 ScriptableObject 12345678910111213141516171819202122232425262728public abstract class RuntimeSet&lt;T&gt; : ScriptableObject{ protected readonly List&lt;T&gt; Items = new(); public int Count =&gt; Items.Count; public void Add(T thing) { if (!Items.Contains(thing)) Items.Add(thing); } public bool Remove(T thing) { return Items.Remove(thing); } public T this[int index] { get =&gt; Items[index]; set =&gt; Items[index] = value; } public void Clear() { Items.Clear(); }} 接著繼承 RuntimeSet 建立一個 GameObjectRuntimeSet ， 這個 GameObjectRuntimeSet 將為 GameObject 的分享集合容器 1234[CreateAssetMenu(menuName = &quot;ScriptableObjects/GameObjectRuntimeSet&quot;)]public class GameObjectRuntimeSet : RuntimeSet&lt;GameObject&gt;{} 在 Unity 編輯器中建立一個 ScriptableObject 實體 CircleRuntimeSet 接著建立要放到這個集合的物件 Circle ，在 OnEnable 時將自己加入集合， OnDisable 時將自己從集合中移除 1234567891011121314public class Circle : MonoBehaviour{ public GameObjectRuntimeSet GameObjectRuntimeSet; private void OnEnable() { GameObjectRuntimeSet.Add(this.gameObject); } private void OnDisable() { GameObjectRuntimeSet.Remove(this.gameObject); }} 把 ScriptableObject 實體 CircleRuntimeSet 設定到 Circle 的 GameObjectRuntimeSet 中，讓 Circle 知道在 OnEnable 時要放入哪個集合。之後，把 Circle 轉為 Prefab 再建立一個製造Circle的 CreateObject，這邊建立一個按鈕，當按下時，會觸發 CreateObject.Create() 123456789101112131415public class CreateObject : MonoBehaviour{ public GameObject circle; public void Create() { float randomX = Random.Range(-6f, 6f); float randomY = Random.Range(-6f, 6f); Vector3 randomPosition = new Vector3(randomX, randomY, 0f); Instantiate(circle, randomPosition, Quaternion.identity); }} 最後建立一個觀看這個集合的物件 1234567891011public class ObjectMonitor : MonoBehaviour{ public GameObjectRuntimeSet GameObjectRuntimeSet; public void Update() { Debug.Log(&quot;Current objects in the set &quot; + GameObjectRuntimeSet.Count); }} 觀察結果每按下按鈕一次，所產生的 Circle 物件都會加入 GameObjectRuntimeSet ，而需要知道有多少個 Circle 的物件，它只要從 GameObjectRuntimeSet 裏面就可以找到目前有多少 Circle 物件。 總結 RuntimeSet 將 ScriptableObject 作為分享的集合容器。 它可以避免使用 Singleton 來管理物件群 它避免了使用 Object.FindObjectOfType 或 GameObject.FindWithTag 等開銷可能會比較大的方法來搜尋物件 返回 ScriptableObject 系列 Reference: https://kendevlog.wordpress.com/2017/12/04/unity%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%989-%E6%9B%B4%E5%A4%9Ascriptableobject%E7%9A%84%E5%A6%99%E7%94%A8/","link":"/2024/06/21/2024-06-21-scriptableobject-runtime-set/"},{"title":"偵測螢幕解析度","text":".screen-container { background: #ffffff; border-radius: 10px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); padding: 20px; text-align: center; } .screen-h2 { color: #333333; margin-bottom: 20px; } .screen-button { background-color: #007bff; color: white; padding: 5px 10px; margin-left: 10px; border: none; border-radius: 5px; cursor: pointer; } 解析度資訊 您的螢幕解析度為： 複製 您的瀏覽器內部目前寬高為： 複製 User Agent： 複製 var screenWidth = Math.floor(screen.width * window.devicePixelRatio); var screenHeight = Math.floor(screen.height * window.devicePixelRatio); var windowWidth = window.innerWidth; var windowHeight = window.innerHeight; document.getElementById(\"screenResolution\").innerText = screenWidth + \" x \" + screenHeight; document.getElementById(\"windowResolution\").innerText = windowWidth + \" x \" + windowHeight; var userAgent = navigator.userAgent; document.getElementById(\"userAgentInfo\").innerText = userAgent; function copyToClipboard(elementId) { var text = document.getElementById(elementId).innerText; var tempInput = document.createElement(\"input\"); tempInput.style = \"position: absolute; left: -1000px; top: -1000px\"; tempInput.value = text; document.body.appendChild(tempInput); tempInput.select(); document.execCommand(\"copy\"); document.body.removeChild(tempInput); alert(\"已複製: \" + text); }","link":"/2024/06/21/2024-06-21-%E5%81%B5%E6%B8%AC%E8%9E%A2%E5%B9%95%E8%A7%A3%E6%9E%90%E5%BA%A6/"},{"title":"閱讀Level Up Your Code With Game Programming Patterns","text":"這本 Unity 的電子書《Level up your code with game programming patterns》 對於提升遊戲開發者的程式設計能力非常有幫助。以下是該電子書的網址與Github網址：https://blog.unity.com/games/level-up-your-code-with-game-programming-patternsGithub：https://github.com/Unity-Technologies/game-programming-patterns-demo/tree/main 這本書介紹了工程師必須了解的SOLID 原則(SOLID principles)，這些原則是編寫高質量程式碼的基礎，SOLID原則是以下五大原則的簡稱： 單一職責原則(Single responsibility)：確保類只負責一件事。 開閉原則(Open-closed)：在不更改現有程式碼的情況下，可以擴展一個類的功能。 里氏替換原則(Liskov substitution)：子類可以替代基類，而不影響程式的正確性。 介面隔離原則(Interface segregation)：讓介面(interface)盡可能簡單，確保實作類只需要實作其所需的介面方法。 依賴倒置原則(Dependency inversion)：高層模組不應依賴於低層模組，兩者都應依賴於抽象。具體實現應依賴於抽象，而不是抽象依賴於具體實現。 這些原則可以讓你的程式設計更具彈性和可維護性，但在不確定是否要使用它們時，請記住KISS（Keep It Simple, Stupid）原則，不要強迫將其應用於程式碼中。 這本電子書也介紹了以下常用在遊戲開發中的設計模式 工廠模式(Factory pattern)：把生成物件的邏輯封裝起來，讓一個特別的物件(工廠Factory)去建立其他物件(產品Product)。 物件池模式(Object Pool pattern)：預先建立一組物件並存放在池中，重用這些物件以減少資源浪費。 單例模式(Singleton pattern)：確保一個特別的類只有一個並可全局訪問的實體。 命令模式(Command Pattern)：將一系列特定動作封裝為命令物件(Command object)，讓這些命令可以撤銷(undo)或是重做(redo) 狀態模式(State Pattern)：讓物件的行為隨內部狀態改變而改變。 觀察者模式(Observer pattern)：當一個物件的狀態改變時，會自動通知所有想要接收此訊息的物件。 MVP模式(Model-View-Presenter)：MVP模式是使用者介面設計模式的一種，它是MVC模式的一種衍生模式，在此模式中，Presenter充當了Model和View之間的橋樑。由Presenter在View與Model之間雙向通信，但View與Model不通信 MVVM模式(Model-View-ViewModel)：MVVM模式是使用者介面設計模式的一種，它是MVC模式的一種衍生模式，它透過觀察者模式(Observer pattern)將 View 與 ViewModel 連接在一起， 在 ViewModel 中進行資料綁定(data binding)。當 View Model 的狀態改變時自動通知 View。","link":"/2024/05/27/2024-05-27-%E9%96%B1%E8%AE%80level-up-your-code-with-game-programming-patterns/"},{"title":"ScriptableObject as Enum","text":"將 ScriptableObject 作為 Enum 可以有很多好處，像是可含有自己的屬性和方法等。另外還不具 Enum 的一些缺陷 Enum 的缺陷有 它會隱含(implicitly)的為所有元素賦予一個整數值，這造成刪改 Enum 中的值很不方便，若隨意刪除一個元素，那它之後元素的值都會變 下面例子，沒有明確指定值，因此會自動從0開始為每個元素賦值 123456enum Skill { SpeedUp, PowerUp, DefenseUp} 預設會自動幫你的賦值 12345678910111213enum Skill { SpeedUp = 0, PowerUp = 1, DefenseUp = 2}// 假設之後要刪除 `PowerUp` ，那麼在它之後元素的值都會變enum Skill { SpeedUp, DefenseUp // DefenseUp 的值會變為 1} 除非使用 Nullable 否則它不可以為 NULL ，因此一般常會自訂一個元素來代表空值 自訂一個元素來代表空值 1234567enum Skill { NONE = 0, SpeedUp = 1, PowerUp = 2, DefenseUp = 3} 在 C# ， enum 中不允許有方法或是屬性，需要使用擴展方法來完成 不可以有方法或屬性 1234567891011enum Skill { NONE = 0, SpeedUp = 1, PowerUp = 2, DefenseUp = 3 // 不可以 // private float bonusRatio; // 不可以 // public float GetBonusRatio(){ return bonusRatio; }} 需要使用擴展方法來完成 1234567891011121314151617public static class SkillExtensions{ public static double GetBonusRatio(this Skill skill) { switch (skill) { case Skill.SpeedUp: return 1.2; case Skill.PowerUp: return 1.5; case Skill.DefenseUp: return 1.3; default: return 1.0; } }} 因此將 ScriptableObject 作為 Enum 來使用也是一種好選擇，使用的方式為 12345[CreateAssetMenu(menuName = &quot;ScriptableObjects/SkillSO&quot;)]public class SkillSO : ScriptableObject{} 然後在透過 Unity 編輯器建立需要的元素即可 使用上也和 Enum 類似 返回 ScriptableObject 系列 Reference: https://leotgo.medium.com/unity-devs-enums-your-worst-enemy-heres-what-you-should-use-instead-f1418e1461d9 https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum?redirectedfrom=MSDN","link":"/2024/06/22/2024-06-22-scriptableobject-as-enum/"},{"title":"線性插值(Lerp)","text":"Mathf.Lerp 是 Unity 中的一個數學函數，用於在兩個值之間進行線性插值(Linear Interpolation)。這個函數可以幫助你製作平滑的效果，像是顏色轉換，動畫轉換等。 語法為 float Mathf.Lerp(float a, float b, float t) a ：起始值 b ：結束值 t ：代表 a 與 b 之間的插值比例，範圍在 0 到 1 之間。如果 t 為 0，則返回 a；如果 t 為 1，則返回 b；如果 t 為 0.5，則返回 a 和 b 之間的中間值(0.5)。 例如： Mathf.Lerp (3f, 5f, 0.5f) 會得到 4 。 我們來看一個例子，假設 a=0 ， b=20 ， t=0.5 。 每一秒執行一次，並將結果儲存回 a 開始： a=0 ， 第一秒： a = Mathf.Lerp (0f, 20f, 0.5f) = 10 第二秒： a = Mathf.Lerp (10f, 20f, 0.5f) = 15 第三秒： a = Mathf.Lerp (15f, 20f, 0.5f) = 17.5… 將結果畫為一個座標圖，其中 X 軸代表時間(每一秒)， Y 軸代表每一秒執行之後的 a a: b: t: time: 改變 document.addEventListener('DOMContentLoaded', function() { const lerp = (start, end, t) => { return start + (end - start) * t; }; let a = 0; let b = 20; let t = 0.5; const points =[]; for(let i = 0; i < 20; i++){ points.push({x: i, y:a}); a = lerp(a, b, t); } const ctx = document.getElementById('myChart').getContext('2d'); const chart = new Chart(ctx, { type: 'line', responsive: true, data: { datasets: [{ label: 'a 的值', data: points, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: 5 }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '時間(秒)' } }, y: { title: { display: true, text: 'a 的值' } } } } }); document.getElementById('change').addEventListener(\"click\", function(){ const aInput = document.getElementById('a'); const bInput = document.getElementById('b'); const tInput = document.getElementById('t'); const timeInput = document.getElementById('time'); let a = aInput.value.trim() === '' ? 0 : parseFloat(aInput.value); let b = bInput.value.trim() === '' ? 20 : parseFloat(bInput.value); let t = tInput.value.trim() === '' ? 0.5 : parseFloat(tInput.value); let time = timeInput.value.trim() === '' ? 20 : parseFloat(timeInput.value); const points =[]; for(let i = 0; i < time; i++){ points.push({x: i, y:a}); a = lerp(a, b, t); } chart.data.datasets = [{ label: 'a 的值', data: points, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: 5 }]; chart.update(); }); }); 可得出以下簡單的結論 隨著時間增加 a 會從開始快速增加，但是當越接近 b 時，成長的速度就會越慢。 下面是一個使用 Mathf.Lerp 調整光強度的例子。 假設光的強度從 0 開始 在第一次更新幀後： Mathf.Lerp(0f, 8f, 0.5f) 得到的值為 4 第二次更新幀後： Mathf.Lerp(4f, 8f, 0.5f) 得到的值為 6 第三次更新幀後： Mathf.Lerp(6f, 8f, 0.5f) 得到的值為 7 第四次更新幀後： Mathf.Lerp(7f, 8f, 0.5f) 得到的值為 7.5 …依此類推，最後將趨近於 8 ，但是隨著 a 的值接近 b ，其變化的速率將減慢。12345678void Start() { light.intensity = 0;}void Update (){ light.intensity = Mathf.Lerp(light.intensity, 8f, 0.5f);} 下面的程式碼將展示如何使用 Mathf.Lerp 來在兩個值之間做插值，讓一個遊戲物件來回移動。 1234567891011121314151617181920212223242526272829public class Example : MonoBehaviour{ // 定義遊戲物件在X軸上的移動範圍 public float minimum = -1.0F; // 最小值 -1.0 public float maximum = 1.0F; // 最大值 1.0 // Lerp 的初始值 static float t = 0.0f; void Update() { // 使用 Lerp 函數在 minimum 和 maximum 之間插值，這個遊戲物件一開始將從 minimum 移動到 maximim transform.position = new Vector3(Mathf.Lerp(minimum, maximum, t), 0, 0); // 增加 t 的值，0.5f * Time.deltaTime 來控制插值的速度 t += 0.5f * Time.deltaTime; // 當 t 超過 1.0 時，將 t 重置為 0 並交換 minimum 和 maximum // 這樣物件將開始從 maximum 移動回 minimum if (t &gt; 1.0f) { float temp = maximum; maximum = minimum; minimum = temp; t = 0.0f; } }} 使用 0.5f * Time.deltaTime 的原因是：確保增量操作（例如移動或旋轉）在不同的幀率下保持一致。這樣，無論遊戲以每秒 30 幀還是每秒 60 幀運行，物件的移動速度都會保持一致。舉個例子：假設你的遊戲每秒運行 60 幀，則 Update 每一秒會執行 60 次， 那麼每幀的 Time.deltaTime 約為 1/60 秒 ≈ 0.0167 秒 如果想要讓每秒 t 增長的量為 0.5f ， 以每一幀來看， t 增長的量要為 0.5f * 0.0167 ≈ 0.0083 ， 這樣在執行 60 次 Update 後約為一秒 =&gt; 0.5f * 0.0167 * 60 ≈ 0.5f 另外還有 Color.Lerp 和 Vector3.Lerp 這些方法的工作方式與 Mathf.Lerp 完全相同，差別在於輸入 a 和 b 的類型 Reference: https://learn.unity.com/tutorial/xian-xing-cha-zhi?language=zh&amp;projectId=5e3afd88edbc2a2998252c77#5e3afd8bedbc2a2998252cb0 https://docs.unity3d.com/ScriptReference/Mathf.Lerp.html","link":"/2024/06/25/2024-06-25-lerp/"},{"title":"ScriptableObject as delegate object","text":"ScriptableObject 除了作為資料的容器外，還可在其內部定義方法，讓 MonoBehaviour 可以將自己傳入 ScriptableObject 的方法中，根據不同的 ScriptableObject 實體去執行不同的動作。 例如：要做增益效果，定義一個抽象的 PowerupEffect 類，它繼承 ScriptableObject ，並且只有一個 ApplyTo 方法，這個方法將增益效果應用到傳入的 GameObject 中。 1234public abstract class PowerupEffect : ScriptableObject { public abstract void ApplyTo(GameObject object);} 建立一個子類 HpBooster ，並 override 了 ApplyTo ，將增加遊戲物件的生命值。 12345678public class HpBooster : PowerupEffect{ public int Amount; public override void ApplyTo(GameObject object) { object.GetComponent&lt;HP&gt;().currentValue += Amount; }} 在建立一個 增益物件 的腳本，這個增益物件將持有 PowerupEffect 的參考，當在觸發器中觸發時，就會呼叫它持有的 PowerupEffect 來將增益效果應用到碰到的遊戲物件。 123456789public class Powerup : MonoBehaviour { public PowerupEffect effect; public void OnTriggerEnter(Collider other) { effect.ApplyTo(other.gameObject); }} 例子，使用音效 1234567// 這個 struct 為最大最小值的結構[Serializable]public struct RangedFloat{ public float minValue; public float maxValue;} 定義一個抽象的 AudioDelegateSO 並繼承 ScriptableObject。在其中含有一個 Play 抽象方法，讓傳入的 AudioSource 播放音效。 1234public abstract class AudioDelegateSO: ScriptableObject{ public abstract void Play(AudioSource source);} 定義一個 SimpleAudioDelegateSO 類，它繼承 AudioDelegateSO ，這個 SimpleAudioDelegateSO 可以管理一個音效列表clips，在 Play 方法中，將隨機播放 clips 列表中的聲音。 123456789101112131415161718[CreateAssetMenu(fileName =&quot;AudioDelegate&quot;)]public class SimpleAudioDelegateSO : AudioDelegateSO{ public AudioClip[] clips; public RangedFloat volume; public RangedFloat pitch; public override void Play(AudioSource source) { if (clips.Length == 0 || source == null) { return; } source.clip = clips[Random.Range(0, clips.Length)]; source.volume = Random.Range(volume.minValue, volume.maxValue); source.pitch = Random.Range(pitch.minValue, pitch.maxValue); source.Play(); }} 我們可以使用這個 SimpleAudioDelegateSO 讓同一個遊戲物件隨機播放不同的聲音，例如可以儲存狗的叫聲，每當觸碰狗遊戲物件時，就隨機播放一種叫聲。 例子： 在遊戲中，會分為玩家控制，或是電腦控制的遊戲物件，如坦克遊戲中的坦克，可以由不同 AI 控制，也可以為玩家控制。這種不同的行為，我們也可以用 Delegate Object 來做。 定義一個抽象的 TankBrain 繼承 ScriptableObject。其中 含有 Initialize 虛方法，不一定會實作這個方法，但是當需要做初始化的動作時可以 override 它。 含有一個 Think 抽象方法，決定傳入的 TankThinker 要有什麼行為。1234public abstract class TankBrain : ScrptableObject{ public abstract void Think(TankThinker tank);} 定義一個 PlayerControlledTank 類，它繼承 TankBrain 它為玩家操控的坦克。 override Think 方法，在裡面取得坦克的位置，並判斷輸入來移動坦克或是發射砲彈。123456789101112131415161718192021222324252627282930[CreateAssetMenu(menuName=&quot;Brains/Player Controlled&quot;)]public class PlayerControlledTank : TankBrain{ public int PlayerNumber; private string m_MovementAxisName; private string m_TurnAxisName; private string m_FireButton; public void OnEnable() { m_MovementAxisName = &quot;Vertical&quot; + PlayerNumber; m_TurnAxisName = &quot;Horizontal&quot; + PlayerNumber; m_FireButton = &quot;Fire&quot; + PlayerNumber; } public override void Think(TankThinker tank) { // 取得坦克移動 component var movement = tank.GetComponent&lt;TankMovement&gt;(); // 透過 Steer 與 Input 輸入來移動坦克 movement.Steer(Input.GetAxis(m_MovementAxisName), Input.GetAxis(m_TurnAxisName)); // 取得坦克發射砲彈 component var shooting = tank.GetComponent&lt;TankShooting&gt;(); // 判斷 Input 輸入是否為開火按鈕 if (Input.GetButton(m_FireButton)) shooting.BeginChargingShot(); else shooting.FireChargedShot(); }} 定義一個 SimpleSniper 類，它也繼承 TankBrain ，它為電腦操控的坦克。 override Think 方法，在裡面判斷是否移動與開火 如取得坦克的位置，並根據它的記憶(Remeber)中判斷是否看過玩家坦克 如果記憶(Remeber)中沒有玩家坦克，則找最近的物件，並判斷是否為玩家坦克 如果還是沒找到，則移動自己 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172[CreateAssetMenu(menuName=&quot;Brains/Simple sniper&quot;)]public class SimpleSniper : TankBrain{ public float aimAngleThreshold = 2f; [MinMaxRange(0, 0.05f)] public RangedFloat chargeTimePerDistance; [MinMaxRange(0, 10)] public RangedFloat timeBetweenShots; public override void Think(TankThinker tank) { GameObject target = tank.Remember&lt;GameObject&gt;(&quot;target&quot;); var movement = tank.GetComponent&lt;TankMovement&gt;(); if (!target) { // 如果記憶(`Remeber`)中沒有玩家坦克，則找最近的物件，並判斷是否為玩家坦克 target = GameObject .FindGameObjectsWithTag(&quot;Player&quot;) .OrderBy(go =&gt; Vector3.Distance(go.transform.position, tank.transform.position)) .FirstOrDefault(go =&gt; go != tank.gameObject); // 記住找到的目標 tank.Remember&lt;GameObject&gt;(&quot;target&quot;, target); } if (!target) { // 如果還是沒找到，則移動自己 movement.Steer(0.5f, 1f); return; } // 瞄準目標 Vector3 desiredForward = (target.transform.position - tank.transform.position).normalized; if (Vector3.Angle(desiredForward, tank.transform.forward) &gt; aimAngleThreshold) { // 判斷轉動方向 bool clockwise = Vector3.Cross(desiredForward, tank.transform.forward).y &gt; 0; movement.Steer(0f, clockwise ? -1 : 1); } else { // 停止轉向 movement.Steer(0f, 0f); } // 獲取坦克的射擊 component var shooting = tank.GetComponent&lt;TankShooting&gt;(); // 檢查是否可以開始充能射擊 if (!shooting.IsCharging) { if (Time.time &gt; tank.Remember&lt;float&gt;(&quot;nextShotAllowedAfter&quot;)) { float distanceToTarget = Vector3.Distance(target.transform.position, tank.transform.position); float timeToCharge = distanceToTarget*Random.Range(chargeTimePerDistance.minValue, chargeTimePerDistance.maxValue); tank.Remember(&quot;fireAt&quot;, Time.time + timeToCharge); shooting.BeginChargingShot(); } } else { float fireAt = tank.Remember&lt;float&gt;(&quot;fireAt&quot;); if (Time.time &gt; fireAt) { shooting.FireChargedShot(); tank.Remember(&quot;nextShotAllowedAfter&quot;, Time.time + Random.Range(timeBetweenShots.minValue, timeBetweenShots.maxValue)); } } }} 返回 ScriptableObject 系列 Reference: https://unity.com/cn/how-to/scriptableobjects-delegate-objects https://unity.com/cn/resources/create-modular-game-architecture-with-scriptable-objects-ebook","link":"/2024/06/24/2024-06-24-scriptableobject-as-delegate-object/"},{"title":"時間(Time)與幀(Frame)","text":"Unity 中有一個 Time 類(class)，它提供了與時間相關的重要方法，讓你可以在專案中使用。 在 Unity 中，有兩個追蹤時間(track time)的系統，一個是每步之間的時間量是可變的，另一個是每步之間的時間量是固定的。 可變時間步長(variable time step)系統：在每次繪製畫面和運行你的APP或遊戲程式碼時執行一次。 固定時間步長(fixed time step)系統：以預定義的時間步長前進，並且與畫面的更新無關。這個系統通常與物理系統相關聯，物理系統會按照固定時間步長的速率運行，但你也可以在每個固定時間步長中執行自己的代碼。 可變動幀率(Variable Frame Rate)：在 Unity 中每一幀所執行的時間會因為程式碼複雜度或是顯示畫面的複雜度而有所不同，同時也會受到裝置設備的效能影響。 固定時間步長(Fixed Timestep)：在 Unity 中，它的物理系統使用固定時間步長(Fixed Timestep)，防止突然出現物體在一幀內移動非常大距離的狀況。 Unity 的時間邏輯流程圖：此文將說明 Unity 是如何處理時間的。 Time 類屬性在幀率變化中的範例：在此文中將說明 Time 類中的各屬性是如何處理突如其來的幀率大幅變動。 錄製遊戲影片：錄製遊戲影片是時間管理中的一個特例。保存螢幕圖片的操作需要耗費相當多的時間，這會導致遊戲的正常幀率降低，錄製出的影片無法反映遊戲的實際表現。為了解決這個問題，可以使用 Unity 提供的 captureFramerate 屬性，來調整錄製時的幀率。 一個簡單的技能冷卻計時器：將示範如何使用 Time.deltaTime 來製作技能冷卻時間。 Time 類有以下 static 屬性 captureDeltaTime 減慢你APP的播放時間(playback time)，以便 Unity 能夠在幀與幀之間保存截圖。 captureFramerate Time.captureDeltaTime 的倒數(reciprocal)，即 1/captureDeltaTime。 deltaTime 從上一個幀到目前幀之間的時間間隔，單位是秒 (只可讀) fixedDeltaTime 固定間隔幀時間 fixedTime 從遊戲開始到現在 FixedUpdate 進行的時間，以秒為單位 (只可讀) fixedTimeAsDouble 與 fixedTime 相同，但是是 double 型態 (只可讀) fixedUnscaledDeltaTime 每次 FixedUpdate 之間的固定時間間隔，以秒為單位，且不受timeScale影響(timeScale-independent)。(只可讀)。這表示調整timeScale時(如暫停遊戲)，它的值也不受影響 fixedUnscaledTime 表示從遊戲開始以來經過的時間，以固定的時間間隔計算，並且不受 timeScale 影響 (只可讀)。 fixedUnscaledTimeAsDouble 與 fixedUnscaledTime 相同，但是是 double 型態 (只可讀) frameCount 遊戲開始以來的總幀數 (只可讀) inFixedTimeStep 如果在 fixed time step callback 中將返回 true 例如MonoBehaviour 的 FixedUpdate，否則返回 false 。(只可讀) maximumDeltaTime 任何給定的幀中 Time.deltaTime 的最大值. 用來限制兩個幀之間的時間(Time.time)增加，以秒為單位。 maximumParticleDeltaTime 在一幀中可以花在更新粒子(particle)的最大時間。如果在一幀中超過這個時間，那麼就會把這個更新分割為多個較小的更新。 realtimeSinceStartup 它返回從APP啟動到當前時間所經過的時間(以秒為單位)。也就是說，它計算了從APP啟動以來的總實際時間，而不僅僅是應用程序在前台運行的時間 (只可讀) realtimeSinceStartupAsDouble realtimeSinceStartup 相同，但是是 double 型態 (只可讀) smoothDeltaTime 一個平滑的 Time.deltaTime (只可讀) time 從APP開始執行到目前這一幀的總時間長，以秒為單位 (只可讀) timeAsDouble 與 time 相同，但是是 double 型態 (只可讀) timeScale 時間流逝的縮放程度，可以用在實現慢動作效果，預設為 1.0 。 當為 1.0 時，表示遊戲時間和真實時間同步，如果設為 0.5 則遊戲時間以半速運行。當為 0 時，則時間停止，但是遊戲邏輯(像是 Update 方法仍然會被呼叫)與渲染事件仍然會被觸發。 timeSinceLevelLoad 自從最後一個非附加場景(non-additive scene)載入完成以來的時間 (以秒為單位) timeSinceLevelLoadAsDouble 與 timeSinceLevelLoad 相同，但是是 double 型態 (只可讀) unscaledDeltaTime 自上一幀以來經過的時間(以秒為單位)，並且不受 Time.timeScale 影響 (只可讀) unscaledTime 自遊戲開始以來經過的總時間(以秒為單位)，這個時間不受 Time.timeScale 的影響 unscaledTimeAsDouble 與 unscaledTimeAsDouble 相同，但是是 double 型態 (只可讀) Reference: https://docs.unity3d.com/ScriptReference/Time.html https://docs.unity3d.com/Manual/TimeFrameManagement.html","link":"/2024/06/26/2024-06-26-time-and-frame/"},{"title":"ScriptableObject 系列","text":"ScriptableObject 是一個資料容器(Data container)，用於儲存資料並作為資源（Asset）在執行時使用。除了基本的資料儲存功能外，它還有多種特殊用法。 ScriptableObject 基礎 將 ScriptableObject 當作變數，在物件之間分享 在事件系統中，將 ScriptableObject 當作事件(Event)物件 將 ScriptableObject 當作物件集合容器，在執行期間，讓這個集合容器在物件之間分享 將 ScriptableObject 當作 Enum 使用 將 ScriptableObject 當作 委託(delegate)物件，在物件需要時將物件傳入委託它完成對應的動作 將 ScriptableObject 作為 Dependency Injection 的工具","link":"/2024/06/28/2024-06-28-scriptableobject-%E7%B3%BB%E5%88%97/"},{"title":"Unity 的時間邏輯流程圖","text":".node.default { font-size: 0.75em; } flowchart TD A[\"`deltaTime`\"] --> B{\"`deltaTime 是否比 maximumDeltaTime 大？`\"} B -- 是 --> C[deltaTime 的值設為maximumDeltaTime] C --> D B -- 否 --> D[ deltaTime 被加到 time 中 ] D --> E{\"`fixedTime 是否落後 Time.time 一個固定時間步長？`\"} E -- 是 --> F[ fixedDeltaTime 加到 fixedTime中 ] F --> G[ 執行 FixedUpdate ] G --> E E -- 否 --> H[ 執行 Update ] import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.esm.min.mjs'; mermaid.initialize({ startOnLoad: true }); Time.time ：為遊戲開始後經過的時間，以秒為單位，一般會持續穩定的增加，只可讀。 受 timeScale 影響，如果 Time.timeScale 設為 0 ，那麼 Time.time 會停止計時，可以達到遊戲暫停的功能。 受 maximumDeltaTime 限制。 當在 FixedUpdate 中呼叫時，回傳的是 Time.fixedTime 的值。 通常用於關於整場遊戲計時的計算。 Time.deltaTime ：從上一個幀到目前幀之間的時間間隔，以秒為單位。 可以在遊戲中用來製作倒數裝置，例如施放技能的時間變化。 Time.timeScale ：時間流逝的縮放程度，可以用在實現慢動作效果，預設為 1.0 。 當為 1.0 時，表示遊戲時間和真實時間同步， 如果設為 0.5 則遊戲時間以半速運行。 設為 0.1 可以實現慢動作效果，這表示播放速度為正常速度的 10%。經過十秒之後 Time.time 的值會增加 1。 當為 0 時，則時間停止，但是遊戲邏輯(像是 Update 方法仍然會被呼叫)與渲染事件仍然會被觸發。但 Time.time 不會增加，Time.deltaTime 也為 0。 Time.maximumDeltaTime ：上面的屬性會被 Time.maximumDeltaTime 限制，這表示這些屬性任何幀率變化的長度永遠不會超過 Time.maximumDeltaTime，例如，如果發生一秒的延遲，且 maximumDeltaTime 為 0.333，那麼 Time.time 只會增加 0.333，而 Time.deltaTime 也會等於 0.333，儘管實際上已經過了更多時間。 unscale版本的屬性(如Time.unscaledTime和Time.unscaledDeltaTime)會忽略這些變化和限制，並回報實際經過的時間。對於需要在遊戲慢動作播放時仍以固定速度響應的任何事物都很有用。例如，用於 UI 交互動畫。 返回 時間與幀 大綱 Reference: https://docs.unity3d.com/uploads/Main/time-flowchart.png","link":"/2024/06/28/2024-06-28-unity-%E7%9A%84%E6%99%82%E9%96%93%E9%82%8F%E8%BC%AF%E6%B5%81%E7%A8%8B%E5%9C%96/"},{"title":"在 Linux 上安裝並使用 AWS CLI 將檔案上傳至 S3","text":"在 Linux 下，使用 以下指令下載 awscliv2.zip 1curl &quot;https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip&quot; -o &quot;awscliv2.zip&quot; 解壓縮並安裝 12unzip awscliv2.zipsudo ./aws/install 使用 aws configure --profile 設定profile的 Access Key ID 與 Secrect Access Key 等資訊。 aws configure --profile &lt;你想設定的profile名稱&gt;12345root@host ~# aws configure --profile my-devAWS Access Key ID [None]: ASIAIOSFODNN7EXAMPLEAWS Secret Access Key [None]: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEYDefault region name [None]: us-east-1Default output format [None]: json 設定完之後，便可以使用 AWS CLI 進行檔案上傳、下載或刪除等操作。假設 Bucket 的名稱是 dev 。 使用 aws s3 ls 可以將 Bucket 中的檔案列出來 aws s3 ls s3://&lt;你的Bucket名稱&gt; --profile &lt;你設定的profile&gt;12root@host ~# aws s3 ls s3://dev --profile my-dev2024-06-24 11:23:11 4 test.csv 使用 aws s3 cp 可以將檔案上傳到 Bucket 中或是從 Bucket 中下載檔案： 上傳檔案至S3：使用 aws s3 cp &lt;你要上傳檔案&gt; s3://&lt;你的Bucket名稱&gt;/&lt;要上傳的prefix與名稱&gt; --profile &lt;你設定的profile&gt; 12root@host ~# aws s3 cp /tmp/test.csv s3://dev/test.csv --profile my-devupload: /tmp/test.csv to s3://dev/test.csv 從S3下載檔案：使用 aws s3 cp s3://&lt;你的Bucket名稱&gt;/&lt;要下載的prefix與名稱&gt; &lt;你要下載的位置&gt; --profile &lt;你設定的profile&gt; 12root@host ~# aws s3 cp s3://dev/test.csv /tmp/downloadfroms3.csv --profile my-devdownload: s3://dev/test.csv to ../tmp/downloadfroms3.csv 使用 aws s3 rm 刪除在 S3 上面的檔案 aws s3 rm s3://&lt;你的Bucket名稱&gt;/&lt;要刪除的prefix與名稱&gt; --profile &lt;你設定的profile&gt;12root@host ~# aws s3 rm s3://dev/test.csv --profile my-devdelete: s3://dev/test.csv Reference: https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html https://docs.aws.amazon.com/cli/v1/userguide/cli-configure-files.html","link":"/2024/06/24/2024-06-24-%E5%AE%89%E8%A3%9D-aws-command-line/"},{"title":"可變動幀率(Variable Frame Rate)","text":"在 Unity 中， APP 的每一幀所執行的時間會因為程式碼複雜度或是顯示畫面的複雜度而有所不同，此外也會受到裝置設備的效能影響。 例如：當有一百個角色在螢幕上活動時，每一幀的執行速度會比只有一個角色來的慢，這種可變的速率通常被稱為 每秒幀數 FPS 。 一般來說 Unity 會嘗試以最快的幀率執行你的 APP。 Update 方法在 Unity 中，提供了 Update 方法作為每一幀執行我們程式碼的入口(entry point)，例如在 Update 中取得使用者的輸入讓遊戲角色向前移動。但是要記住遊戲的幀率是可變的，因此Update調用之間的時間間隔也會變化。 幀率變動對遊戲物件移動速度的影響下面的程式碼想做的事是把這個遊戲物件平移一段距離，但是幀率(frame rate)是會變動的，因此這個遊戲物件在移動時，它的速度也會變化。例如： 假設遊戲為每秒 100 幀的速度在執行，那麼 Update 這個方法會執行 100 次，因此這個物件每秒會移動 distancePerFrame 一百次 但是如果因為 CPU 負載變高導致速度下降到 每秒 60 幀的速度在執行的話，那麼這個物件會變為每秒移動 distancePerFrame 六十次 1234567public class ExampleScript : MonoBehaviour { public float distancePerFrame; void Update() { transform.Translate(0, 0, distancePerFrame); // 錯誤 }} 大部分的情況下，這是不好的，因為通常在遊戲中會希望物體是以穩定且可預測的速度移動而不受到幀率影響。 使用 Time.deltaTime 確保一致性Time.deltaTime 為從上一幀到目前幀之間的時間間隔，以秒為單位。這個屬性通常用於在 Update 方法中進行時間相關的計算例如，你想要從現開始，經過一秒後做某些動作，可以這樣操作： 1234567891011public class ExampleScript : MonoBehaviour { private float timer = 0f; void Update() { timer += Time.deltaTime; if (timer &gt;= 1f) { Debug.Log(&quot;一秒過去了，某些動作&quot;); timer = 0f; } }} 因此解決上面位移問題的方式是根據每一幀經過的時間來縮放每一幀的移動量，這樣無論幀率如何變化，物體每秒移動的總距離都會保持一致。程式碼如下： 12345678public class ExampleScript : MonoBehaviour { // 變數的名稱變為 per second ，這是因為此時不再是依靠幀而是秒了 public float distancePerSecond; void Update() { transform.Translate(0, 0, distancePerSecond * Time.deltaTime); }} 返回 時間與幀 大綱","link":"/2024/06/28/2024-06-28-%E5%8F%AF%E8%AE%8A%E5%8B%95%E5%B9%80%E7%8E%87(variable-frame-rate)/"},{"title":"錄製遊戲影片","text":"錄製遊戲影片是時間管理中的一個特例。保存螢幕圖片的操作需要耗費相當多的時間，這會導致遊戲的正常幀率降低，錄製出的影片無法反映遊戲的實際表現。為了解決這個問題，可以使用 captureFramerate 屬性。該屬性的預設值為 0，表示未錄製遊戲。如果要進行錄製，則需要將該屬性的值設為非零值，此時遊戲時間會變慢，幀更新會在精確的間隔內發生。幀之間的間隔等於 1/Time.captureFramerate，所以如果將值設置為5.0，則更新每五分之一秒發生一次。由於幀率需求有效降低，在 Update 方法中有時間保存螢幕截圖或執行其他操作。 12345678910111213141516public class ExampleScript : MonoBehaviour { string folder = &quot;ScreenshotFolder&quot;; int frameRate = 25; void Start () { Time.captureFramerate = frameRate; System.IO.Directory.CreateDirectory(folder); } void Update () { string name = string.Format(&quot;{0}/{1:D04} shot.png&quot;, folder, Time.frameCount ); // 抓取螢幕截圖，並存放到指定位置 Application.CaptureScreenshot(name); }} 返回 時間與幀 大綱","link":"/2024/06/28/2024-06-28-%E9%8C%84%E8%A3%BD%E9%81%8A%E6%88%B2%E5%BD%B1%E7%89%87/"},{"title":"UGUI Canvas","text":"Canvas 組件(Component)為 UGUI 中的根本，主要用來渲染自己的所有 UI 組件。UI 組件必須要為 Canvas 組件的子組件才可正常顯示。 Render ModeUI 渲染方式有以下三種 Screen Space - Overlay(預設)：螢幕空間，覆蓋模式， UI 始終顯示在場景(Scene)內容前方。 Pixel Perfect：是否開啟無鋸齒精確渲染，性能換效果，當勾選時會有較好的 UI 顯示，但是較耗費性能 SortOrder：排序層編號，用於控制多個 Canvas 時的渲染先後順序。該值越高顯示越前面 Target Display：目標裝置，在哪個裝置上顯示。 Additional Shader Channels：其他著色器通道，決定著色器可以讀取哪些資料。 Screen Space - Camera：螢幕空間，攝影機模式， 3D 物體可以顯示在 UI 之前。 Render Camera：用於渲染UI的攝影機，如果不設定，則會類似於覆蓋模式 一般不建議直接使用主攝影機去渲染 UI Plane Distance：UI 平面在攝影機前方的距離，類似整體 Z 軸的感覺。值越小該 Canvas UI 越靠近攝影機。 Sorting Layer：Canvas屬於的排序層，可在 Edit -&gt; Project Setting -&gt; Tags and Layers -&gt; Sorting Layers 進行新增與編輯，越下方的層顯示越前面 Order in Layer：Canvas在所屬排序層下的順序，該值越高顯示越前面 例如角色狀態，一般會選這種模式，因為玩家角色物件要顯示在 UI 前面。 World Space： 世界空間，3D模式。 Event Camera：用於處理 UI 事件(Click、Drag)的攝影機。如果不設定，不能正常註冊UI事件，有就是說如果沒設定則像是 Click 事件就無法正常使用。 一般使用主攝影機 把 UI 當作 3D 物件，可以圍著人物或其他物件旋轉，移動。 Reference: https://www.bilibili.com/video/BV14N411Z7Fz?p=3&amp;vd_source=f103d4eb21cc24456defbcf356882852","link":"/2024/07/05/2024-07-05-ugui-canvas/"},{"title":"固定時間步長(Fixed Timestep)","text":"在 Unity 中，它的物理系統使用固定時間步長(Fixed Timestep)，Unity 提供 FixedUpdate 作為我們程式碼的入口(entry point)，你可以在這邊執行與物理相關的程式碼，例如向 Rigidbody 施加力。 fixedDeltaTime 是 Unity 中控制固定時間步長循環間隔的屬性，以秒為單位。 例如，當 fixedDeltaTime為 0.01 時意味著每個固定時間步長持續 1/100 秒，因此每秒會執行 100 次固定更新。 當你的APP執行的幀率高於每秒固定時間步長(Fixed Timestep)時，這表示每個幀的持續時間會比單個固定時間步長的持續時間還要短。 例如，如果 fixedDeltaTime 設為 0.02，那麼通常每秒會有 50 次固定更新。 如果你的 APP 以每秒 60 幀的速度執行，這會超過每秒 50 次的固定更新，這表示大約每十幀中會有一幀不會觸發固定更新。 如果你的 APP 的幀率低於固定時間步長值，這意味著每個幀的持續時間比單個固定時間步長還要長。為了解決這個問題，Unity 每幀會執行一個或多個固定更新，以便物理模擬能夠趕上自上一幀以來流逝的時間。 例如，如果你的固定時間步長值為 0.01，每秒會執行 100 次固定更新。如果你的應用以每秒 25 幀的速度運行，每幀的持續時間（0.04 秒）是固定時間步長值（0.01 秒）的四倍， Unity 將每幀執行四次固定更新。在幀率較低時，Unity 通過增加固定更新次數來保持物理模擬的準確性。 fixedDeltaTime 設定的越低，表示越頻繁的執行物理更新，模擬的越精確，但是會加大 CPU 的負擔。 返回 時間與幀 大綱","link":"/2024/06/28/2024-06-28-%E5%9B%BA%E5%AE%9A%E6%99%82%E9%96%93%E6%AD%A5%E9%95%B7(fixed-timestep)/"},{"title":"簡單技能冷卻計時器","text":"以下將建立一個簡單的技能冷卻計時器 12345678910111213141516171819202122public class SkillTimer : MonoBehaviour{ private float timer = 0; private float skillCooldown = 3; void Update() { // 讓計時器隨時間增加 timer += Time.deltaTime; if (timer &gt; skillCooldown) { // 重置計時器 timer = 0; // 釋放技能... Debug.Log(&quot;施放技能&quot;); } }} timer 變數用於累計經過的時間。 skillCooldown 用於設定技能冷卻時間為 3 秒。 每次 Update 被呼叫時，timer 會不斷的加上 Time.deltaTime 當 timer 超過 skillCooldown 時，就會重置計時器，並施放技能 返回 時間與幀 大綱","link":"/2024/06/28/2024-06-28-%E7%B0%A1%E5%96%AE%E8%A8%88%E6%99%82%E5%99%A8/"},{"title":"Canvas Scaler","text":"Canvas Scaler 組件(Component)是控制 UI 縮放的組件。主要負責控制在不同解析度下 UI 元件大小縮放比例，讓 UI 可以自動適應不同的螢幕，但它不負責位置，位置由 (RectTransform)[/2024/07/05/2024-07-05-ugui-recttransform] 組件負責。 Canvas Size 為 Cavas 中 RectTransform 的寬高。 下圖中， 左側的 Screen 為目前裝置的螢幕大小，下圖為 1012 x 515 Cavas 中 RectTransform 的 寬高＊縮放係數 = 螢幕解析度， (width * X scale) x (height * Y scale)， (1012 * 1) x (515 * 1) Reference Resolution(參考解析度)：在 Scale With Screen Size 模式中，它會參與解析度自適應的計算 主要提供三種模式 Constant Pixel Size(恆定像素模式)：不論螢幕大小如何，UI始終保持相同像素大小。 一般在遊戲中不常用。 它不會讓 UI 元件自動適應解析度大小，除非使用程式碼去修改 Scale With Screen Size(縮放模式)：根據螢幕大小進行縮放 在遊戲中最常用 Constant Physical Size(恆定物理模式)：不論螢幕大小如何，UI元素始終保持相同物理大小 World (世界模式)：當 Canvas 的 Render Mode 選擇為 World Space 時，會將 Canvas Scaler 變為 World。 一般不常更改，主要像素密度，一般值越大越清晰。因此當文字模糊時，可以考慮加大這個值。 Constant Pixel Size(恆定像素模式)Scale FactorScale Factor 縮放 Canvas 中所有 UI 元素。 當 Scale Factor 為 1 且 Screen Size=1024x768 則 Canvas Size 會為 1024x768，圖片大小為原樣 當 Scale Factor 為 2 且 Screen Size=1024x768 則 Canvas Size 會為 512x384，在其中的圖片大小看起來會放大 2 倍。 Reference Pixel Per UnitReference Pixel Per Unit 設定多少像素對應 Unity 中的一個單位，預設一個單位為 100 像素。 在計算時，圖片設定中的 Pixels Per Unit 設定會與此參數一起計算。(圖片設定中的 Texture Type 要設為 Sprite(2D and UI))， 當 Pixels Per Unit=100，表示每單位由 100 像素組成，而圖片解析度是512x512，那麼圖片在世界座標中大小就會變成 512/100 = 5.12x5.12 UnitSprite 在世界座標的大小 = 原圖片大小(像素) / Pixels Per Unit UI的大小 = 原圖片大小(像素) / (Pixels Per Unit / Reference Pixels Per Unit) Scale With Screen SizeReference ResolutionReference Resolution：參考解析度，美術人員出圖的標準解析度。一邊選擇市面上最常見的解析度作為標準。 使用在電腦上的話，可以用 1920x1080 假設你要用於 Android 或是 iOS 的手機遊戲的話，可以用 1080x1440 Screen Match ModeScreen Match Mode：螢幕匹配模式，當目前螢幕解析度寬高不符合解析度時，用於解析度大小自適應的匹配模式。 Expand(擴大)Expand：水平或垂直擴大 Canvas Size，讓它高於Reference Resolution，不會裁剪 UI 元素，可能會有黑邊。計算公式： scaleFactor(縮放係數) = Mathf.Min(screenSize.x(螢幕寬) / m_ReferenceResolution.x(Reference Resolution寬), screenSize.y(螢幕高) / m_ReferenceResolution.y(Reference Resolution高)) Canvas Size = 螢幕寬高 / scaleFactor(縮放係數) 例子： Reference Resolution 為 1920x1080 ， 螢幕(screen)解析度為 800x600。scaleFactor = Mathf.Min(800/1920, 600/1080) = Mathf.Min(0.41667, 0.5555) = 0.41667Canvas Size = (800,600) / 0.41667 = (1920, 1440) 效果：最大程度的顯示所有 UI 元素，保留 UI 所有的細節，可能會有黑邊。 Shirk(收縮)Shirk：水平或垂直收縮 Canvas Size，讓它低於Reference Resolution，可能會被裁減。計算公式： scaleFactor(縮放係數) = Mathf.Max(screenSize.x(螢幕寬) / m_ReferenceResolution.x(Reference Resolution寬), screenSize.y(螢幕高) / m_ReferenceResolution.y(Reference Resolution高)) Canvas Size = 螢幕寬高 / scaleFactor(縮放係數) 例子： Reference Resolution 為 1920x1080 ， 螢幕(screen)解析度為 800x600。scaleFactor = Mathf.Max(800/1920, 600/1080) = Mathf.Max(0.41667, 0.5555) = 0.5555Canvas Size = (800,600) / 0.5555 = (1440, 1080) 效果：最大程度的放大 UI 元素，可能會被裁減。 Match Width Or HeightMatch Width Or Height：以寬和高進行混合縮放。 Match：用於計算寬高匹配值。 當值為 0 時，適合直立螢幕模式的遊戲。將 Canvas Size 寬度設為 Reference Resolution 的寬度，並保持比例不變，螢幕越高時可能會出現黑邊。 當值為 1 時，用在橫向螢幕模式的遊戲。將 Canvas Size 高度設為 Reference Resolution 的高度，並保持比例不變，螢幕越長時可能會出現黑邊。計算公式：1234float logWidth = Mathf.Log(screenSize.x / m_ReferenceResolution.x, kLogBase);float logHeight = Mathf.Log(screenSize.y / m_ReferenceResolution.y, kLogBase);float logWeightedAverage = Mathf.Lerp(logWidth, logHeight, m_MatchWidthOrHeight);scaleFactor = Mathf.Pow(kLogBase, logWeightedAverage); 使用建議 存在直立螢幕模式和橫向螢幕模式的遊戲選擇使用 Expand 或 Shirnk 不存在螢幕模式切換的遊戲（即定死為直立螢幕模式或是橫向螢幕模式）選擇使用 Match Width Or Height 直式螢幕稱為 Portrait ，橫式螢幕 Landscape Constant Physical Size(恆定物理模式)DPI (Dots Per Inch，每英吋點數)DPI：圖像每英吋長度內的像素點數 Physical UnitPhysical Unit：物理單位，使用的物理單位種類 Centimeters(cm 公分)：1 英吋 = 2.54 公分 Millimeters(mm 公釐)：1 英吋 = 25.4 公釐 Inches(英吋)： 1 英吋 = 1 英吋 Points (點)： 1 英吋 = 72 點 Picas (派卡)： 1 英吋 = 6 派卡 Fallback Screen DPI：備用 DPI ，當找不到裝置 DPI 時，使用此值Default Sprite DPI：預設圖片 DPI計算公式：根據 DPI 算出新的 Reference Pixels Per Unit新 Reference Pixels Per Unit = Reference Pixels Per Unit ＊ Physical Unit / Default Sprite DPI UI的大小 = 原圖片大小(像素) / (Pixels Per Unit / 新 Reference Pixels Per Unit) 根據裝置的 DPI 進行計算，在不同裝置上的顯示大小更加準確 World 模式當 Canvas 的 Render Mode 選擇為 World Space 時，會將 Canvas Scaler 變為 World ， 3D 世界模式。 Dynamic Pixels Per UnitUI 中動態建立的點陣圖(例如文字)，中的單位像素(類似密度)。一般值越大越清晰。因此當文字模糊時，可以考慮加大這個值。 Reference Pixels Per Unit單位參考像素，多少像素對應 Unity 中的一個單位，預設一個單位為 100 像素。 Reference: https://www.arkaistudio.com/blog/2016/03/28/unity-ugui-%e5%8e%9f%e7%90%86%e7%af%87%e4%ba%8c%ef%bc%9acanvas-scaler-%e7%b8%ae%e6%94%be%e6%a0%b8%e5%bf%83/ https://forum.unity.com/threads/what-reference-resolution-and-game-view-settings-should-i-use.1088650/","link":"/2024/07/05/2024-07-05-canvasscaler/"},{"title":"Graphic Raycaster","text":"Graphic Raycaster 是用來檢查UI輸入事件的圖形射線發射器。它主要負責透過射線檢查玩家和 UI 元素的交互，判斷是否點擊到了 UI 元素 屬性 說明 Ignore Reversed Graphics 是否忽略反轉圖形，預設為 true。(例如 當某個 UI 按鈕的 Rotation X 設為 180 ，這個按鈕就不能點擊) Blocking Objects 射線被哪些類型的碰撞器(Collider)阻擋，在 Screen Space - Overlay 模式下無效。 Two D：UI 元件會被 2D 碰撞器擋住； Three D：UI 元件會被 3D 碰撞器擋住； All： UI 元件會被所有碰撞器擋住。 Blocking Mask 射線被哪些層的碰撞器阻擋，在 Screen Space - Overlay 模式下無效","link":"/2024/07/05/2024-07-05-graphic-raycaster/"},{"title":"Time 類屬性在幀率變化中的範例","text":"以下將說明各種 Time 類中的屬性是如何回報與響應幀率的巨大變化；下面的表格展示了 Unity 執行了 16 幀的情況，其中第 8 幀出現一個大延遲。 Frame unscaledTime time unscaledDeltaTime deltaTime smoothDeltaTime 1 0.000 0.000 0.018 0.018 0.018 2 0.018 0.018 0.018 0.018 0.018 3 0.036 0.036 0.018 0.018 0.018 4 0.054 0.054 0.018 0.018 0.018 5 0.071 0.071 0.017 0.017 0.018 6 0.089 0.089 0.018 0.018 0.018 7 0.107 0.107 0.018 0.018 0.018 8 1.123 0.440 1.016 0.333 0.081 9 1.140 0.457 0.017 0.017 0.066 10 1.157 0.474 0.017 0.017 0.056 11 1.175 0.492 0.018 0.018 0.049 12 1.193 0.510 0.018 0.018 0.042 13 1.211 0.528 0.018 0.018 0.038 14 1.229 0.546 0.018 0.018 0.034 15 1.247 0.564 0.018 0.018 0.031 16 1.265 0.582 0.018 0.018 0.028 在第 1 到第 7 幀中， 從 time 和 unscaledTime 可以發現這些值穩定的增加，約為 60 幀， timeScale 設為 1 。 在第 8 幀中，出現了超過一秒的大延遲， 當幀延遲超過 maximumDeltaTime 的值時，Unity 會限制 deltaTime 回報的值以及增加到目前時間的量。這個限制的目的是避免如果時間步長超過這個數值可能會發生的不良副作用。 所謂的不良副作用：像這樣的延遲會導致 deltaTime 的值變得非常大。例如，如果延遲超過一秒，deltaTime 可能會超過 1.0 秒。如果一個物體的移動量是透過 deltaTime 縮放的，這樣大的 deltaTime 值會導致物體在一幀內移動非常大的距離，可能直接穿過遊戲中的牆壁或其他障礙物，導致遊戲中不希望看到的「穿牆」現象。 下圖表中可以看到在第 8 幀時， unscaledDeltaTime 超過一秒(1.016)，但是 deltaTime 回報的是 0.333 ，這是因為 deltaTime 被 maximumDeltaTime 限制。 document.addEventListener('DOMContentLoaded', function() { const ctx = document.getElementById('deltaTimeBarChart').getContext('2d'); const chart = new Chart(ctx, { type: 'bar', responsive: true, data: { datasets: [{ label: 'unscaledDeltaTime', data: [ {x: \"1\", y:0.018}, {x: \"2\", y:0.018}, {x: \"3\", y:0.018}, {x: \"4\", y:0.018}, {x: \"5\", y:0.017}, {x: \"6\", y:0.018}, {x: \"7\", y:0.018}, {x: \"8\", y:1.016}, {x: \"9\", y:0.017}, {x: \"10\", y:0.017}, {x: \"11\", y:0.018}, {x: \"12\", y:0.018}, {x: \"13\", y:0.018}, {x: \"14\", y:0.018}, {x: \"15\", y:0.018}, {x: \"16\", y:0.018}, ], }, { label: 'deltaTime', data: [ {x: \"1\", y:0.018}, {x: \"2\", y:0.018}, {x: \"3\", y:0.018}, {x: \"4\", y:0.018}, {x: \"5\", y:0.017}, {x: \"6\", y:0.018}, {x: \"7\", y:0.018}, {x: \"8\", y:0.333}, {x: \"9\", y:0.017}, {x: \"10\", y:0.017}, {x: \"11\", y:0.018}, {x: \"12\", y:0.018}, {x: \"13\", y:0.018}, {x: \"14\", y:0.018}, {x: \"15\", y:0.018}, {x: \"16\", y:0.018}, ], }] }, options: { scales: { x: { position: 'bottom', title: { display: true, text: '幀(Frame)' } }, y: { title: { display: true, text: '時間(秒)' } } } } }); }); 在第 8 幀時， unscaledTime 增加將近一秒(1.123)的時間，但是 time 只增加較小的時間(0.440)，這是因為 time 加上的是被限制的 deltaTime (即 maximumDeltaTime 的值)。簡單的說： unscaledTime 代表從遊戲開始到目前幀的真實經過時間，不受限制。 time 代表遊戲開始到目前幀的經過時間，但是受 maximumDeltaTime 限制。 document.addEventListener('DOMContentLoaded', function() { const ctx = document.getElementById('unscaledTime').getContext('2d'); const chart = new Chart(ctx, { type: 'line', responsive: true, data: { datasets: [{ label: 'unscaledTime', data: [ {x: \"1\", y:0.000}, {x: \"2\", y:0.018}, {x: \"3\", y:0.036}, {x: \"4\", y:0.054}, {x: \"5\", y:0.071}, {x: \"6\", y:0.089}, {x: \"7\", y:0.107}, {x: \"8\", y:1.123}, {x: \"9\", y:1.140}, {x: \"10\", y:1.157}, {x: \"11\", y:1.175}, {x: \"12\", y:1.193}, {x: \"13\", y:1.211}, {x: \"14\", y:1.229}, {x: \"15\", y:1.247}, {x: \"16\", y:1.265}, ], }, { label: 'time', data: [ {x: \"1\", y:0.000}, {x: \"2\", y:0.018}, {x: \"3\", y:0.036}, {x: \"4\", y:0.054}, {x: \"5\", y:0.071}, {x: \"6\", y:0.089}, {x: \"7\", y:0.107}, {x: \"8\", y:0.440}, {x: \"9\", y:0.457}, {x: \"10\", y:0.474}, {x: \"11\", y:0.492}, {x: \"12\", y:0.510}, {x: \"13\", y:0.528}, {x: \"14\", y:0.546}, {x: \"15\", y:0.564}, {x: \"16\", y:0.582}, ], }] }, options: { scales: { x: { position: 'bottom', title: { display: true, text: '幀(Frame)' } }, y: { title: { display: true, text: '時間(秒)' } } } } }); }); Time.smoothDeltaTime 提供了最近一段時間內 deltaTime 的平滑近似值，這種平滑處理可以避免在計算中突然出現的波動，這種平滑的演算法無法預測未來的變化，但是可以讓回報的時間較平滑，因此可以比較符合實際預期的時間。 document.addEventListener('DOMContentLoaded', function() { const ctx = document.getElementById('timeChart').getContext('2d'); const chart = new Chart(ctx, { type: 'line', responsive: true, data: { datasets: [{ label: 'smoothDeltaTime', data: [ {x: \"1\", y:0.018}, {x: \"2\", y:0.018}, {x: \"3\", y:0.018}, {x: \"4\", y:0.018}, {x: \"5\", y:0.018}, {x: \"6\", y:0.018}, {x: \"7\", y:0.018}, {x: \"8\", y:0.081}, {x: \"9\", y:0.066}, {x: \"10\", y:0.056}, {x: \"11\", y:0.049}, {x: \"12\", y:0.042}, {x: \"13\", y:0.038}, {x: \"14\", y:0.034}, {x: \"15\", y:0.031}, {x: \"16\", y:0.028}, ], }, { label: 'deltaTime', data: [ {x: \"1\", y:0.018}, {x: \"2\", y:0.018}, {x: \"3\", y:0.018}, {x: \"4\", y:0.018}, {x: \"5\", y:0.017}, {x: \"6\", y:0.018}, {x: \"7\", y:0.018}, {x: \"8\", y:0.333}, {x: \"9\", y:0.017}, {x: \"10\", y:0.017}, {x: \"11\", y:0.018}, {x: \"12\", y:0.018}, {x: \"13\", y:0.018}, {x: \"14\", y:0.018}, {x: \"15\", y:0.018}, {x: \"16\", y:0.018}, ], }] }, options: { scales: { x: { position: 'bottom', title: { display: true, text: '幀(Frame)' } }, y: { title: { display: true, text: '時間(秒)' } } } } }); }); maximumDeltaTime 也會影響物理系統，物理系統使用 fixedTimestep 值來決定每個固定步長中模擬的時間量。Unity 嘗試保持物理模擬與實際經過的時間同步，有時會在一幀內執行多次物理更新。然而，如果由於某些重計算或延遲導致物理模擬落後太多，系統可能需要多次步驟來追趕當前時間。這種大量的步驟可能進一步導致性能下降。 為了避免由於試圖追趕而導致的逐步減慢，maximumDeltaTime 值還作為物理系統在任何給定兩幀之間模擬時間的上限。 如果一次幀更新的處理時間超過了 maximumDeltaTime，物理引擎將不會試圖模擬超過 maximumDeltaTime 的時間，而是讓幀處理趕上。一旦幀更新完成，物理模擬將恢復，就像它停止後沒有時間流逝一樣。這樣做的結果是，物理物體將不會像通常那樣以完全實時移動，而是會略微減速。然而，物理的「時鐘」仍然會跟踪它們，就好像它們在正常移動一樣。物理時間的減速通常不容易察覺，並且通常是在遊戲性能與實時物理模擬之間的可接受折衷。 返回 時間與幀 大綱","link":"/2024/06/28/2024-06-28-time-%E9%A1%9E%E5%B1%AC%E6%80%A7%E5%9C%A8%E5%B9%80%E7%8E%87%E8%AE%8A%E5%8C%96%E4%B8%AD%E7%9A%84%E7%AF%84%E4%BE%8B/"},{"title":"中文姓名產生器 (Chinese Name Generator)","text":"","link":"/2024/07/08/2024-07-08-chinese_name_generator/"},{"title":"粒子系統的 Main Module","text":"當建立一個新的粒子系統 GameObject，或是將粒子系統組件添加到現有的 GameObject 中時， Unity 就會將 Main Module 嵌入粒子系統中。 屬性 說明 Duration 粒子系統執行的時間長度(秒) Looping 若啟用，粒子系統將會重複播放粒子 Prewarm 若啟用，粒子系統在播放前會先預加載。(只有在 Looping 屬性啟用時，才會生效) Start Delay 粒子系統將延遲一段時間(秒)才播放 Start Lifetime 粒子系統的初始生命週期(秒)。也就是粒子在被建立出來到銷毀的這段時間 Start Speed 每個粒子的初始速度 3D Start Size 若啟用，則可分別控制每個軸的大小 Start Size 每個粒子初始的大小 3D Start Rotation 若啟用，則可分別控制每個軸的旋轉角度 Start Rotation 每個粒子的初始旋轉角度 Flip Rotation 讓一些粒子以相反的方向旋轉，值在 0 ~ 1，值越大，翻轉的越多。如值為 0.1 則會有 10%的粒子反轉。相反的方向是指與 Start Rotation 相反，當 Start Rotation 為 90 時，翻轉的粒子為 -90 Start Color 每個粒子的初始顏色 Gravity Modifier 縮放物理系統的重力值，值為零時會關閉重力 Simulation Space 目前粒子系統的參照座標。 Local space：控制粒子在父物件區域空間(local space)進行動畫，因此會隨著父物件移動。 World space ：控制粒子在世界空間(world space)進行動畫。 Custom space ：選擇一個物件，粒子將參照這個物件的位置 Simulation Speed 調整粒子的更新速度。當值為 0.5 則以半速播放， 1 則為原速播放 Delta Time Scale ：會受 Time Scale 影響 Unscaled ：不受 Time Scale 影響。例如：在暫停選單中，還可播放粒子。 Scaling Mode 選擇如何使用 transform 的縮放比例(scale)。 Hierarchy ：粒子將跟隨父物件進行縮放。 Local ：忽略任何父物件的transform，僅應用粒子系統 transform 的縮放比例。 Shape ：將縮放應用於粒子的起始位置(start positions)，但不影響它們的大小。 Play on Awake 如果啟用，在物件建立時，粒子系統就會自動啟動 Emitter Velocity 選擇粒子系統如何計算 Inherit Velocity 和 Emission 模組所使用的速度。 Rigidbody ：若 Rigidbody 存在，則粒子系統可以透過 Rigidbody 計算速度。 Transform ：透過追蹤 Transform 的移動來計算速度。 如果 Rigidbody 不存在的話，預設會使用 Transform Custom ：使用自訂的速度。 Max Particles 粒子的最大值，如果達到這個限制則會移除一些粒子 Auto Random Seed 如果設為 true ，則粒子系統每次播放時看起來都會不同。若設為 false ，則系統每次播放時都會相同 Random Seed 若 Auto Random Seed 設為 false ，該值用於建立一個唯一的可重複效果 Stop Action 當系統中的所有粒子都結束時，可以讓系統執行某個動作。當所有粒子都消失且系統的運行時間超過其持續時間時，系統會被認為已停止。若循環播放(Looping)的系統，只有通過腳本停止系統時才會執行這個動作。 動作可以設為： Disable ：GameObject已停用。 Destory ： GameObject已Destory 。 Callback ：OnParticleSystemStopped Callback 會發送到附加在該 GameObject 上的所有腳本。 Culling Mode 選擇是否在粒子離開螢幕時暫停粒子系統的模擬。 Automatic ：如果 Looping 啟用，則會使用 Pause ；其他的則會使用 Always Simulate Pause And Catch-up ：系統在離開螢幕時會停止模擬。當再次進入時，系統會執行一個大的步驟以達到在沒有暫停時應處於的位置。在複雜的系統中，這個選項可能會導致很高的效能損耗。 Pause ：當螢幕關閉時，系統會停止模擬。 Always Simulate ： 總是模擬，即使螢幕關閉也會模擬 Ring Buffer Mode 保存粒子存活，直到達到最大粒子數量。當新的粒子生成時，會回收最老的粒子，而不是在它們的生命結束時移除。 Disabled ：停用 Buffer ，當粒子的生命週期結束時，系統會直接刪除粒子。 Pause Until Replaced ：當粒子的生命週期結束時，會暫停這些舊的粒子，直到達到 Max Particle 的限制，一旦達到限制，系統會將這些暫停的粒子回收，讓它們重新出現為新的粒子。 Loop Until Replaced ：在粒子結束生命週期時，它們會倒回到其生命週期的指定比例，直到達到最大粒子數量限制。一旦達到限制，系統會將這些粒子回收，使它們重新出現為新的粒子。 Start開始的屬性，如 lifetime ， speed ， size ， rotation 與 color 等指定了粒子發射時的初始狀態。所有粒子系統會使用物理設定中的重力，在 Gravity Modifier 的值可以用來調節重力的縮放，如果設為零則可關閉重力，讓粒子不被重力影響。3D Start Size 屬性讓你可以個別指定粒子的寬(x)，高(y)與深度(z)，深度只會做用在 3D 網格(Mesh)中。此外還可為這些屬性設定隨機值，其值範圍可介於兩個常數或曲線之間。 Reference: https://docs.unity3d.com/Manual/PartSysMainModule.html","link":"/2024/07/17/2024-07-17-main-module/"},{"title":"RectTransform","text":"RectTransform 組件(Component)是 2D 佈局(layout)中使用的組件，用於控制 UI 組件位置以及對齊方式，繼承自 Transform 組件。 Transform 表示一個點，只處理位置(Position)，角度(Rotation)與縮放(Scale) RectTransform 表示一個 2D 矩形，UI 元素可以放置在這個矩形內，並加入了錨點(Anchors)，軸心點(Pivot)，長寬等屬性。 目的是控制 UI 元件大小，讓其可以自動適應解析度。 屬性 說明 Anchor 錨點，為相對於父矩形的錨點，值為 0 ~ 1。 Min：父矩形範圍內 X 和 Y 的最小值 Max：父矩形範圍內 X 和 Y 的最大值 Pivot 矩形範圍內的軸心點，值為 0 ~ 1。影響物件的旋轉，縮放，位置。在錨點計算位置中會用到 Pos (X, Y, Z) 軸心點相對於錨點的位置 Width, Height 矩形的寬高 Left/Top/Right/Bottom 矩形邊緣相的對於錨點的位置。當錨點分離時才會出現。 Ratation 圍繞軸心點的旋轉角度 Scale 縮放大小 BluePrint Mode 啟用後，編輯旋轉和縮放不會影響矩形，只會影響顯示內容 Raw Edit Mode 啟用後，改變軸心點和錨點值不會改變矩形位置，但會影響顯示內容 軸心點(Pivot)軸心點為矩形範圍內的軸心點，它會影響物件的旋轉，縮放，位置。此外在錨點計算位置中會也用到 在編輯器中，藍色空心圓就是軸心(Pivot) 軸心的值為 0 ~ 1 之間 預設值為 (0.5, 0.5)，在矩形的中心。 當值為 (0, 0) 時，會在矩形位置的左下角。 當值為 (1, 1) 時，會在矩形的右上角。 物件會根據軸心坐旋轉 錨點(Anchor)錨點，為相對於父矩形的錨點。由 Min 和 Max 組成，這四個點在 Unity 編輯器中顯示為四個三角形，並組成一個矩形。 Min：父矩形範圍內 X 和 Y 的最小值。 Max：父矩形範圍內 X 和 Y 的最大值。 錨點為一個點：當 Min 與 Max 相同時，錨點為一個點。 預設 Min 與 Max 皆為 (0.5, 0.5)。此時，為父元素的中心。 Min 與 Max 皆為 (0, 0)。此時，為父元素的左下角。 Min 與 Max 皆為 (1.0, 1.0)。此時，為父元素的右上角。 錨點為一個點的時候，編輯器左邊顯示的為 Pos X 與 Pox Y，在此情況下，將錨點看作原點座標，而錨點距離軸心的 X 距離為 Pos X ；錨點距離軸心的 Y 距離為 Pos Y 這麼做的原因是為了適應不同解析度。例如，將錨點設定到右上角 Min(0,1) Max(0,1)，那麼不論解析度如何改變，這個元件都可以根據錨點保持正確的距離。 錨點為一個點的時候，編輯器左邊顯示的還有 Width 與 Height ，這個寬高為元件的寬高，會依據軸心點而有所不同 錨點為矩形：當 Min 與 Max 不同時，錨點會分離為一個矩形 Min 設為 (0.2, 0.1) ， Max 設為 (0.8, 0.7) 錨點為矩形時，編輯器左邊顯示會變為 Left ， Top ， Right ， Bottom。表示為錨點矩形與元件的矩形所形成的距離， Left 為左邊距離， Top 為上邊距離， Right 為右邊距離， Bottom 為下邊距離，如下圖。 當錨點為矩形時，可以讓元件會根據父元件的變化而拉伸大小。常常用在背景圖。 BluePrint Mode當勾選了 BluePrint Mode 之後，編輯旋轉和縮放不會影響矩形，只會影響顯示內容 一般不常使用。 Raw Edit Mode啟用 Raw Edit Mode 後，當改變軸心點和錨點值不會改變矩形位置，但會影響顯示內容 開始圖 未啟用 Raw Edit Mode 去更改軸心，會發現軸心往上移動，但是圖形沒有變 啟用 Raw Edit Mode 去更改軸心，會發現軸心沒有變，但是圖形往下移動 一般不常使用。 使用 Unity 編輯器快速設定軸心與錨點在編輯器中，會看到如下圖的按鈕，使用滑鼠左鍵點擊，它便會展開 展開後如下圖使用滑鼠左鍵點擊，就可以快速的設定錨點位置(九宮格佈局)。 按下 Shift ， 再點擊滑鼠左鍵，除了錨點位置，同時可以設定軸心點（相對自身矩形）按下 Alt ， 再點擊滑鼠左鍵，除了錨點位置，同時可以設置物件位置 在程式碼中，取得 RectTransform因為 RectTransform 繼承自 Transform，因此當該遊戲物件擁有 RectTransform 時，只要將它的 Transform 轉型為 RectTransform 即可。 1RectTransform rectTransform = (this.transform as RectTransform); Reference: https://docs.unity3d.com/Packages/com.unity.ugui@2.0/manual/class-RectTransform.html https://www.arkaistudio.com/blog/2016/05/02/unity-ugui-%e5%8e%9f%e7%90%86%e7%af%87%e4%b8%89%ef%bc%9arecttransform/","link":"/2024/07/08/2024-07-05-ugui-recttransform/"},{"title":"Scroll View","text":"當建立 Scroll View 時，預設會建立多個組件(Component)。 Viewport ：決定可視範圍 Content ：在這個滾動視圖中的內容物件都將放置於這個 Content 中。它的尺寸多大，滾動視角就能滾多遠。 Scrollbar Horizontal ：水平滾動條，可視需要刪除 Scrollbar Vertical ：垂直滾動條，可視需要刪除 ScrollRectScrollRect 是 滾動視圖中的一個組件。 屬性 說明 Content 控制滾動視圖內容的父物件，它的尺寸多大，滾動視圖就能滾多遠。 Horizontal 是否啟用水平滾動 Vertical 是否啟用垂直滾動 Movement Type 滾動視圖元素的運動類型，主要控制拖動時的回應效果。 Unrestricted ： 不受限制，隨便拖動。(一般不會使用) Elastic ：回效果，當滾出邊緣之後，會彈回邊界。(常用)。 — Elasticity ：回彈係數，控制回彈效果，值越大，回彈越慢。 Clamped ：夾緊效果，始終限制在範圍內，沒有回彈效果。 Inertia 移動慣性，如果開啟，鬆開滑鼠後，會有一個移動慣性。 Deceleration Rate ：減速率(0~1)，0沒有慣性，1不會停止。 Scroll Sensitivity 滾輪(滑鼠中鍵)和觸控板(筆記型電腦)的滾動事件敏感性 Viewport 關聯滾動式圖內容的物件 Horizontal Scrollbar 關聯的水平滾動條物件。 Visibility ：是否在不需要時自動隱藏滾動條。 — Permanent ：一直顯示滾動條。 — Auto Hide ：自動隱藏滾動條。 — Auto Hide And Expend Viewport ：自動隱藏滾動條並且自動擴展內容視角(Viewport)。 —— Spacing ：滾動條和視角(Viewport)之間的間隔空間 Vertical Scrollbar 關聯的垂直滾動條物件 此外如果想對 Container 中的物件做排列的話，可以使用 Layout Group 組件 Grid Layout Group ：網格(Grid)方式排列子物件 Horizontal Layout Group ：水平方向(Width) 排列子物件 Vertical Layout Group ：垂直方向(Height) 排列子物件 若想讓 Container 的大小自動符合內容物件的大小的話，可以使用 Container Size Filter 組件","link":"/2024/07/15/2024-07-15-scroll-view/"},{"title":"粒子系統(Particle System)","text":"粒子系統（Particle System）是一種用於模擬和渲染大量微小物件的技術，這些微小物件通常用於建立一些視覺效果，如火焰、煙霧、爆炸、流星、雨、雪等。 在 Unity 建立一個粒子系統的方式和建立其他組件的方式一樣，在編輯器中 Effects -&gt; Particle System 粒子系統有多個模組和屬性可以使用，我們可以根據需要啟用某些模組。預設會啟用 Emission，Shape 與 Renderer 。 模組 說明 Main 包含會影響整個粒子系統的全局屬性(global properties)。 Emission 控制粒子的發射速度，時間，波次 Shape 第一發射粒子的體積和形狀 Velocity over Lifetime 控制粒子在生命週期中的速度 Limit Velocity over Lifetime 在生命週期內限制粒子的速度 Inherit Velocity 控制粒子的速度如何隨時間推移而受到其父物件移動的影響 Lifetime by Emitter Speed 用來控制粒子系統中每個粒子的生命週期如何受到發射器速度的影響。 Force over Lifetime 通過此模組中指定的力來對粒子產生影響 Color over Lifetime 指定粒子的顏色和透明度在其生命週期中如何變化 Color by Speed 設定粒子的顏色根據粒子速度(每秒的距離單位)變化 Size over Lifetime 控制粒子在其生命週期內的大小 Size by Speed 設定粒子的大小，根據粒子速度(每秒的距離單位)變化 Rotation over Lifetime 控制粒子在其生命週期內的旋轉 Rotation by Speed 設定粒子的旋轉，根據根據粒子速度(每秒的距離單位)變化 External Forces 修改力對粒子的影響 Noise 未粒子添加噪音值 Collision 控制粒子如何與場景中其他遊戲物件發生碰撞 Triggers 控制粒子的觸發事件 Sub Emitters 在某粒子生命週期的階段建立附加粒子發射器 Texture Sheet Animation 控制動畫幀進行播放 Lights 控制粒子的光照 Trails 控制粒子的軌跡(拖尾) Custom Data 在編輯器中定義要附加到粒子的自訂資料格式 Renderer 設定粒子的圖案或網格如何被其他粒子變換，著色和繪製 Reference: https://docs.unity3d.com/Manual/ParticleSystemModules.html","link":"/2024/07/17/2024-07-17-particle-system/"},{"title":"粒子系統的 Shape","text":"Shape Module 定義了粒子的體積(volume)或表面(surface)以及開始速度(velocity)的方向。所有的形狀（除了網格(Mesh)）都有定義關於它們尺寸的屬性，例如半徑(Radius)屬性，可以在 Sence 編輯器中編輯這些屬性，選擇的形狀會影響粒子發射的區域與發射粒子的初始方向。例如， 球形(Sphere)：會向所有方向發射粒子， 錐形(Cone)：使粒子從發射點向外擴散開來，形成一個擴散的粒子流。 網格(Mesh)：粒子會沿著網格表面上每個點的法線方向發射出去。 Sphere 與 Hemisphere 屬性 說明 Shape Sphere：向所有方向發射粒子 Hemisphere ：在平面的一側均勻地向各個方向發射粒子。 Radius Sphere 或 Hemisphere 形狀的半徑(radius) Radius Thickness 發射粒子的體積比例。值為 0 時，粒子從形狀的外表面發射。值為 1 時，粒子從整個體積發射。介於這兩者之間的值將使用部分體積進行發射。 Arc 設定球體的弧度，若 Sphere 設為 360 的話，為一個球體，設為180則為半球體。 Mode ： 定義 Unity 如何在形狀的弧線周圍生成粒子 — Random ：隨機產生粒子。 — Loop ：循環產生粒子，並在每個週期結束時回到起點。 — Ping-Pong ：與 Loop 模式相同，只是每個連續的循環會以與上次相反的方向進行。 — Burst Spread ：爆炸擴散模式會均勻地在形狀周圍分配粒子生成。與預設的隨機化行為相比，這種模式可以均勻地分佈粒子，避免粒子聚集在一起不均勻的情況。爆炸擴散模式最適合與爆炸發射一起使用。 Spread ：弧線周圍可能產生粒子的離散間隔。例如，值為 0 時允許粒子在弧線周圍的任意位置生成，而值為 0.1 時則只允許粒子在形狀周圍的 10% 間隔處生成。 Texture 為粒子著色的紋理。 Position 對發射器形狀(emitter shape)應用一個偏移量。 Rotation 旋轉發射器形狀(emitter shape)。 Scale 改變發射器形狀(emitter shape)的大小。 Align to Direction 根據粒子初始移動方向來定向粒子。如果你想模擬例如在碰撞過程中從車身飛脫的漆塊，這會很有用。如果方向不滿意，你也可以在主模組中通過設置Start Rotation的值來覆蓋它。 Randomize Direction 將粒子的方向混合到隨機方向。當設置為 0 時，這個設置沒有影響。當設置為 1 時，粒子的方向完全隨機。 Spherize Direction 將粒子的方向混合到球形方向，即它們將從 Transform 的中心向外移動。當設置為 0 時，這個設置沒有影響。當設置為 1 時，粒子的方向指向中心外側（其行為與形狀設置為 Sphere 時相同）。 Randomize Position 將粒子隨機移動直到指定的值。當設置為 0 時，這個設置沒有影響。任何其他值都會在粒子的生成位置上添加一些隨機性。 Cone 屬性 說明 Shape Cone： 從錐體(Cone)的底部或主體發射粒子。粒子隨著它們距離錐體中心線由遠而近的發散。 Angle 錐體在其頂點的角度。角度為 0 時產生一個圓柱體，而角度為 90 時產生一個扁平的圓盤。 Radius Cone 形狀的半徑(radius) Radius Thickness 發射粒子的體積比例。值為 0 時，粒子從形狀的外表面發射。值為 1 時，粒子從整個體積發射。介於這兩者之間的值將使用部分體積進行發射。 Arc 發射器形狀所形成的圓形的角度部分。 Mode ： 定義 Unity 如何在形狀的弧線周圍生成粒子 — Random ：隨機產生粒子。 — Loop ：循環產生粒子，並在每個週期結束時回到起點。 — Ping-Pong ：與 Loop 模式相同，只是每個連續的循環會以與上次相反的方向進行。 — Burst Spread ：爆炸擴散模式會均勻地在形狀周圍分配粒子生成。與預設的隨機化行為相比，這種模式可以均勻地分佈粒子，避免粒子聚集在一起不均勻的情況。爆炸擴散模式最適合與爆炸發射一起使用。 Spread ：弧線周圍可能產生粒子的離散間隔。例如，值為 0 時允許粒子在弧線周圍的任意位置生成，而值為 0.1 時則只允許粒子在形狀周圍的 10% 間隔處生成。 Length 設定錐體的長度。只在 Emit from 屬性設置為 Volume 時才可使用。 Emit from 從錐體的哪部分發射粒子，底部(Base)或體積(Volume)。 Texture 為粒子著色的紋理。 Position 對發射器形狀(emitter shape)應用一個偏移量。 Rotation 旋轉發射器形狀(emitter shape)。 Scale 改變發射器形狀(emitter shape)的大小。 Align to Direction 根據粒子初始移動方向來定向粒子。如果你想模擬例如在碰撞過程中從車身飛脫的漆塊，這會很有用。如果方向不滿意，你也可以在主模組中通過設置Start Rotation的值來覆蓋它。 Randomize Direction 將粒子的方向混合到隨機方向。當設置為 0 時，這個設置沒有影響。當設置為 1 時，粒子的方向完全隨機。 Spherize Direction 將粒子的方向混合到球形方向，即它們將從 Transform 的中心向外移動。當設置為 0 時，這個設置沒有影響。當設置為 1 時，粒子的方向指向中心外側（其行為與形狀設置為 Sphere 時相同）。 Randomize Position 將粒子隨機移動直到指定的值。當設置為 0 時，這個設置沒有影響。任何其他值都會在粒子的生成位置上添加一些隨機性。 Donut 屬性 說明 Shape Donut： 從圓環（torus）發射粒子。粒子從圓環的環狀部分向外移動。 Radius Donut 形狀的主要半徑(radius) Donus Radius Donut 形狀外部厚度的半徑 Radius Thickness 發射粒子的體積比例。值為 0 時，粒子從形狀的外表面發射。值為 1 時，粒子從整個體積發射。介於這兩者之間的值將使用部分體積進行發射。 Arc 發射器形狀所形成的圓形的角度部分。 Mode ： 定義 Unity 如何在形狀的弧線周圍生成粒子 — Random ：隨機產生粒子。 — Loop ：循環產生粒子，並在每個週期結束時回到起點。 — Ping-Pong ：與 Loop 模式相同，只是每個連續的循環會以與上次相反的方向進行。 — Burst Spread ：爆炸擴散模式會均勻地在形狀周圍分配粒子生成。與預設的隨機化行為相比，這種模式可以均勻地分佈粒子，避免粒子聚集在一起不均勻的情況。爆炸擴散模式最適合與爆炸發射一起使用。 Spread ：弧線周圍可能產生粒子的離散間隔。例如，值為 0 時允許粒子在弧線周圍的任意位置生成，而值為 0.1 時則只允許粒子在形狀周圍的 10% 間隔處生成。 Length 設定錐體的長度。只在 Emit from 屬性設置為 Volume 時才可使用。 Emit from 從錐體的哪部分發射粒子，底部(Base)或體積(Volume)。 Texture 為粒子著色的紋理。 Position 對發射器形狀(emitter shape)應用一個偏移量。 Rotation 旋轉發射器形狀(emitter shape)。 Scale 改變發射器形狀(emitter shape)的大小。 Align to Direction 根據粒子初始移動方向來定向粒子。如果你想模擬例如在碰撞過程中從車身飛脫的漆塊，這會很有用。如果方向不滿意，你也可以在主模組中通過設置Start Rotation的值來覆蓋它。 Randomize Direction 將粒子的方向混合到隨機方向。當設置為 0 時，這個設置沒有影響。當設置為 1 時，粒子的方向完全隨機。 Spherize Direction 將粒子的方向混合到球形方向，即它們將從 Transform 的中心向外移動。當設置為 0 時，這個設置沒有影響。當設置為 1 時，粒子的方向指向中心外側（其行為與形狀設置為 Sphere 時相同）。 Randomize Position 將粒子隨機移動直到指定的值。當設置為 0 時，這個設置沒有影響。任何其他值都會在粒子的生成位置上添加一些隨機性。 Box 屬性 說明 Shape Box： 從盒子（Box）的邊緣(edge)，表面(surface)或是盒體(body)發射粒子。粒子會向發射器物件的 Z 方向移動。 Emit from 從盒子（Box）的哪部分發射粒子，邊緣(Edge)，外殼(Shell)或體積(Volume)。 Texture 為粒子著色的紋理。 Position 對發射器形狀(emitter shape)應用一個偏移量。 Rotation 旋轉發射器形狀(emitter shape)。 Scale 改變發射器形狀(emitter shape)的大小。 Align to Direction 根據粒子初始移動方向來定向粒子。如果你想模擬例如在碰撞過程中從車身飛脫的漆塊，這會很有用。如果方向不滿意，你也可以在主模組中通過設置Start Rotation的值來覆蓋它。 Randomize Direction 將粒子的方向混合到隨機方向。當設置為 0 時，這個設置沒有影響。當設置為 1 時，粒子的方向完全隨機。 Spherize Direction 將粒子的方向混合到球形方向，即它們將從 Transform 的中心向外移動。當設置為 0 時，這個設置沒有影響。當設置為 1 時，粒子的方向指向中心外側（其行為與形狀設置為 Sphere 時相同）。 Randomize Position 將粒子隨機移動直到指定的值。當設置為 0 時，這個設置沒有影響。任何其他值都會在粒子的生成位置上添加一些隨機性。 Mesh ， MeshRenderer 與 SkinnedMeshRenderer 屬性 說明 Shape Mesh： 從盒子（Box）的邊緣(edge)，表面(surface)或是盒體(body)發射粒子。粒子會向發射器物件的 Z 方向移動。 Reference: https://docs.unity3d.com/Manual/PartSysShapeModule.html","link":"/2024/07/18/2024-07-18-shape/"},{"title":"Color over Lifetime","text":"此模組指定粒子在生命週期中要如何要如何顯示它的顏色與透明度。 屬性 說明 Color 粒子在其生命週期內的顏色漸變。漸變條最左邊的點表示粒子生命的開始，最右邊的點表示粒子生命的結束。 粒子會隨著時間變化顏色，例如，白熱的火花在穿過空氣時會冷卻，而魔法咒語可能會爆發出彩虹般的顏色。同樣重要的是透明度的變化。粒子在其生命週期結束時通常會燃燒殆盡、逐漸消失或散佈（例如，熱火花、煙火和煙霧粒子），而一個簡單的逐漸減少的漸變可以產生這種效果。 當同時使用起始顏色屬性時，此模組會將兩種顏色相乘，得到最終的粒子顏色。","link":"/2024/07/19/2024-07-19-color-over-lifetime/"},{"title":"粒子系統的 Color by Speed","text":"此模組可以根據粒子的速度（每秒的距離單位）來改變顏色 屬性 說明 Color 根據速度範圍定義的粒子顏色漸變。 Speed Range 此屬性用來映射顏色漸變（速度在範圍外的將映射到漸變的端點）。 燃燒或發光的粒子（如火花）在快速通過空氣時通常會燃燒得更亮（例如，當火花暴露在更多氧氣中時），但隨著速度減慢會稍微變暗。為了模擬這一點，你可以使用按速度變化顏色功能（Color By Speed），將漸變色設置為速度範圍的高端為白色，低端為紅色（在火花的例子中，更快的粒子會顯示為白色，而較慢的粒子則顯示為紅色）。","link":"/2024/07/19/2024-07-19-color-by-speed/"},{"title":"粒子系統的 Inherit Velocity","text":"使用這個模組在子發射器（subemitters）上。父系統中的每個粒子都可以在子發射器中產生粒子。此模組讀取來自父粒子的速度，並控制子發射器粒子的速度如何隨著時間對該速度作出反應。 屬性 說明 Mode 指定發射器速度如何應用於粒子。 Current ：發射器(emitter)目前的速度將會在每一幀中應用到所有粒子。例如，目前的發射器速度減慢，則所有粒子也會跟著減慢。 Initial ：發射器的速度會在每個粒子生成時應用一次。之後發射器速度的任何變化都不會影響已經生成的粒子。 Multiplier 設定粒子應繼承的發射器速度的比例。 這個模組適合從移動物體中發射粒子，例如從車輛產生的塵土，火箭的煙霧，蒸汽火車煙囪中的蒸汽，或任何需要粒子在初始階段以其來源物體的速度的百分比移動的情況。這個模組只在主模組中的 Simulation Space 設為 World 時才會對粒子產生影響。 也可以使用曲線讓效果隨時間變化。例如，你可以對新建立的粒子施加強的吸引力，隨時間減少。這對於蒸汽火車的煙霧會很有用，煙霧會隨時間慢慢漂移，停止並跟隨它所排放的火車。 Unity 以兩種方式計算發射器的速度，可以在主模組中的 Emitter Velocity 屬性設定要使用的計算方式： 基於附加的 Rigidbody 組件的速度 基於粒子系統的 Transform 組件在目前幀中移動的距離","link":"/2024/07/19/2024-07-19-inherit-velocity/"},{"title":"粒子系統的 Force over Lifetime","text":"在此模組中指定的力量（如風或吸引力）讓粒子加速。 屬性 說明 X, Y, Z 在 X、Y 和 Z 軸上應用於每個粒子的力量。 Space 選擇力量是應用於局部空間(Local)還是世界空間(World)。 Randomize 當使用 Random Between Two Constants 或 Random Between Two Curves 模式時，系統會在每一幀內從定義的範圍中選擇新的力的方向讓粒子的運動變得更加混亂和不規則。 在流體(Fluids)的運動中，常常會受到外力的影響。例如，煙霧從火源上升時，會因為周圍的熱空氣而稍微加速。通過使用曲線來控制粒子在其生命周期中的力量，可以實現微妙的效果。以之前的例子為例，煙霧最初會向上加速，但隨著上升的空氣逐漸變涼，力量會減弱。火焰產生的濃煙可能會在最初加速，然後隨著擴散變慢，甚至如果持續很長時間，可能會開始向下落。 Reference: https://docs.unity3d.com/Manual/PartSysForceOverLifeModule.html","link":"/2024/07/19/2024-07-19-force-over-lifetime/"},{"title":"粒子系統的 Emission Module","text":"Emission Module 的屬性會影響粒子系統發射的速率和時間。在建立一個新的粒子系統 GameObject 時，預設會啟用這個模組。 屬性 說明 Rate over Time 單位時間內發射粒子的數量(以秒為單位)。這表示在每個時間單位內，系統會產生指定數量的粒子。例如：設為 10 表示系統每秒會產生 10 個粒子。 Rate over Distance 每移動一單位距離發射的粒子數量(以米為單位)。這表示粒子系統根據其移動距離來發射粒子，而不是時間。例如：設為 5 時，則表示每移動一米時，系統會產生 5 個粒子。這個屬性在模擬由物體運動產生的粒子時非常有用（例如，從汽車輪子在泥土軌道上產生的灰塵） 這兩個值各自計算互不影響，例如系統在 10 秒內，移動了 5 米，那麼粒子系統會發射 10*(Rate over Time) + 5*(Rate over Distance) 個粒子 Bursts 一次性爆發是生成粒子的事件，這些設置允許在指定的時間點發射粒子。 Time ：設置在粒子系統開始播放後多少秒的時間點上發射爆發。 Count ：設置每次爆發可能發射的粒子數量。 Cycles ：設置爆發要播放多少次。 Interval ： 設置每個爆發周期觸發之間的時間間隔（以秒為單位）。 Probability ：控制每次爆發事件生成粒子的可能性。越高的值將使系統產生更多粒子，若值為 1 則保證系統每次爆發事件都會生成粒子，不會有任何隨機性或不確定性。 發射(emission)率可以是恆定的，也可以根據曲線(curve)在系統的生命週期內發生變化。 Reference: https://docs.unity3d.com/Manual/PartSysEmissionModule.html","link":"/2024/07/18/2024-07-18-emission-module/"},{"title":"粒子系統的 Noise module","text":"Noise module 為粒子運動添加湍流(turbulence)效果。預設中不會啟用這個模組。 屬性 說明 Separate Axes 對粒子效果進行細緻的調整，以便在 X、Y 和 Z 軸上分別應用不同的強度和重映射值。 Strength 一條曲線(curve)來定義噪聲效果(noise effect)在粒子整個生命週期中的強度。越高的值會使粒子移動得更快、更遠。 Frequency 此屬性控制了粒子改變運動方向的頻率以及改變方向的劇烈程度，較低的值會產生柔和(soft)、平滑(smooth)的噪聲(noise)，較高的值會產生快速變化的噪聲。 Scroll Speed 此屬性讓粒子隨著時間運動的更加不可預測和不規則。值越高粒子移動越不穩定。 Damping 啟用此屬性後，強度與頻率成正比。 Octaves 用於指定生成最終噪聲值的重疊噪聲層數。使用更多層會產生更豐富、更複雜的噪聲，但會顯著增加性能成本。 Octave Multiplier Octaves 啟用時才可用。對於每個額外的噪聲層(noise layer)，將強度按此比例減少。 Octave Scale Octaves啟用時才可用。使用此屬性來調整每個額外的噪聲層的頻率。 Quality 較低的 Quality ，可以減少效能消耗，但是也會影響噪聲(noise)的視覺效果。 Remap 將最終的噪聲值重新映射到不同的範圍內。 Remap Curve Remap 啟用時才可用。此屬性為描述如何將最終噪聲值轉換為不同範圍的曲線。例如，可以使用此曲線來選擇噪聲場中的較低範圍並忽略較高範圍，透過建造一個從高開始並在零處結束的曲線來實現。 Position Amount 控制噪聲對粒子位置影響的倍數。 Rotation Amount 控制噪聲對粒子旋轉影響的倍數（以每秒度數為單位）。 Size Amount 控制噪聲對粒子大小影響的倍數。 可以用強烈的高頻噪聲來模擬火星的運動，而使用柔和的低頻噪聲則更適合模擬煙霧效果。噪聲(Noise)演算法基於 Curl Noise，內部使用多個 Perlin Noise 樣本(Sample)來建立最終的噪聲場。 Reference: https://docs.unity3d.com/Manual/PartSysNoiseModule.html","link":"/2024/07/19/2024-07-19-noise-module/"},{"title":"粒子系統的 Velocity over Lifetime module","text":"Velocity over Lifetime 模組讓你可以在粒子生命週期中控制粒子的速度。預設中不會啟用這個模組。 屬性 說明 Linear X, Y, Z 粒子在 X，Y 與 Z 軸(axe) 上直線運動速度(Linear velocity) Space 指定線性 X、Y、Z 軸是指本地空間(Local)還是世界空間(World)。 Orbital X, Y, Z 粒子圍繞 X、Y 和 Z 軸的軌道速度(Orbital velocity)。 Offset X, Y, Z 繞軌粒子的軌道中心位置。 Radial 粒子朝向或遠離中心位置的徑向速度(Radial velocity)。 Speed Modifier 對粒子沿著/圍繞其當前移動方向的速度應用一個倍數。 要建立在特定方向上漂移的粒子，可以使用 Linear X, Y, Z 曲線(curve)模式。 要建立圍繞中心位置旋轉的粒子效果，請使用 Orbital X, Y, Z 。此外，可以使用 Radial 將粒子推向或遠離中心位置。通過使用 Offset X, Y, Z ，您可以為每個粒子定義自定義的旋轉中心。 您還可以使用此模組來調整粒子系統中粒子的速度，而不影響它們的方向，只需將上述所有值保持為零，僅修改 Speed Modifier 即可。 Reference: https://docs.unity3d.com/Manual/PartSysVelOverLifeModule.html","link":"/2024/07/19/2024-07-19-velocity-over-lifetime-module/"},{"title":"How to use Cursor AI in Unity","text":"在 Mac 的 Unity 中如何使用 Cursor AI ？以下記載如何在 Mac 的 Unity 中設定 Cursor AI 在 Unity 編輯器中，找到 Windows -&gt; Package Manager 點擊 + 展開選單，並找到 Add package from git URL 並選擇，在輸入 https://github.com/boxqkrtm/com.unity.ide.cursor.git ， 以安裝 Cursor Editor 。 接著到 https://www.cursor.com/ 註冊帳號並下載 Cusor Editor 安裝。 然後到 Preferences -&gt; External Tools -&gt; External Script Editor ，選擇安裝的 Cursor 至此，便可以在編寫程式碼的時候，使用 Cursor AI 了。 按下 ⌘ + L 可以開啟 AI 互動，在這邊你可以向AI闡述你的問題，讓它生成相關的程式碼 按下 ⌘ + K 在這邊你可以向AI闡述你的需求，讓它在選中的段落為你產生程式碼。","link":"/2024/09/22/2024-09-22-how-to-use-cursor-ai-in-unity/"},{"title":"粒子系統的 Lifetime by Emitter Speed","text":"Lifetime by Emitter Speed 模組根據發射器的速度來控制每個粒子的初始壽命。它會將粒子的初始壽命乘以一個取決於發射物體速度的值。對於大多數粒子系統來說，這個值是來自遊戲物體的速度，但對於子發射器（sub-emitter）來說，速度來自於生成該子發射器粒子的父粒子。 屬性 說明 Multiplier 粒子的初始壽命會乘上一個倍數。這個模組根據你設置的曲線模式以不同方式使用這個倍數。曲線模式包括： Constant ：使用固定倍數值。這種模式會忽略 Speed Range 屬性。 Curve ： 根據發射器的速度，將其映射到介於 0 和 1 之間的值，然後使用正規化為這個曲線取樣。 Random Between Two Constants ：為每個粒子設置一個介於兩個值之間的隨機倍數。這種模式會忽略 Speed Range 屬性。 Random Between Two Curves ：根據發射器的速度，將其映射到介於 0 和 1 之間的值，然後使用正規化為這些曲線取樣。對於每個粒子，模組會將倍數設置為這兩個樣本之間的隨機值。 Speed Range 粒子系統將發射器速度映射到 Multiplier（倍數）曲線上的最小值和最大值。如果發射器的速度等於第一個值，那麼倍數就是曲線開始時的值。如果發射器的速度等於第二個值，那麼倍數就是曲線末端的值。這個屬性僅在 倍數(Multiplier)的曲線模式設置為曲線 Curve 或 Random Between Two Curves 時才有關聯。 Reference: https://docs.unity3d.com/Manual/PartSysLifetimeByEmitterSpeedModule.html","link":"/2024/07/19/2024-07-19-lifetime-by-emitter-speed/"},{"title":"Unity 2D Liquid","text":"以下將介紹如何使用 Shader ， Texture ， 以及 Camera 來在 2D 中建立液體(Liquid)效果。 建立互動物件 首先建立液體：建立一個 Circle Sprite 並添加 CircleCollider2D 與 Rigidbody2D ，並命名為 Liquid 。 建立一個 Empty Game Object 命名為 Liquids ， 並在其中將剛剛建立的 Liquid 複製多份。 建立牆體：建立一個 Square Sprite 並加入 BoxCollider2D ，並命名為 Wall 。 建立一個 Empty Game Object 命名為 Walls ， 並在其中將剛剛建立的 Wall 複製多份，排列為一個可以承裝物體的凹型。 建立一個 Liquids Layer 建立一個 LiquidCamera 並更改以下屬性 Clear Flags ： Solid Color Background ： 黑色 Culling Mask ： 設為剛剛建立的 Liquids Layer Projection ： 更改為 Orthographic 建立一個 Textures 資料夾，在其中建立一個 Render Texture 並命名為 LiquidTexture 將剛剛建立的 LiquidTexture 設定到 LiquidCamera 的 Target Texture 安裝 Shader Graph 建立一個 Shaders 資料夾，在其中建立一個 Unlit Shader Graph 並命名為 LiquidShaderGraph 使用滑鼠左鍵點擊剛剛建立的 LiquidShaderGraph 打開 Shader Graph Editor 滑鼠在 + 按鈕上面點擊一下展開選單，找到 Texture 2D 並點擊建立，並命名為 MainTex 點擊剛剛建立的 MainTex 在右側的 Graph Inspector 中找到 Default 並將 LiquidTexture 設定到這個 Default 中 使用滑鼠左鍵按住 MainTex 並拖拉到中央，如下圖 在空白處按下滑鼠右鍵找到 Create Node 並按下，在 Create Node 選單中找到 Sample Texture 2D 並按下建立一個 Sample Texture 2D Node 使用滑鼠左鍵將 MainTex 的接點拖拉到剛剛建立的 Sample Texture 2D Node 建立一個 Float 並命名為 Tickness 建立一個 Step Node ，將剛剛建立的 Thickness 連接到 Edge ，將 Sample Texture 2D 的 Alpha (A) 連接到 In 建立一個 Color 並命名為 Color ， Default 設為藍色 建立一個 Multiply Node 並將 Step Node 的 Out 連接到 A ； 將剛剛建立的 Color 連接到 B 找到 Fragment Node ，將它的 Suface Type 設為 Transparent ，將 Step Node 的 Out 連接到 Fragment 的 Alpha ； 將 Multiply 的 Out 連接到 Base Color 最後按下 Save Asset 把它儲存 建立一個 Materials 資料夾，並在其中建立 Material 並命名為 LiquidMaterial 將剛剛建立的 LiquidMaterial 的 Shader 設為之前建立的 LiquidShaderGraph 並設定它的顏色為藍色 在 LiquidCamera 之下建立一個 Quad ，將它的 Z Position 設為 10 ，它的 Materials 設為 LiquidMaterial 最後觀看結果 Play TestLiquid2D on itch.io Reference: https://www.youtube.com/watch?v=_8v4DRhHu2g","link":"/2024/08/29/2024-08-29-liquid-2d/"},{"title":"Java 複製檔案的方式","text":"方法一： 使用 java.io 的 FileInputStream 讀取，在使用 FileOutputStream 寫入。這種方式使用 byte stream 直接讀取來源檔案內容，在寫入到目標檔案。比 Files.copy 慢。 123456789FileInputStream fis = new FileInputStream(&quot;source.txt&quot;);FileOutputStream fos = new FileOutputStream(&quot;destination.txt&quot;);byte[] buffer = new byte[1024];int length;while ((length = fis.read(buffer)) &gt; 0) { fos.write(buffer, 0, length);}fis.close();fos.close(); 方法二： 使用 java.nio 的 transferTo 讀取，在使用 transferFrom 寫入。這種方式可以直接在 FileChannel 中傳輸資料。它可以快速的將資料從一個 channel 傳輸到另外一個 channel ，而不需要在 User space 與 Kernal space 進行資料複製，是一種實現 zero copy 的複製方式。但是在某些作業系統中， transferTo 可能會限制傳輸的最大 Byte ，因此在使用時，可能需要進行分段傳輸。 12345FileChannel sourceChannel = new FileInputStream(&quot;source.txt&quot;).getChannel();FileChannel destChannel = new FileOutputStream(&quot;destination.txt&quot;).getChannel();sourceChannel.transferTo(0, sourceChannel.size(), destChannel);sourceChannel.close();destChannel.close(); 方法三： 使用 java.nio 的 Files.copy 。java NIO 提供的一種高級操作方式，但是它本身不實現 zero copy 技術 123Path sourcePath = Paths.get(&quot;source.txt&quot;);Path destinationPath = Paths.get(&quot;destination.txt&quot;);Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING); 注意：以上的操作都沒有使用 try finally 或是 try-with-resources 關閉資源，正確的使用需要關閉資源才不會造成 Memory leak 12345678910try (FileInputStream fis = new FileInputStream(&quot;source.txt&quot;); FileOutputStream fos = new FileOutputStream(&quot;destination.txt&quot;)) { byte[] buffer = new byte[1024]; int length; while ((length = fis.read(buffer)) &gt; 0) { fos.write(buffer, 0, length); }} catch (IOException e) { e.printStackTrace();}","link":"/2024/09/23/2024-09-23-java-copy-file/"},{"title":"TextMeshPro 顯示中文","text":"使用 TextMeshPro 時，因為 Unity 預設的字型資源（如 LiberationSans SDF）不包含中文字元，所以中文會顯示為空白或方框。我們需要自己下載支援中文的字體檔案，一些免費的可以在網路上找到，像是 Google 的 Noto Sans Traditional Chinese 生成靜態字體 將下載的字體檔案（如 .ttf 或 .otf）拖入 Unity 的專案中。 使用 Window -&gt; TextMeshPro -&gt; Font Asset Creator，選擇字型檔案後，可以生成 .asset 檔案。 這種方式需要手動指定要包含的字元範圍（如常用中文字、標點符號等），因此使用上較麻煩。 動態字體：如果不想手動管理字元集，可以使用 Dynamic Font Asset： 選擇 Assets -&gt; Create -&gt; TextMeshPro -&gt; Font Asset。 快捷鍵：Ctrl/Cmd + Shift + F12 Unity 將自動創建一個動態字體資產，該資產會在運行時根據需要生成缺失的字元，避免因字元缺失而顯示為空白。 Reference: https://docs.unity3d.com/Packages/com.unity.textmeshpro@3.2/manual/FontAssetsDynamicFonts.html","link":"/2024/11/18/2024-11-18-textmeshpro-%E9%A1%AF%E7%A4%BA%E4%B8%AD%E6%96%87/"},{"title":"Unity 資料(Data) 與 序列化(Serialization)","text":"資料結構在 Unity 中儲存資料時要選擇適合的資料結構來儲存，以下是 C# 常用的資料結構。 陣列 (Array)：陣列適用於大小固定、元素類型一致的集合。例如，儲存固定數量的關卡分數或完成狀態。123int[] levelScores = new int[10]; // 用於存儲 10 個關卡的分數levelScores[0] = 100; // 第一關的分數levelScores[1] = 200; // 第二關的分數 列表 (List)：列表是動態的，能在執行時調整大小，適合在需要新增或移除元素的情境。例如，動態管理角色的物品欄。123List&lt;string&gt; inventoryItems = new List&lt;string&gt;(); // 用於儲存物品清單inventoryItems.Add(&quot;Item1&quot;); // 添加物品inventoryItems.Add(&quot;Item2&quot;); // 添加物品 字典 (Dictionary)：字典是鍵(Key)與值(Value)的儲存方式，適合需要快速查找的情況。例如，排行榜系統或配置表。123Dictionary&lt;string, int&gt; leaderboard = new Dictionary&lt;string, int&gt;(); // 玩家名稱對應分數leaderboard[&quot;Player1&quot;] = 1000; // Player1 的分數leaderboard[&quot;Player2&quot;] = 1500; // Player2 的分數 自定義資料結構：當內建資料結構無法滿足需求時，可設計自定義結構以應對特定場景。例如，設計角色屬性與技能系統。1234567891011121314151617181920public class Character{ public string Name; public int Health; public int Mana; public List&lt;string&gt; Abilities; public Character(string name, int health, int mana) { Name = name; Health = health; Mana = mana; Abilities = new List&lt;string&gt;(); } public void AddAbility(string ability) { Abilities.Add(ability); }} 資料結構對效能的影響 優化記憶體使用選用適當的資料結構能減少不必要的記憶體浪費。例如：若需要儲存固定數量的元素，可使用 陣列 (Array) 而非列表 (List)。陣列因固定大小而佔用較少的記憶體空間。 提升存取與檢索速度不同的資料結構提供不同的存取效率，選擇合適的結構能顯著提升遊戲回應速度。例如：字典 (Dictionary) 提供常數時間的查找，非常適合需要快速檢索的場景，例如排行榜的玩家數據。 高效的資料操作適合的資料結構能簡化資料新增、刪除等操作，讓遊戲流程更順暢。例如：列表 (List) 適合用於需要頻繁增刪元素的場景，例如動態的物品欄。 降低處理負擔選用適當的資料結構可減少額外處理，進一步提升遊戲效能。例如：若需要按順序遍歷元素，使用 列表 (List) 而非字典 (Dictionary) 可避免多餘的鍵值查找。 資料序列化 (Serialization)序列化是將資料轉換為可儲存或傳輸的格式（如 JSON 或 XML）。在 Unity 中，以下是常見的序列化方法 使用 JSON 序列化，適合用於需要與網路服務或跨平台數據交換的情境。而 Unity 內建的 JsonUtility 類別，適合簡單的序列化。1234567891011121314151617181920212223242526using UnityEngine;[System.Serializable]public class GameData{ public int playerLevel; public int playerScore;}public class SerializationExample : MonoBehaviour{ private void Start() { // 建立資料 GameData data = new GameData { playerLevel = 10, playerScore = 500 }; // 序列化 string json = JsonUtility.ToJson(data); Debug.Log(&quot;Serialized JSON: &quot; + json); // 反序列化 GameData loadedData = JsonUtility.FromJson&lt;GameData&gt;(json); Debug.Log(&quot;Loaded Level: &quot; + loadedData.playerLevel); Debug.Log(&quot;Loaded Score: &quot; + loadedData.playerScore); }} 使用 XML 序列化，XML (eXtensible Markup Language) 是一種結構化的數據格式，常用於儲存遊戲設定(configuration settings)或是與舊系統的兼容。1234567891011121314151617181920212223242526272829303132using System.IO;using System.Xml.Serialization;using UnityEngine;[System.Serializable]public class GameData{ public int playerLevel; public int playerScore;}public class XmlSerializationExample : MonoBehaviour{ private void Start() { // 建立資料 GameData data = new GameData { playerLevel = 10, playerScore = 500 }; // 序列化 XmlSerializer serializer = new XmlSerializer(typeof(GameData)); StringWriter writer = new StringWriter(); serializer.Serialize(writer, data); string xml = writer.ToString(); Debug.Log(&quot;Serialized XML: &quot; + xml); // 反序列化 StringReader reader = new StringReader(xml); GameData loadedData = (GameData)serializer.Deserialize(reader); Debug.Log(&quot;Loaded Level: &quot; + loadedData.playerLevel); Debug.Log(&quot;Loaded Score: &quot; + loadedData.playerScore); }} 二進位序列化(Binary serialization)二進位序列化是一種將物件壓縮成緊湊的二進位格式的方式，適合用於需要高效儲存或讀寫數據的情境，例如保存遊戲進度或本地化配置文件。相比於 JSON 或 XML 等文本格式，二進位格式在讀取和寫入速度上具有顯著優勢，同時生成的數據也更小。但 BinaryFormatter 在 ASP.NET 應用程式中已淘汰並禁止。 ScriptableObjectScriptableObject 是 Unity 中用來存儲資料的資源(assets)類型，提供一種直觀的方式來管理設定、參數和可重複使用的組件。它們在 Unity 編輯器中以序列化的格式儲存數據。 定義 ScriptableObject 12345678using UnityEngine;[CreateAssetMenu(fileName = &quot;NewSettings&quot;, menuName = &quot;Game Settings&quot;)]public class GameSettings : ScriptableObject{ public int playerHealth; public int enemyCount; public float playerSpeed;} ScriptableObject 的序列化與反序列化 12345678910111213141516171819202122232425262728293031using UnityEngine;using System.IO;public class SettingsManager : MonoBehaviour{ public GameSettings gameSettings; // 引用 ScriptableObject // 保存遊戲設定到檔案 public void SaveSettings() { string jsonSettings = JsonUtility.ToJson(gameSettings); // 序列化為 JSON File.WriteAllText(Application.persistentDataPath + &quot;/settings.json&quot;, jsonSettings); // 寫入檔案 Debug.Log(&quot;Settings saved to &quot; + Application.persistentDataPath + &quot;/settings.json&quot;); } // 從檔案加載遊戲設定 public void LoadSettings() { string path = Application.persistentDataPath + &quot;/settings.json&quot;; if (File.Exists(path)) // 檢查檔案是否存在 { string jsonSettings = File.ReadAllText(path); // 讀取檔案 JsonUtility.FromJsonOverwrite(jsonSettings, gameSettings); // 將 JSON 加載到現有的 ScriptableObject Debug.Log(&quot;Settings loaded from &quot; + path); } else { Debug.LogWarning(&quot;Settings file not found at &quot; + path); } }} PlayerPrefsPlayerPrefs 是 Unity 提供的內建解決方案，用於以鍵(Key)值(Value)對的形式存儲小型資料，如玩家偏好設置、基本遊戲進度或遊戲內設置資料。它易於使用且跨平臺支持，適合管理輕量級資料。 PlayerPrefs 僅支持基礎類型（如 int、float 和 string）， 如果需要存儲更複雜的資料結構，則需要進行序列化。將資料轉換為 JSON 或 XML 格式，然後以字符串形式存儲到 PlayerPrefs 中。 PlayerPrefs 的資料以明文形式存儲，容易受到未授權的訪問。 何時不使用 PlayerPrefs，儘管 PlayerPrefs 簡單易用，但在以下情況下可能並不適合： 大型資料：對於複雜或大規模資料，就不適合使用，可改使用資料庫（如 SQLite）。 敏感數據：對於高度敏感的信息，應考慮使用加密文件或平台特定的安全存儲方案。 網絡同步：PlayerPrefs 不適合在設備間同步資料，應使用雲存儲或服務器端資料管理。","link":"/2024/11/26/2024-11-26-unity-data-and-serialization/"},{"title":"ScriptableObject 作為 Dependency Injection 的工具","text":"在 Unity 中，使用 Singleton Manager 是一種方便的設計模式，但它也有一些潛在的缺點和風險。如下 由於 Singleton 通常是全域可訪問的，這使得任何腳本都可以直接與其交互，導致程式碼之間的強耦合，使其難以測試以及維護 由於 Singleton 通常是靜態的並且在整個應用程式中持續存在，在單元測試時很難模擬或替換。 隨著功能增多， Singleton Manager 的代碼會變得臃腫，難以維護或擴展，可能導致其責任過多（違反單一職責原則，SRP）。 通常會使用 DontDestroyOnLoad 保持 Singleton 在場景切換中持久化，但這可能導致重複生成 Singleton （如果新場景中也有同樣的 Manager）導致出現錯誤或是多餘的資源佔用。 隱藏的依賴性，由於 Singleton 是全域性的，腳本中直接調用 Singleton 的方法可能隱藏了實際的依賴性，導致在代碼重構或移植時，可能很難理清某些功能到底依賴於哪些 Singleton 。 我們可以使用 ScriptableObject 作為 Dependency Injection 的工具，用來減少 Singleton Manager 的使用。首先建立一個 Abstract Class 123456public abstract class BaseDataService : ScriptableObject{ public abstract void SaveLevelData(LevelData levelData); public abstract LevelData LoadLevelData(int level);} 之後根據需要的實作去繼承這個 BaseDataService 類，例如你想要實作將存擋儲存到本機上的檔案中時，可以建立一個 FileGameDataService ，然後在該類實作這些方法 1234567891011121314151617181920[CreateAssetMenu(fileName = &quot;FileGameDataService&quot;, menuName = &quot;ScriptableObject/Data/GameDataService&quot;)]public class FileGameDataService : BaseDataService{ public override void SaveLevelData(LevelData levelData) { string json = JsonUtility.ToJson(levelData); File.WriteAllText(Application.persistentDataPath + $&quot;/level_{levelData.level}_{levelData.levelType}_{levelData.levelDifficulty}_data.json&quot;, json); } public override LevelData LoadLevelData(int levelIndex, LevelType levelType, LevelDifficulty levelDifficulty) { string path = Application.persistentDataPath + $&quot;/level_{levelIndex}_{levelType}_{levelDifficulty}_data.json&quot;; if (File.Exists(path)) { string json = File.ReadAllText(path); return JsonUtility.FromJson&lt;LevelData&gt;(json); } return null; }} 使用 Unity 編輯器建立一個 ScriptableObject。 在需要使用讀檔存檔方法的 MonoBehaviour 類中，加入 [SerializeField] private BaseDataService dataService 參考 123456789public class GameManager : MonoBehaviour{ [SerializeField] private BaseDataService dataService; public void SaveGame(LevelData levelData) { dataService.SaveLevelData(levelData); }} 最後，把這個 FileGameDataService 設定上去即可。 Reference: https://medium.com/glassblade/awesome-unity-dependency-injection-through-scriptableobjects-d58e0fc8f87c","link":"/2024/12/11/2024-12-11-scriptableobject-as-dependency-injection-tool/"},{"title":"Google Cloud Vision API with Java","text":"以下說明如何在 Java 中使用 Google Cloud Vision API。 前往 Google Cloud Console https://console.cloud.google.com/ 建立一個專案。 輸入專案名稱。 選擇 APIs Services -&gt; Enabled APIs &amp; services。 選擇 ENABLED APIs AND SERVICES。 在搜尋框中輸入 vision。 找到 Cloud Vision API 點擊進入。 啟用這個 Cloud Vision API API 建立一個 Service account 。選擇 Credentials -&gt; + CREATE CREDENTIALS -&gt; Service account 輸入 Service account 的 name 與 ID 並選擇 CREATE AND CONTINUE 第二步，可以跳過，選擇 CONTINUE 第三步，可以跳過，選擇 DONE ，建立 Service Account 點擊剛剛建立的 Service Account 選擇 KEYS -&gt; ADD KEY -&gt; Create new key 選擇 JSON ，就會產生一個 JSON 檔案，供之後 Java 程式使用 建立一個 Java 專案，並引用 google-cloud-vision 依賴，123456789101112131415161718&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.cloud&lt;/groupId&gt; &lt;artifactId&gt;libraries-bom&lt;/artifactId&gt; &lt;version&gt;26.50.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.cloud&lt;/groupId&gt; &lt;artifactId&gt;google-cloud-vision&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在程式碼中使用以下程式碼引入上面建立的 GoogleCredentials12GoogleCredentials credentials = GoogleCredentials .fromStream(new FileInputStream(&quot;&lt;在步驟15產生的json檔案&gt;&quot;)); 使用以下程式碼將 圖片文字的 Pdf 轉為 文字12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static void processPdf() throws IOException { GoogleCredentials credentials = GoogleCredentials .fromStream(new FileInputStream(&quot;&lt;在步驟15產生的json檔案&gt;&quot;)); ImageAnnotatorSettings imageAnnotatorSettings = ImageAnnotatorSettings.newBuilder() .setCredentialsProvider(FixedCredentialsProvider.create(credentials)).build(); try (ImageAnnotatorClient vision = ImageAnnotatorClient.create(imageAnnotatorSettings)) { String fileName = &quot;./image-based-pdf-sample.pdf&quot;; Path path = Paths.get(fileName); byte[] data = Files.readAllBytes(path); ByteString pdfBytes = ByteString.copyFrom(data); InputConfig inputConfig = InputConfig.newBuilder().setMimeType(&quot;application/pdf&quot;) // Supported MimeTypes: // &quot;application/pdf&quot;, // &quot;image/tiff&quot; .setContent(pdfBytes).build(); Feature feature = Feature.newBuilder().setType(Feature.Type.DOCUMENT_TEXT_DETECTION).build(); AnnotateFileRequest request = AnnotateFileRequest.newBuilder().setInputConfig(inputConfig) .addFeatures(feature).build(); List&lt;AnnotateFileRequest&gt; requests = new ArrayList&lt;&gt;(); requests.add(request); BatchAnnotateFilesResponse response = vision.batchAnnotateFiles(requests); List&lt;AnnotateFileResponse&gt; responses = response.getResponsesList(); for (AnnotateFileResponse res : responses) { if (res.hasError()) { System.out.format(&quot;Error: %s%n&quot;, res.getError().getMessage()); return; } int pageSize = res.getTotalPages(); System.out.println(&quot;pageSize = &quot; + pageSize); for (int i = 0; i &lt; pageSize; i++) { AnnotateImageResponse annotateImageResponse = res.getResponses(i); System.out.format(&quot;%nText: %s%n&quot;, annotateImageResponse.getFullTextAnnotation().getText()); } } }} 使用以下程式碼，可以辨認圖片12345678910111213141516171819202122232425262728293031323334353637public static void image() throws IOException { GoogleCredentials credentials = GoogleCredentials .fromStream(new FileInputStream(&quot;&lt;在步驟15產生的json檔案&gt;&quot;)); ImageAnnotatorSettings imageAnnotatorSettings = ImageAnnotatorSettings.newBuilder() .setCredentialsProvider(FixedCredentialsProvider.create(credentials)).build(); try (ImageAnnotatorClient vision = ImageAnnotatorClient.create(imageAnnotatorSettings)) { String fileName = &quot;./test.jpg&quot;; Path path = Paths.get(fileName); byte[] data = Files.readAllBytes(path); ByteString imgBytes = ByteString.copyFrom(data); List&lt;AnnotateImageRequest&gt; requests = new ArrayList&lt;&gt;(); Image img = Image.newBuilder().setContent(imgBytes).build(); Feature feat = Feature.newBuilder().setType(Type.LABEL_DETECTION).build(); AnnotateImageRequest request = AnnotateImageRequest.newBuilder().addFeatures(feat).setImage(img).build(); requests.add(request); BatchAnnotateImagesResponse response = vision.batchAnnotateImages(requests); List&lt;AnnotateImageResponse&gt; responses = response.getResponsesList(); for (AnnotateImageResponse res : responses) { if (res.hasError()) { System.out.format(&quot;Error: %s%n&quot;, res.getError().getMessage()); return; } for (EntityAnnotation annotation : res.getLabelAnnotationsList()) { annotation.getAllFields().forEach((k, v) -&gt; System.out.format(&quot;%s : %s%n&quot;, k, v.toString())); } } }} 整個 Java 程式碼 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package ultrasigncorp.vision;import java.io.FileInputStream;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.ArrayList;import java.util.List;import java.util.concurrent.TimeUnit;import java.util.regex.Matcher;import java.util.regex.Pattern;import com.google.cloud.vision.v1.AnnotateImageRequest;import com.google.cloud.vision.v1.Feature;import com.google.cloud.vision.v1.Feature.Type;import com.google.cloud.vision.v1.Image;import com.google.api.gax.core.FixedCredentialsProvider;import com.google.api.gax.longrunning.OperationFuture;import com.google.auth.oauth2.GoogleCredentials;import com.google.cloud.storage.Blob;import com.google.cloud.storage.Bucket;import com.google.cloud.storage.Storage;import com.google.cloud.storage.Storage.BlobListOption;import com.google.cloud.storage.StorageOptions;import com.google.cloud.vision.v1.*;import com.google.protobuf.ByteString;import com.google.protobuf.util.JsonFormat;import com.google.cloud.vision.v1.AnnotateFileResponse.Builder;public class Main { public static void main(String... args) throws Exception { image(); processPdf(); } public static void image() throws IOException { GoogleCredentials credentials = GoogleCredentials .fromStream(new FileInputStream(&quot;./test.json&quot;)); ImageAnnotatorSettings imageAnnotatorSettings = ImageAnnotatorSettings.newBuilder() .setCredentialsProvider(FixedCredentialsProvider.create(credentials)).build(); try (ImageAnnotatorClient vision = ImageAnnotatorClient.create(imageAnnotatorSettings)) { String fileName = &quot;./test.jpg&quot;; Path path = Paths.get(fileName); byte[] data = Files.readAllBytes(path); ByteString imgBytes = ByteString.copyFrom(data); List&lt;AnnotateImageRequest&gt; requests = new ArrayList&lt;&gt;(); Image img = Image.newBuilder().setContent(imgBytes).build(); Feature feat = Feature.newBuilder().setType(Type.LABEL_DETECTION).build(); AnnotateImageRequest request = AnnotateImageRequest.newBuilder().addFeatures(feat).setImage(img).build(); requests.add(request); BatchAnnotateImagesResponse response = vision.batchAnnotateImages(requests); List&lt;AnnotateImageResponse&gt; responses = response.getResponsesList(); for (AnnotateImageResponse res : responses) { if (res.hasError()) { System.out.format(&quot;Error: %s%n&quot;, res.getError().getMessage()); return; } for (EntityAnnotation annotation : res.getLabelAnnotationsList()) { annotation.getAllFields().forEach((k, v) -&gt; System.out.format(&quot;%s : %s%n&quot;, k, v.toString())); } } } } public static void processPdf() throws IOException { GoogleCredentials credentials = GoogleCredentials .fromStream(new FileInputStream(&quot;./test.json&quot;)); ImageAnnotatorSettings imageAnnotatorSettings = ImageAnnotatorSettings.newBuilder() .setCredentialsProvider(FixedCredentialsProvider.create(credentials)).build(); try (ImageAnnotatorClient vision = ImageAnnotatorClient.create(imageAnnotatorSettings)) { String fileName = &quot;./image-based-pdf-sample.pdf&quot;; Path path = Paths.get(fileName); byte[] data = Files.readAllBytes(path); ByteString pdfBytes = ByteString.copyFrom(data); InputConfig inputConfig = InputConfig.newBuilder().setMimeType(&quot;application/pdf&quot;) .setContent(pdfBytes).build(); Feature feature = Feature.newBuilder().setType(Feature.Type.DOCUMENT_TEXT_DETECTION).build(); AnnotateFileRequest request = AnnotateFileRequest.newBuilder().setInputConfig(inputConfig) .addFeatures(feature).build(); List&lt;AnnotateFileRequest&gt; requests = new ArrayList&lt;&gt;(); requests.add(request); BatchAnnotateFilesResponse response = vision.batchAnnotateFiles(requests); List&lt;AnnotateFileResponse&gt; responses = response.getResponsesList(); for (AnnotateFileResponse res : responses) { if (res.hasError()) { System.out.format(&quot;Error: %s%n&quot;, res.getError().getMessage()); return; } int pageSize = res.getTotalPages(); System.out.println(&quot;pageSize = &quot; + pageSize); for (int i = 0; i &lt; pageSize; i++) { AnnotateImageResponse annotateImageResponse = res.getResponses(i); System.out.format(&quot;%nText: %s%n&quot;, annotateImageResponse.getFullTextAnnotation().getText()); } } } }} Reference: https://cloud.google.com/vision/docs/reference/rest/v1/BatchAnnotateFilesResponse https://cloud.google.com/vision/docs/pdf https://github.com/googleapis/google-cloud-java/tree/main/java-vision","link":"/2024/12/09/2024-12-09-google-vision-api-with-java/"},{"title":"在 Unity 中使用 Google AdMob","text":"以下說明如何在 Unity 中使用 Google AdMob 在 Unity 編輯器中， Edit -&gt; Project Settings -&gt; Package Manager ，輸入以下資料並儲存123Name: OpenUPMURL: https://package.openupm.comScopes: com.google 在 Unity 編輯器中， Window -&gt; Package Manager 開啟 Package Manager ，找到 Google Mobile Ads for Unity 並按下 Install 安裝。 在 Unity 編輯器中， Project Settings -&gt; Player -&gt; Android -&gt; Publishing Settings -&gt; Build 確認 Custom Gradle Properties Template 和 Custom Gradle Settings Template 有被勾選。 在 Unity 編輯器中，選取 Assets -&gt; External Dependency Manager -&gt; Android Resolver -&gt; Resolve ，讓 Unity External Dependency Manager 程式庫將已宣告的依附元件複製到 Unity 應用程式的 Assets/Plugins/Android 目錄中。 在 Unity 編輯器中，選取選單中的 Assets -&gt; Google Mobile Ads -&gt; Settings ，設定 AdMob 應用程式 ID 在載入廣告之前，需要呼叫 MobileAds.Initialize() 讓應用程式初始化 Google Mobile Ads SDK。初始化只需執行一次，最好是在應用程式啟動時執行。1234567public class LoadGoogleMobileAdsScript : MonoBehaviour{ public void Start() { MobileAds.Initialize(initStatus =&gt; { }); }} 可以使用以下 id 使用測試廣告進行測試1234567#if UNITY_ANDROID private string _adUnitId = &quot;ca-app-pub-3940256099942544/6300978111&quot;;#elif UNITY_IPHONE private string _adUnitId = &quot;ca-app-pub-3940256099942544/2934735716&quot;;#else private string _adUnitId = &quot;unused&quot;;#endif 使用橫幅廣告 (Banner Ad) 使用 BannerView 類建立橫幅廣告 123456789// _adUnitId ：BannerView 應從中載入廣告的廣告單元 ID。// AdSize ：您要使用的廣告尺寸。詳情請參閱「橫幅廣告尺寸」。// AdPosition ：橫幅廣告應放置的位置。AdPosition 列舉了有效的廣告排序值。BannerView bannerView = new BannerView(_adUnitId, AdSize.Banner, AdPosition.Top);``` 2. 使用 request 載入廣告```csharpvar adRequest = new AdRequest();bannerView.LoadAd(adRequest); 使用後記得用銷毀廣告 12345if (bannerView != null){ bannerView.Destroy(); bannerView = null;} 完整程式碼 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class BannerAd : MonoBehaviour{ #if UNITY_ANDROID private string _adUnitId = &quot;ca-app-pub-3940256099942544/6300978111&quot;; #elif UNITY_IPHONE private string _adUnitId = &quot;ca-app-pub-3940256099942544/2934735716&quot;; #else private string _adUnitId = &quot;unused&quot;; #endif private BannerView _bannerView; void Start() { LoadAd(); } private void OnEnable() { LoadAd(); } private void OnDisable() { DestroyAd(); } public void CreateBannerView() { if (_bannerView != null) { DestroyAd(); } _bannerView = new BannerView(_adUnitId, AdSize.Banner, AdPosition.Top); } public void LoadAd() { if (_bannerView == null) { CreateBannerView(); } var adRequest = new AdRequest(); _bannerView.LoadAd(adRequest); } public void DestroyAd() { if (_bannerView != null) { _bannerView.Destroy(); _bannerView = null; } }} Reference: https://developers.google.com/admob/unity/quick-start?hl=zh-tw#openupm","link":"/2024/12/23/2024-12-23-how-to-use-google-admob-in-unity/"},{"title":"使用 AuidoMixer 管理聲音音量","text":"Unity 的 AuidoMixer 可以讓開發者將遊戲音樂，音效分組，方便管理。以下說明如何設定。 在 Unity 編輯器中， 找到 Create -&gt; Audio -&gt; AudioMixer ， 建立一個 AudioMixer 建立 AudioMixer 之後，可以更改為自己需要的名稱，例如 MainAudioMixer 在剛剛建立的 AudioMixer ，使用滑鼠左鍵點擊 Groups 區域旁邊的 + ， 建立兩個分組並命名為 Music 和 SoundEffect 找到有 AudioSource 的物件，將Group的欄位設定為對應的 Group ，將 AudioSource 分配到對應的分組，例如下圖將 Sound 的 Group 設為 SoundEffect 而 BackgroundMusic 的 Group 設為 Music 接著到 MainAudioMixer 物件，把它展開，會看到建立的 Group ，選擇 Music ，在 Inspector 上面，找到 Volume ，對著 Volume 按下滑鼠右鍵，選 Expose Volume (of Music) to script 。 SoundEffect 也是同樣的操作 在回到 MainAudioMixer ， 找到右上角的 Exposed Parameters 把它展開，並把它們命名為自己想要的名稱，注意這邊的名稱會在腳本中使用，腳本想要透過 audioMixer.SetFloat 變更數值的話，傳入名稱要一致才行。 使用範例程式碼。12345678910111213141516171819using UnityEngine;using UnityEngine.UI;public class SettingMenu : MonoBehaviour{ public AudioMixer audioMixer; public void SetSoundVolume(float value) { float dB = value &gt; 0 ? Mathf.Log10(value) * 20 : -80f; audioMixer.SetFloat(&quot;sound&quot;, dB); } public void SetMusicVolume() { float dB = value &gt; 0 ? Mathf.Log10(value) * 20 : -80f; audioMixer.SetFloat(&quot;music&quot;, dB); }} 注意，audioMixer.SetFloat 接受的是分貝值範圍（20f 為最大，-80f 為最小），如果希望使用範圍為 0 ~ 1 的線性值，可透過 Mathf.Log10 進行轉換。 float dB = value &gt; 0 ? Mathf.Log10(value) * 20 : -80f; 當 value 小於 0 或等於 0 時，直接返回 -80f 表示靜音 當 value 大於 0 時，計算 Mathf.Log10(value) * 20 ， 當 value 等於 1 時， Log10(1) 會返回 0 ， 剛好是 audioMixer 的原來音量 Reference: https://stackoverflow.com/questions/46529147/how-to-set-a-mixers-volume-to-a-sliders-volume-in-unity https://blog.csdn.net/tqy19921202/article/details/103734295","link":"/2024/12/13/2024-12-13-audiomixer/"},{"title":"在 Unity 中使用 Unit test","text":"本文記錄如何在 Unity 中使用內建的 Unity Test Runner 進行 Unit Test。 。 首先選擇 Window -&gt; General -&gt; Test Runner 開啟 Test Runner 。 到 Test Runner 中找到 Create a Test new Assembly Folder in the active path. 按鈕，按下。 按下後會建立一個 Tests 資料夾，裡面會幫你建立一個 Tests.asmdef 檔案，這個檔案是 Unity 的 Assembly Definition File (程序集定義文件)，讓你可以管理測試腳本的組件。 之後，為了讓測試腳本知道你寫的腳本，你需要在你放腳本的地方（如 Asserts/Scripts） 建立一個 Assembly Definition File (Create -&gt; Scripting -&gt; Assembly Definition)， 並取為自己想要的名稱，這邊命名為 MyScriptAssembly。 注意，如果你有使用 TextMeshPro 或是 DOTween 的話，你還需要在 MyScriptAssembly 中的 Assembly Definition References 加入 Unity.TextMeshPro 和 DOTween.Modules （預設不會有 DOTween.Modules，請參考 建立 DoTween 的 asmdef 檔案）。 接著回到 Tests.asmdef 檔案，將 MyScriptAssembly 加入到 Tests.asmdef 的 Assembly Definition References 中。 最後你就可以在 Unity 中開始使用 Unit Test 了，到 Tests 資料夾中，選擇 Create -&gt; Testing -&gt; C# Test Script 建立測試腳本。此外，你也可以在 Tests 資料夾中建立其他資料夾規劃你的測試。 建立測試腳本 12345678910111213141516171819public class NewTestScript{ // A Test behaves as an ordinary method [Test] public void NewTestScriptSimplePasses() { // Use the Assert class to test conditions } // A UnityTest behaves like a coroutine in Play Mode. In Edit Mode you can use // `yield return null;` to skip a frame. [UnityTest] public IEnumerator NewTestScriptWithEnumeratorPasses() { // Use the Assert class to test conditions. // Use yield to skip a frame. yield return null; }} 到 Test Runner 就可以看到測試了，可以一個一個選擇執行，或是執行全部。 一些注意事項： 如果要測試拋出例外之類的測試的話，需要使用 LogAssert.Expect 而不是 Assert.*** 12345678910111213141516171819202122// 測試錯誤日誌[Test]public void TestLogError(){ testComponent.LogError(&quot;Test error message&quot;); LogAssert.Expect(LogType.Error, &quot;&lt;color=red&gt;❌&lt;/color&gt;[&lt;color=lightblue&gt;TestObject&lt;/color&gt;]: Test error message\\n&quot;);}// 測試例外日誌[Test]public void TestLogException(){ try { int a = 0; float b = 1 / a; } catch (System.Exception e) { testComponent.LogException(e, &quot;My Message&quot;); } LogAssert.Expect(LogType.Exception, &quot;DivideByZeroException: Attempted to divide by zero.&quot;);} SetUp 與 TearDown SetUp: 每個測試案例開始前，會執行此方法。通常用來還原測試案例初始化狀態，確保測試案例不互相干擾。 TearDown: 每個測試案例完成後，會執行此方法。通常用來清除測試案例的狀態，確保測試案例不互相干擾。123456789101112131415161718192021private class TestObject : MonoBehaviour { }private GameObject testGameObject;private TestObject testComponent;private LogCapture logCapture;[SetUp]public void Setup(){ testGameObject = new GameObject(&quot;TestObject&quot;); testComponent = testGameObject.AddComponent&lt;TestObject&gt;(); logCapture = new LogCapture(); Application.logMessageReceived += logCapture.HandleLog;}[TearDown]public void Teardown(){ Application.logMessageReceived -= logCapture.HandleLog; Object.DestroyImmediate(testGameObject);} 建立 DoTween 的 asmdef 檔案 一般預設是不會有 DoTween 的 asmdef 檔案，必須到 Tools -&gt; Demigiant -&gt; DOTween Utility Panel 中，開啟 DOTween Utility Panel並找到 Create ASMDEF 按鈕 ，按下建立 asmdef 檔案。","link":"/2025/01/30/2025-01-30-create-unit-test-for-unity/"},{"title":"使用粒子系統(Particle System) 製作 2D 煙霧效果","text":"首先需要一張煙霧圖片，這邊使用 Photopea 來製作做煙霧圖片，進入 Photopea 後，選擇 檔案 -&gt; 新增 ， 會彈出新增專案畫面。 將寬高設定為 512 像素 。 DPI 設為 100 像素/Inch 。 背景選擇白色。 選擇 檢視 -&gt; 顯示 -&gt; 格線 。啟用格線，方便我們之後對齊 選擇 編輯 -&gt; 選項 打開選項畫面，調整格線大小，由於 寬高是 512 ，我們想要切為四等分，因此設定網格間隙為 512 / 4 = 128 接著選擇 濾鏡 -&gt; 渲染 -&gt; 雲彩 。 建立一個雲霧的圖片 再建立一個新專案，寬高一樣是 512 ， 但是這次背景選 透明 回到有雲彩圖片的專案，選擇套索工具，羽化設為 20 px ， 使用 套索工具 切出煙霧圖案 按下 ctrl + c 將切出的圖案複製 ， 切換到 背景透明的專案，按下 ctrl + v 貼上。可以使用移動工具，移動煙霧圖片，對齊中心。 如下圖： 最後，輸出煙霧圖片為 PNG 至此，我們的煙霧圖片就準備完畢了。 接著到 Unity 編輯器中。將煙霧圖片複製到裡面 建立一個 Material，命名為 SmokeMaterial 將 SmokeMaterial 的 Shader 更改為 Particles/Unlit 將 Surface Type 設為 Transparent 。設為透明。 將 Surface Inputs 中 Base Map 設為剛剛的煙霧圖片。 建立一個 GameObject ，命名為 Smoke 。接著在這個物件下建立一個 Particle System ， 命名為 Smoke Particle System。 以下開始設定 Smoke Particle System ，Transform 組件 預設噴射方向是朝 Z 軸方向噴射，由於是 2D 遊戲，我們將其 Rotation 的 X 設為 -90 ， 讓粒子系統朝 Y 軸方向噴射，在畫面上會呈現朝上噴射。 修改以下模組主模組 Start Life Time ： 設為 Random Between Two Constants， 2 和 5 Start Speed ：設為 Random Between Two Constants， 3 和 4 Start Rotation ：設為 Random Between Two Constants， -180 和 180 Scaling Mode ： Hierarchy 。 讓粒子系統可以直接隨父級物件縮放。 Emission 模組 Rate over Time ： 40 。 每秒生成的40個粒子。 Shape 模組 Shape ： Cone 。 Color over Lifetime 模組 開始時顏色為白色且透明，逐漸變得不透明，然後變為黑色並再次變透明，模擬煙霧散去的效果。 Texture Sheet Animation 模組 Mode ： Grid 。確保煙霧圖片已經被切割為 2×2 的動畫格，這樣才能正確使用 Grid 模式來播放動畫。 Tile ： 圖片是 4 個，因此 X, Y 設為 2 X ： 2 Y ： 2 Animation ： Whole Sheet 。 整張圖片 Time Mode ： LifeTime Frame over Time ： 選擇 Random Between Constants ， 數字填 0 和 3 Renderer 模組 Material ： 更改為上面建立的 SmokeMaterial 最後效果如圖 參考： https://www.bilibili.com/video/BV1UY4y1n76t?spm_id_from=333.788.videopod.sections&amp;vd_source=f103d4eb21cc24456defbcf356882852","link":"/2025/01/29/2025-01-29-particle-system-smoke-effect/"},{"title":"緩動函數 (Easing function)","text":".chart_canvas_wrapper{ /* height: 200px; */ width: 300px; } 緩動函數 (Easing function) 用於控制物件的速度變化。它們決定物件如何從開始到結束的進行方式，比如是否線性移動，或逐漸加速、減速，甚至彈跳等效果。讓物件的移動看起來更生動。 提升動畫的自然感：讓動畫看起來更流暢，避免機械化的線性運動。 增強視覺效果：通過不同的速度變化，創造出多樣的動畫風格。 改善用戶體驗：讓交互更生動，提升用戶對動畫的感知。 緩入 (Ease In)：物件從靜止逐漸加速 (從 0 開始加速)。 適合物體從靜止開始移動的動畫。 緩出 (Ease Out)：物件從高速逐漸減速直到靜止 (減速到 0)。 適合物體移動到目標位置後停止的動畫。 緩入緩出 (Ease InOut)：先加速後減速的平滑運動 (前半段從 0 開始加速，後半段減速到 0)。 適合彈跳、滑動等動畫。 線性運動 (Linear) ： 等速運動，從開始到結束的速度完全一致。 適合進度條。 緩動函數的圖示 線性（Linear）：一條直線。 緩入（Ease-In）：曲線從平緩到陡峭。 緩出（Ease-Out）：曲線從陡峭到平緩。 緩入緩出（Ease-In-Out）：曲線呈 S 形。 彈性（Elastic）：曲線有多次波動。 反彈（Bounce）：曲線有多次階梯狀下降。 Quad ： 二次方曲線。 適合簡單的加速或減速動畫，如按鈕點擊效果。 Cubic ： 三次方曲線。 適合需要更強烈速度變化的動畫，如頁面切換。 Quart ： 四次方曲線。 適合需要快速加速或減速的動畫，如彈出窗口。 Quint ： 五次方曲線。 適合極端的速度變化效果，如快速閃現的動畫。 Since ： 平滑的正弦波曲線。 適合需要柔和過渡的動畫，如淡入淡出效果。 Expo ： 指數運動，起始或結束速度變化極快，幾乎瞬間到達或停止。 適合需要極快速度變化的動畫，如閃電效果。 Circ ： 模擬圓形曲線運動，速度變化平滑且自然。 適合模擬圓形軌跡的動畫，如旋轉效果。 Bounce ： 模擬物體彈跳的效果。 適合模擬球體落地或彈跳的動畫，如按鈕點擊後的反饋。 Elastic ： 模擬彈簧運動的效果，帶有回彈。 適合模擬彈簧或彈性物體的動畫，如彈性按鈕。 Flash ： 快速來回閃動的效果。 適合需要快速閃動的動畫，如警告提示。 Play Test Ease on itch.io --- Quad Cubic Quart Quint Sine Exponential Circ Elastic Back Bounce - 集合在一張圖中 - document.addEventListener('DOMContentLoaded', function() { const easeInQuad = (x) => { return x * x; }; const easeOutQuad = (x) => { return 1 - Math.pow(1 - x, 2); }; const easeInOutQuad = (x) => { return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2; }; const easeInCubic = (x) => { return x * x * x; }; const easeOutCubic = (x) => { return 1 - Math.pow(1 - x, 3); }; const easeInOutCubic = (x) => { return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2; }; const easeInQuart = (x) => { return x * x * x * x; }; const easeOutQuart = (x) => { return 1 - Math.pow(1 - x, 4); }; const easeInOutQuart = (x) => { return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2; }; const easeInQuint = (x) => { return x * x * x * x * x; }; const easeOutQuint = (x) => { return 1 - Math.pow(1 - x, 5); }; const easeInOutQuint = (x) => { return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2; }; const easeInSine = (x) => { return 1 - Math.cos((x * Math.PI) / 2); }; const easeOutSine = (x) => { return Math.sin((x * Math.PI) / 2); }; const easeInOutSine = (x) => { return -(Math.cos(Math.PI * x) - 1) / 2; }; const easeInExpo = (x) => { return x === 0 ? 0 : Math.pow(2, 10 * x - 10); }; const easeOutExpo = (x) => { return x === 1 ? 1 : 1 - Math.pow(2, -10 * x); }; const easeInOutExpo = (x) => { return x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2; }; const easeInCirc = (x) => { return 1 - Math.sqrt(1 - Math.pow(x, 2)); }; const easeOutCirc = (x) => { return Math.sqrt(1 - Math.pow(x - 1, 2)); }; const easeInOutCirc = (x) => { return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2; }; const easeInElastic = (x) => { const c4 = (2 * Math.PI) / 3; return x === 0 ? 0 : x === 1 ? 1 : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4); }; const easeOutElastic = (x) => { const c4 = (2 * Math.PI) / 3; return x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1; }; const easeInOutElastic = (x) => { const c5 = (2 * Math.PI) / 4.5; return x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2 : (Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5)) / 2 + 1;}; const easeInBack = (x) => { const c1 = 1.70158; const c3 = c1 + 1; return c3 * x * x * x - c1 * x * x; }; const easeOutBack = (x) => { const c1 = 1.70158; const c3 = c1 + 1; return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);}; const easeInOutBack = (x) => { const c1 = 1.70158; const c2 = c1 * 1.525; return x < 0.5 ? (Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2 : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2; }; const easeInBounce = (x) => { return 1 - easeOutBounce(1 - x); }; const easeOutBounce = (x) => { const n1 = 7.5625; const d1 = 2.75; if (x < 1 / d1) { return n1 * x * x; } else if (x < 2 / d1) { return n1 * (x -= 1.5 / d1) * x + 0.75; } else if (x < 2.5 / d1) { return n1 * (x -= 2.25 / d1) * x + 0.9375; } else { return n1 * (x -= 2.625 / d1) * x + 0.984375; } }; const easeInOutBounce = (x) => { return x < 0.5 ? (1 - easeOutBounce(1 - 2 * x)) / 2 : (1 + easeOutBounce(2 * x - 1)) / 2; }; const points =[]; const pointLength = 100; const pointRadius = 1; for(let i = 0; i < pointLength; i++){ let y_point = easeInCubic(i/pointLength); points.push({x: i/pointLength, y:y_point}); } const chart = new Chart(document.getElementById('EaseInCubic').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInCubic', data: points, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points2 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeOutCubic(i/pointLength); points2.push({x: i/pointLength, y:y_point}); } const chart2 = new Chart(document.getElementById('EaseOutCubic').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseOutCubic', data: points2, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points3 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeInOutCubic(i/pointLength); points3.push({x: i/pointLength, y:y_point}); } const chart3 = new Chart(document.getElementById('EaseInOutCubic').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInOutCubic', data: points3, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points4 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeInQuad(i/pointLength); points4.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseInQuad').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInQuad', data: points4, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points5 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeOutQuad(i/pointLength); points5.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseOutQuad').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseOutQuad', data: points5, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points6 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeInOutQuad(i/pointLength); points6.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseInOutQuad').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInOutQuad', data: points6, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points7 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeInQuart(i/pointLength); points7.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseInQuart').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInQuart', data: points7, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points8 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeOutQuart(i/pointLength); points8.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseOutQuart').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseOutQuart', data: points8, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points9 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeInOutQuart(i/pointLength); points9.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseInOutQuart').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInOutQuart', data: points9, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points10 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeInQuint(i/pointLength); points10.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseInQuint').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInQuint', data: points10, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points11 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeOutQuint(i/pointLength); points11.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseOutQuint').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseOutQuint', data: points11, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points12 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeInOutQuint(i/pointLength); points12.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseInOutQuint').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInOutQuint', data: points12, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points13 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeInSine(i/pointLength); points13.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseInSine').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInSine', data: points13, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points14 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeOutSine(i/pointLength); points14.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseOutSine').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseOutSine', data: points14, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points15 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeInOutSine(i/pointLength); points15.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseInOutSine').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInOutSine', data: points15, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points16 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeInExpo(i/pointLength); points16.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseInExpo').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInExpo', data: points16, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points17 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeOutExpo(i/pointLength); points17.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseOutExpo').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseOutExpo', data: points17, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points18 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeInOutExpo(i/pointLength); points18.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseInOutExpo').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInOutExpo', data: points18, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points19 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeInCirc(i/pointLength); points19.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseInCirc').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInCirc', data: points19, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points20 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeOutCirc(i/pointLength); points20.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseOutCirc').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseOutCirc', data: points20, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points21 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeInOutCirc(i/pointLength); points21.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseInOutCirc').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInOutCirc', data: points21, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points22 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeInElastic(i/pointLength); points22.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseInElastic').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInElastic', data: points22, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points23 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeOutElastic(i/pointLength); points23.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseOutElastic').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseOutElastic', data: points23, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points24 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeInOutElastic(i/pointLength); points24.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseInOutElastic').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInOutElastic', data: points24, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points25 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeInBack(i/pointLength); points25.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseInBack').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInBack', data: points25, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points26 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeOutBack(i/pointLength); points26.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseOutBack').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseOutBack', data: points26, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points27 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeInOutBack(i/pointLength); points27.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseInOutBack').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInOutBack', data: points27, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points28 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeInBounce(i/pointLength); points28.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseInBounce').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInBounce', data: points28, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points29 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeOutBounce(i/pointLength); points29.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseOutBounce').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseOutBounce', data: points29, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); const points30 =[]; for(let i = 0; i < pointLength; i++){ let y_point = easeInOutBounce(i/pointLength); points30.push({x: i/pointLength, y:y_point}); } new Chart(document.getElementById('EaseInOutBounce').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [{ label: 'EaseInOutBounce', data: points30, borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, pointRadius: pointRadius }] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); new Chart(document.getElementById('AllInOne').getContext('2d'), { type: 'line', responsive: true, data: { datasets: [ { label: 'EaseInCubic', data: points, borderColor: 'rgba(255, 99, 132, 1)', // 紅色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseOutCubic', data: points2, borderColor: 'rgba(54, 162, 235, 1)', // 藍色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseInOutCubic', data: points3, borderColor: 'rgba(75, 192, 192, 1)', // 青綠色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseInQuad', data: points4, borderColor: 'rgba(255, 206, 86, 1)', // 黃色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseOutQuad', data: points5, borderColor: 'rgba(153, 102, 255, 1)', // 紫色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseInOutQuad', data: points6, borderColor: 'rgba(255, 159, 64, 1)', // 橙色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseInQuart', data: points7, borderColor: 'rgba(75, 192, 75, 1)', // 深綠色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseOutQuart', data: points8, borderColor: 'rgba(0, 128, 255, 1)', // 天藍色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseInOutQuart', data: points9, borderColor: 'rgba(255, 105, 180, 1)', // 粉紅色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseInQuint', data: points10, borderColor: 'rgba(139, 69, 19, 1)', // 棕色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseOutQuint', data: points11, borderColor: 'rgba(64, 224, 208, 1)', // 綠松石色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseInOutQuint', data: points12, borderColor: 'rgba(255, 223, 0, 1)', // 金色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseInSine', data: points13, borderColor: 'rgba(220, 20, 60, 1)', // 深紅色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseOutSine', data: points14, borderColor: 'rgba(30, 144, 255, 1)', // 閃亮藍 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseInOutSine', data: points15, borderColor: 'rgba(50, 205, 50, 1)', // 萊姆綠 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseInExpo', data: points16, borderColor: 'rgba(138, 43, 226, 1)', // 紫羅蘭色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseOutExpo', data: points17, borderColor: 'rgba(255, 20, 147, 1)', // 粉色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseInOutExpo', data: points18, borderColor: 'rgba(255, 140, 0, 1)', // 深橙色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseInCirc', data: points19, borderColor: 'rgba(47, 79, 79, 1)', // 深灰綠色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseOutCirc', data: points20, borderColor: 'rgba(0, 191, 255, 1)', // 天藍 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseInOutCirc', data: points21, borderColor: 'rgba(186, 85, 211, 1)', // 亮紫 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseInElastic', data: points22, borderColor: 'rgba(34, 139, 34, 1)', // 森林綠 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseOutElastic', data: points23, borderColor: 'rgba(255, 99, 71, 1)', // 番茄紅 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseInOutElastic', data: points24, borderColor: 'rgba(218, 165, 32, 1)', // 黃金棕色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseInBack', data: points25, borderColor: 'rgba(128, 128, 128, 1)', // 灰色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseOutBack', data: points26, borderColor: 'rgba(70, 130, 180, 1)', // 鋼藍色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseInOutBack', data: points27, borderColor: 'rgba(60, 179, 113, 1)', // 海洋綠 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseInBounce', data: points28, borderColor: 'rgba(233, 150, 122, 1)', // 深珊瑚色 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseOutBounce', data: points29, borderColor: 'rgba(255, 215, 0, 1)', // 金黃 borderWidth: 2, fill: false, pointRadius: pointRadius }, { label: 'EaseInOutBounce', data: points30, borderColor: 'rgba(123, 104, 238, 1)', // 中紫色 borderWidth: 2, fill: false, pointRadius: pointRadius } ] }, options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: '' } }, y: { title: { display: true, text: '' } } } } }); }); Reference: https://easings.net/#","link":"/2024/12/02/2024-12-02-easing-function/"},{"title":"Unity UGUI performance","text":"Canvas在 Unity UI 中，修改單一元素可能會觸發整個 Canvas 的重新整理。這種重新評估與網格生成的過程會對效能造成嚴重影響，特別是在複雜的 UI 設計中。主要原因如下： 網格生成成本高：Unity 的 UI 系統會將元素分組為繪製批次（Draw Calls），但每次小變動都需要重新生成批次，導致高資源消耗。 過度使用單一 Canvas：將大量 UI 元素集中於一個 Canvas 內，當有微小更新時，會引發顯著的效能尖峰。 解決方式：將 UI 分割到多個 Canvas 是減少效能問題的有效方法。 將單一個 Canvas 分割為 巢狀 Canvas（Nested Canvases），這麼做的好處有 子 Canvas 與父 Canvas 和兄弟 Canvas 互相隔離，具有獨立的幾何圖形和批次處理功能。 有助於組織層次結構化的 UI。 單一 Canvas 的變動不會影響其他 Canvas，縮小了網格重新生成的範圍。 分割 Canvas 的最佳實踐 依刷新頻率分組： 靜態元素：將不常變動的 UI 元素（如背景圖片、標題）放在單獨的 Canvas 上。 動態元素：將頻繁更新的 UI 元素（如血量條、分數、計時器）分配到不同的 Canvas。 保持一致性： 確保 Canvas 內的元素共享相同的 Z 值、材質和貼圖，以提高批次處理的效率。 避免過度巢狀化： 雖然巢狀 Canvas 功能強大，但過度巢狀化會增加維護難度。應針對邏輯分組策略性使用。 範例結構： 主 Canvas：作為 UI 的總容器。 HUD Canvas：顯示血量、分數和小地圖（頻繁更新）。 暫停菜單 Canvas：包含按鈕和靜態菜單元素（很少更新）。 背包 Canvas：用於展示背包內容（僅在打開時更新）。 這樣的結構下，當玩家血量在遊戲中變動時，僅 HUD Canvas 會更新，暫停菜單 Canvas和背包 Canvas 不受影響。這樣的分割方式有效避免了不必要的效能開銷。 Graphic RaycastersGraphic Raycaster 是 Unity UI 系統的一部分，負責將玩家的觸控或點擊行為轉換為遊戲可理解的事件。它的主要作用是： 事件檢測：確認玩家觸碰的屏幕區域是否對應到某個 UI 元素。 信息傳遞：將觸控位置與設定為可互動的 UI 元素匹配，並將事件傳遞給正確的遊戲部分。 運作方式：Graphic Raycaster 僅關注 UI 圖形元素（例如按鈕、圖片）。檢查所有設置為可響應觸控的 UI 部件，並確認玩家的觸碰是否在其範圍內。 Graphic Raycaster 產生的問題： 效能消耗高： 每次觸控時，Graphic Raycaster 都需要遍歷屏幕上的所有可交互 UI 元素。 過多的 Graphic Raycaster 或不必要的檢測可能導致資源浪費，尤其是在大型 UI 設計中。 非交互元素： 並非所有 UI 元素都需要響應觸控事件，例如裝飾性的圖片或靜態文本。對這些元素進行射線檢測會降低效能。 解決方式： 移除不必要的 Graphic Raycasters 確保僅在需要檢測觸控事件的 UI Canvas 或元素上添加 Graphic Raycaster。 非交互式 Canvas（例如背景圖像）則移除 Graphic Raycaster，避免不必要的檢測。 關閉非交互元素的 Raycast Target 對於不需要觸控的 UI 元素（如純裝飾性圖片），關閉其 Raycast Target 設定。 在 Image 組件中，取消勾選 Raycast Target。 這樣可以防止該元素被包含在射線檢測的範圍內，減少計算負擔。 使用阻擋遮罩（Blocking Mask） 當 Canvas 的 Render Mode 設置為 Worldspace Camera 或 Screen Space Camera 時，可以使用 Blocking Mask： 該遮罩決定 Raycaster 是否使用 2D 或 3D 物理來檢測阻擋物。 如果物理檢測對 UI 無直接影響，避免啟用該功能以節省資源。 分割 Canvas 將靜態和動態 UI 元素分離至不同的 Canvas。 靜態 Canvas 不需要頻繁更新，也不需要 Graphic Raycaster。 例子：假設遊戲的 UI 包含以下部分 主菜單：大部分按鈕需要觸控響應，因此保留 Graphic Raycaster，並確保按鈕的 Raycast Target 為啟用狀態。 背景圖片：純裝飾性元素，關閉 Raycast Target 並移除其 Canvas 的 Graphic Raycaster。 玩家 HUD（血量條、得分顯示）：分配到單獨的 Canvas，僅需要檢測少數互動（例如按鈕點擊）。 管理 UI 對象池問題：在常見的 UI 對象池使用方式中，開發者通常先更改對象的父節點（parent），再禁用對象（disable）。然而，這樣的操作會導致： 多次改變層級結構：反復更新對象的層級關係（hierarchy），使得整體性能受到影響。 不必要的開銷：每次改變父節點或激活/禁用對象時，Unity 會標記整個層級結構為“髒”，從而增加開銷。 解決方案：優化對象激活與重設順序 為提高效率，建議按照以下順序管理 UI 對象池： 禁用對象再更改父節點： 禁用對象（SetActive(false)）後再將其重新分配到對象池的父節點。 這樣可以確保原始層級結構僅被標記一次為“髒”，避免重複更新。 從對象池提取時的順序： 先更改父節點：將對象移動到新父節點中。 更新對象數據：重設對象的數據（如 UI 文本或圖片）。 最後激活對象：使用 SetActive(true) 啟用對象。 這樣的流程可將每個對象的層級結構變化降至最少，從而減少不必要的性能開銷。 隱藏 Canvas 的方法在開發過程中，可能需要暫時隱藏某些 UI 元素或整個 Canvas。常見的方式有 使用 SetActive(false) 禁用整個 GameObject 可能會導致 Canvas 層級結構中的回調函數執行（如 OnDisable 和 OnEnable），增加不必要的性能開銷。 移動 Canvas 的位置，讓使用者看不見 並不能停止 GPU 的繪製操作，仍會影響性能。 改變透明度， 並不能停止 GPU 的繪製操作，仍會影響性能。 解決方案：停用 Canvas 組件，透過停用 Canvas 可以 停止繪製操作，當停用 Canvas 組件會立即停止向 GPU 發送繪製請求，使畫布變得不可見。 並保留頂點緩衝區，Canvas 的頂點資料（meshes 和 vertices）會被保留，因此在重新啟用時無需重建(rebulid)，僅需恢復繪製操作。 避免不必要的回調，停用 Canvas 組件不會觸發整個層級結構的 OnDisable/OnEnable 回調，從而減少性能損耗。 UI 元素動畫當在 UI 元素上應用 Animator 時，即使動畫的值保持不變，也會在每一幀對 UI 元素產生影響。這會導致 不必要的性能消耗，特別是在多個靜態 UI 元素上。 解決方案：針對靜態或偶爾改變的 UI 動畫需求，避免使用 Animator。可以透過以下方式實現高效的 UI 動畫。使用程式碼或 Tweening 系統進行動畫處理 手寫動畫程式碼：針對簡單的動畫需求，直接使用 C# 程式碼逐步更改 UI 屬性（如位置、透明度等）。 Tweening 系統：使用輕量級的 Tweening 庫來簡化動畫實現。 Tweening 系統通過插值逐步更改屬性，對於臨時或事件驅動的動畫需求非常高效。 使用專業的 Tweening 資產（如 DoTween）可以快速實現高效動畫。 開發 UI 建議 為最常用的 UI 元素建立 Prefabs 對於經常使用的 UI 元素（如標題文字），可以將其創建為 Prefab，並將所需的組件附加到這些 Prefab 上。這樣一來，當你需要修改某些元素時，所有使用該 Prefab 的地方都會自動更新，讓你更輕鬆地管理與修改 UI 元素。 例子：假設你有多個地方需要顯示標題文字，將標題文字做成 Prefab，並在遊戲中重複使用。未來如果需要調整字體或大小，只需更改 Prefab，就能同步更新所有相關元素。 使用 Sprite Atlas 在 Unity 中使用 Sprite Atlas 來將多個 Sprite 紋理打包到一個單一的紋理資源中。這對於優化遊戲效能非常有幫助，因為它減少了渲染過程中的 draw calls，從而提升遊戲性能，特別是在移動設備上。 Sprite Atlas 的優點： Draw call 優化：使用 Sprite Atlas，可以減少 draw calls，讓 Unity 在渲染多個 Sprite 時只用一個 draw call，大大提高性能。 紋理分組：Sprite Atlas 讓你能夠將多個 Sprite 或紋理打包在一起，便於管理和組織資源。 自動打包：Unity 會自動進行紋理打包，將個別的 Sprite 儘可能地安排在 Atlas 中，減少空白區域的浪費，並優化紋理使用。 Mipmapping 支援：Sprite Atlas 支援 Mipmapping，這能夠提高在遠距離查看紋理時的渲染質量。 平台適配：可以為不同的裝置平台或螢幕解析度創建不同的 Sprite Atlas 變體，保證在各種設備上的最佳效能。 Unity 編輯器整合：你可以直接在 Unity 編輯器中創建與管理 Sprite Atlas，方便遊戲開發者進行資源的視覺化與調整。 使用透明圖片疊加進行設計對齊 將設計圖層疊加一個稍微透明的圖片，這樣可以幫助你更準確地對齊並組織 UI 視圖，使其符合最終設計。 MVVM在 Unity 中實作 MVVM 123456// Modelpublic class GameData{ public int level; public int starts;} 12345678910111213141516// ViewModelpublic class GameViewModel : MonoBehaviour{ private GameData gameData; public int level =&gt; gameData.level; public int starts =&gt; gameData.starts; private void Start() { gameData = new GameData(); } public void UpdateGameData(int level, int score) { gameData.level = level; gameData.starts = score; }} 1234567891011121314// Viewpublic class GameView : MonoBehaviour{ [SerializeField] private GameViewModel gameViewModel; private void Start() { gameViewModel.UpdateGameData(1, 100); } private void Update() { Debug.Log(&quot;Level: &quot; + gameViewModel.level); Debug.Log(&quot;Starts: &quot; + gameViewModel.starts); } }","link":"/2024/11/25/2024-11-25-unity-ugui-performance/"},{"title":"MP3 轉換器","text":"function resizeIframe(iframe) { iframe.height = iframe.contentWindow.document.body.scrollHeight + \"px\"; window.requestAnimationFrame(() => resizeIframe(iframe)); } 參考：https://github.com/ffmpegwasm/ffmpeg.wasm/tree/main","link":"/2025/02/09/2025-02-09-mp3-converter/"},{"title":"Docker 筆記","text":"Docker 筆記，記錄一些在使用上遇到的問題 拉取 Image 時出現 Error: creating build container: short-name &quot;tomcat:9.0.20-jdk8-slim&quot; did not resolve to an alias and no unqualified-search registries are defined in &quot;/etc/containers/registries.conf&quot;因為 Docker Hub 不希望你拉錯 Image ，使用 UNQUALIFIED IMAGE NAMES 時可能會拉到攻擊者的 Image ，所以 Docker Hub 要你明確指定來源 解決方式是 執行 podman pull docker.io/tomcat:9.0.20-jdk8-slim 而不是 podman pull tomcat:9.0.20-jdk8-slim 或是在 /etc/containers/registries.conf 中加上 unqualified-search-registries = [“docker.io”] ， 這樣當你沒有明確指明來源時，會從 Docker Hub 抓。 參考： https://unix.stackexchange.com/questions/701784/podman-no-longer-searches-dockerhub-error-short-name-did-not-resolve-to-an","link":"/2025/02/08/2025-02-08-docker-note/"},{"title":"Shader Graph Node 筆記","text":"Add Node ： 將輸入 A 與 B 相加後輸出。可用在 顏色混合：兩個顏色相加會讓結果更亮，例如 紅色(1,0,0) + 綠色(0,1,0) = 黃色(1,1,0)。 偏移效果：可以為 UV 座標 添加一個數值，實現紋理偏移或滾動效果。 漸變控制：用於疊加額外的數值，如增加光照強度或提高某些參數的基礎值。 Multiply Node ： 將輸入 A 與 B 相乘後輸出。可用在 顏色調整：用 Multiply 乘以一個顏色值可以調整其亮度，例如 (1,1,1) * 0.5 讓顏色變暗。 遮罩（Mask）：如果將一個紋理乘以一個黑白影像（如漸層遮罩），黑色部分（0）會被隱藏，白色部分（1）保持不變。 縮放（Scaling）：可以用 Multiply 來控制值的縮放，例如控制波動強度、光照強度等。 Split Node： 會將輸入向量 In 拆分為四個 Float 輸出 R、G、B 和 A。 這些輸出對應於輸入 In 向量的各個通道： R (紅色通道) G (綠色通道) B (藍色通道) A (Alpha 透明度通道) 如果輸入向量 In 的維度小於 4（即不是 Vector4），則缺少的輸出通道將預設為 0。 生成的程式碼 1234float _Split_R = In[0];float _Split_G = In[1];float _Split_B = 0;float _Split_A = 0; 參考： https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Split-Node.html Transform Node： 用來將輸入從一個座標空間轉換到另一個座標空間。可以用來處理位置 (Position)、方向 (Direction) 或法線 (Normal) 等資料的變換。 位置 (Position) 會受 平移、旋轉、縮放 影響。 方向 (Direction) 只受 旋轉縮放 影響，不會受 平移 影響。 當轉換的不是 Position（位置）時，Unity 建議使用 World 選項，而不要使用 Absolute World，否則可能會產生非預期行為。例如，當轉換方向（Direction）或法線（Normal）時，Camera Relative（相機相對世界） 可能會影響計算結果，因此 World 會更適合。 參考： https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Transform-Node.html 對於計算機圖形學中的應用中，噪聲應該是偽隨機的，也就是說兩次調用應得到同樣的結果。 Gradient Noise (梯度噪聲)： 梯度噪聲產生的紋理具有連續性，因此常用於模擬自然現象（如雲層、山脈、火焰等）。 Perlin 噪聲（Perlin noise，又稱為柏林噪聲）是梯度噪聲的一種。由Ken Perlin開發的自然噪聲生成算法，具有在函數上的連續性，可在多次調用時給出一致的數值。該噪聲可以用來模擬人體的隨機運動，螞蟻行進的線路等。另外，還可以通過計算分形和模擬雲朵，火焰等非常複雜的紋理。 Gradient Noise Node ：梯度噪聲節點，根據輸入 UV 生成梯度噪聲（Gradient Noise）或 Perlin 噪聲（Perlin Noise）。 可調整 Scale 來控制噪聲的大小與細節。 輸入 UV ： 為 Vector2 ， UV 位置作為噪聲的「種子」，可透過偏移、縮放來改變噪聲分佈 UV + 偏移（Offset） → 平移噪聲圖案 UV * 縮放（Scale） → 改變噪聲細節 UV 變形（Distortion） → 產生扭曲效果 Scale ： 為 Float ， 可改變噪聲的細節程度 較大值 → 細節更密集，較小值 → 細節較稀疏輸出 Output ： 為 Float ， 輸出範圍為 0.0 到 1.0 Simple Noise Node ： 根據輸入的 UV 可以產生 簡單 (Simple) 或是 Value 雜訊。 參考： https://huailiang.github.io/blog/2021/noise/ https://en.wikipedia.org/wiki/Value_noise https://blog.csdn.net/Czhenya/article/details/119900293 https://huailiang.github.io/blog/2021/noise/ UV Node ： UV 節點 用來獲取頂點或片段的 UV 坐標。Unity 允許你在網格的數據中處理多個紋理座標集，因此可以透過 Channel 下拉選單來選擇從四組 UV 坐標中擷取資料。大多數網格通常只會使用 UV0，但你也可以利用其他通道來隱藏更多數據。需要注意的是，Shader Graph 有一個限制，就是它只能存取 UV0 到 UV3，而 UV4 到 UV7 則只能在著色器程式碼中訪問。這意味著如果需要更多的 UV 通道，Shader Graph 本身無法直接處理，但你仍然可以在手寫的著色器代碼中處理更高的 UV 通道。 Position Node： 根據此節點所在的 Shader 階段 (Shader Stage)來決定，此節點是存取 網格頂點 (Vertex) 或片段 (Fragment) 的位置 (Position) 。可以使用 Space (空間) 下拉選單來選擇輸出值的座標空間。 Ports 名稱 描述 類型 綁定 描述 Out 輸出 Vector3 無 網格頂點 (Vertex) 或片段 (Fragment) 的位置 (Position) Controls 名稱 類型 選項 描述 Space 下拉選單 Object, View, World, Tangent, Absolute World 為這個 Position 節點的輸出選一個座標空間(coordinate space) World 與 Absolute WorldPosition 節點 提供 World (世界) 和 Absolute World (絕對世界) 兩種座標空間選項： Absolute World (絕對世界座標)： 在所有 Scriptable Render Pipeline (SRP) 中，始終返回物件在場景中的絕對世界位置。 World (世界座標)： 返回所選 SRP 預設的世界座標。 不同渲染管線的 World 預設行為： High Definition Render Pipeline (HDRP) 預設使用 Camera Relative (相機相對) 世界座標。 Universal Render Pipeline (URP) 預設使用 Absolute World (絕對世界座標)。 舊版本 Shader Graph 6.7.0 或更早版本，如果 Position 節點 使用 World 空間，則會自動升級為 Absolute World，以確保計算結果不變。 HDRP 中，如果之前使用 World 空間 手動計算 Camera Relative 世界座標，現在可以直接選擇 World，系統會自動使用相機相對的世界座標。 參考： https://docs.unity3d.com/Packages/com.unity.shadergraph@7.1/manual/Position-Node.html Tiling And Offset Node（平鋪與偏移節點）： Tiling And Offset Node 用於調整紋理（Texture）或 UV 坐標的平鋪（Tiling）和偏移（Offset），允許你在 Shader Graph 中動態改變紋理的大小與位置。 Tiling 輸入是 Vector 2，它控制紋理在物件上複製的次數（即平鋪的數量）。 UV * Tilling Offset 輸入是 Vector 2，它用來在任何方向上移動（滾動）紋理。 UV + Offset UVs 輸入是原始的 UV 座標，平鋪和偏移會應用到這些座標上。 UV 乘以一個數值就是縮放 (Tiling)UV 加減一個值，就是移動 (Offset) 產生的程式碼 1234void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out){ Out = UV * Tiling + Offset;} Absolute Node ： 將 輸入 取絕對值後 輸出。 Power Node ： Power Node 就是次方的意思，當輸入 A 、 B， 輸出為 A的B次方， A^B 1234void Unity_Power_float4(float4 A, float4 B, out float4 Out){ Out = pow(A, B);} Sample Texture 2D ： 有三個輸入： Texture：要取樣的紋理（Texture 2D）。 UV coordinate：紋理的取樣座標，這決定了紋理中哪個位置的顏色將被取樣。 Sampler State：決定如何取樣紋理的採樣器狀態。 這個節點還有兩個額外選項： Type：這個選項決定節點的取樣行為： 當選擇 Default 時，該節點會取樣紋理的顏色（顏色值）。 當選擇 Normal 時，該節點會取樣法線圖（Normal Map），這樣可以獲得法線的資訊來用於光照計算等效果。 Space：這個選項只有在 Normal 模式下有效，決定輸出的法線信息應該處於哪個空間： Object：???。 Tabgent：???。 在 SpriteRenderer 有時候會有 Material does not have a _MainTex texture property. It is required for SpriteRenderer 的警告，這表示 你的 Shader 沒有 _MainTex 屬性。可以這麼理解：在 Shader Graph 中，如果你設定了一個 Texture2D 屬性，並將它的 Reference 設為 _MainTex，那麼，當這個 Shader 被應用到 Sprite Renderer 的 Material 上時，Sprite Renderer 會自動把它的 Sprite 貼圖傳遞給 _MainTex。這樣 Shader 就能正確使用 Sprite 的貼圖，而不需要手動指定 Texture。 Time Node (時間節點) ： 用來提供 時間資訊 Time: 返回自場景(scene)開始以來的時間（以秒為單位）。這個值隨著場景運行而增加。 Sine Time: sin(Time)，產生 -1 到 1 之間的循環值，這個輸出經常用於創建周期性或擺動的效果。 Cosine Time: cos(Time)，效果類似於 Sine Time，但它的波形會有不同的相位（即開始的點不同），通常用於不同的波動模式。 Delta Time: 返回自上一幀以來經過的時間（以秒為單位）。這個值用於幀率無關的動畫或運動計算，確保無論運行速度如何，行為都保持一致。 Smooth Delta: 類似於 Delta Time，但它會對多幀的時間差進行平滑處理，通過平均多個幀的時間差來減少突變，使過渡更加平滑。 當希望物件可以持續的動，或者 Shader 需要依賴時間來運作時，就可以使用 Time 節點，可以嘗試使用 Time 節點 來做 動畫漸變（Gradient）、顏色（Color）、紋理（Texture），以創造獨特的 Shader 效果。 下圖是一個簡單的使用方式，如果你想要產生 0 到 1 之間循環的數值，可以這樣做。 Time 節點 選擇 Sine Time ， 其範圍為 [-1, 1] 。 將 Sine Time 連接到 Add Node ， 把 sin(Time) 加上 1 ， 轉換為 [0,2] 連接上 Divide Node ， 把 Add Node 的輸出 除以 2 ， 轉換為 [0,1] 參考： https://blog.csdn.net/chillxiaohan/article/details/130107677 參考： https://danielilett.com/2021-05-20-every-shader-graph-node/ https://learn.unity.com/tutorial/shadergraph-time-node#5f625e2cedbc2a0020036df9","link":"/2025/02/11/2025-02-11-shader-graph-node/"},{"title":"將資料夾指向到其他位置","text":"如果 Mac 本機的容量不足，但是應用程式卻需要固定路徑才能使用，此時可以使用 symbolic link ，將原來的位置指向到另外一個位置。 以 DiffusionBee 為例，他的資料夾位置是在 ~/.diffusionbee ，我們可以把這個資料夾指向到外部硬碟的位置 使用 mv 指令把 ~/.diffusionbee 移動到外部硬碟位置 mv ~/.diffusionbee '/Volumes/外部硬碟/bee/' 使用 ln -s 將外部硬碟位置連接到 ~/.diffusionbee ln -s /Volumes/外部硬碟/bee/.diffusionbe ~/.diffusionbee 如果需要再次更改，連接到其他硬碟的話，只需要使用 rm 指令刪除原來鏈結，再次建立即可rm ~/.diffusionbeeln -s /Volumes/另一個外部硬碟/bee_new/.diffusionbee ~/.diffusionbee 參考： https://michaelcharl.es/aubrey/en/code/diffusionbee-on-external-storage","link":"/2025/02/08/2025-02-08-%E5%B0%87%E8%B3%87%E6%96%99%E5%A4%BE%E6%8C%87%E5%90%91%E5%88%B0%E5%85%B6%E4%BB%96%E4%BD%8D%E7%BD%AE/"},{"title":"Shader Graph 的空間","text":"Object Space 模型的所有頂點位置都是 相對於該物件的中心點（Pivot Point） 來計算的，而不是世界原點 (0,0,0) World Space 世界空間（World Space） 是所有物件共享的一個全域座標系統，其中所有物件的位置都是相對於 世界原點 (0,0,0) 來計算的。在 Unity Editor 中，當你修改某個 Object Transform 的位置，就是在修改那個 Object 的 World Space。 假設有一個物件 A 在 (3,2,1) 的世界座標，然後它的子物件 B 在 localPosition = (1,1,1)： A.position = (3,2,1)（世界空間） B.localPosition = (1,1,1)（本地空間，相對於 A） B.position = (4,3,2)（世界空間，因為 A 的位置 + B 的本地位置 = 世界位置） 所以，如果你在 Unity 編輯器中修改 B.position，你就是在改變它的 世界空間座標，而 B.localPosition 會自動調整，以維持相對於 A 的關係。 Absolute World Space 與 World Space URP：Universal Render Pipeline（通用渲染管線），較強調效能，適合跨平台。 HDRP：High Definition Render Pipeline（高解析度渲染管線），較強調畫質，適用於 高端 PC、主機遊戲、電影級畫質 在 URP 中，world space 與 absolute world space 是一樣的。 但是在 HDRP 中，他使用 camera relative rendering ， 因此 HDRP 的 world space 是相對於相機的 (camera-relative) ，而他的 absolute world space 則不管相機。 Tangent Space 在 切線空間（Tangent Space） 中，位置和方向是相對於每個頂點及其法線來定義的。 View/Eye Space 在 視圖空間（View/Eye Space） 中，物件的位置是相對於相機及其朝前的方向( forward-facing direction )來描述的。這與 相機相對渲染（Camera-Relative Rendering） 不同，因為視圖空間會考慮相機的旋轉。 Clip space 在 裁剪空間（Clip Space） 中，物件的位置是相對於螢幕（Screen）的。這個空間是在視圖空間經過投影變換（projected）後產生的，其結果取決於相機的視野範圍（Field of View, FOV）和裁剪平面（Clipping Planes）。通常，超出裁剪空間範圍的物體會被裁剪（Clipped），也稱為剔除（Culled），簡單來說就是被刪除，因此這個空間被稱為「裁剪空間」。","link":"/2025/02/12/2025-02-12-shader-graph-space/"},{"title":"圖片與 Base64 轉換 - 線上工具","text":"function resizeIframe(iframe) { iframe.height = iframe.contentWindow.document.body.scrollHeight + \"px\"; window.requestAnimationFrame(() => resizeIframe(iframe)); }","link":"/2025/02/12/2025-02-12-image-to-base64/"},{"title":"在 2D世界中使用粒子系統 (Particle system) 碰撞物體","text":"使用粒子系統 (Particle system) 產生粒子，並讓粒子與其他物件碰撞。可以用來製作粒子推動其他物體的效果， 首先建立一個 GameObject ， 依自己需要取名(這邊取名 WindObject ) 在這個 GameObject 之下建立一個 Particle system (Effects -&gt; Particle system) ，依自己需要取名(這邊取名 WindEffect ) 修改以下模組參數：主要模組中的Duration ： 1 ， 設定粒子系統的持續時間。設為 1 意味著粒子系統的 一次發射周期持續 1 秒。 如果粒子系統是循環播放的（Looping 開啟），它會每 1 秒重置並重新發射粒子。 如果 Looping 關閉，粒子系統只會運行 1 秒後停止。 Start Lifetime ： 0.5 ， 每個粒子的生命週期（以秒為單位）。 設為 0.5 表示每個粒子在生成後僅存活 0.5 秒。當生命週期結束時，粒子將被銷毀。如果 Start Lifetime 設置為隨機範圍，則每個粒子會有不同的存活時間。Start Speed ： 2 ， 粒子生成時的初始速度（以單位/秒為單位）。 設為 2 表示粒子從生成位置以每秒 2 單位的速度移動。Gravity Source ： 2D Physics 。 設為 2D Physics 表示粒子受到 Unity 2D 重力場的影響，會根據 Unity 2D 的 Physics2D.gravity 設定進行模擬。Simulation Space ： World 。 設為 World 表示粒子生成後會與世界空間對齊，並且粒子位置不會受到粒子系統的移動影響。Scaling Mode ： Hierarchy 。 Hierarchy 模式指的是粒子系統會根據其所在的父級物件及其整個層級結構的縮放來影響粒子的大小、速度、壽命等屬性。讓粒子系統可以直接隨父級物件縮放，無需手動調整。Max Particles ： 10 。 粒子系統同一時間允許存在的最大粒子數。設為 10 表示在任何時刻，粒子系統內的粒子數不會超過 10 個。 Emission 模組Rate over Time ： 10 。 每秒生成的粒子數量。設置為 10 意味著粒子系統會在每秒內均勻生成 10 個粒子。 會受到 Max Particles 與 Start Lifetime 限制， 如果 Max Particles 設置為 10，且粒子的存活時間（Start Lifetime）足夠長，那麼粒子系統最多同時顯示 10 個粒子，即便 Rate over Time 想生成更多粒子，也會受到限制。 當 Start Lifetime 為 0.5 時，粒子會在 0.5 秒內消失。因此，即使 Rate over Time 為 10，由於粒子存活時間短，每秒可能只有一半的粒子還存活。 Shape 模組Shape ： Edge 。 粒子會沿著一條 邊線（Edge） 發射，而不是從一個平面或三維體積中生成。Radius ： 0.1 。 當 Shape 設為 Edge 時，Radius 表示該邊線的長度（在視覺上呈現為一小段線段）。 Force over LifetimeX ： -20 。 表示粒子在 X 軸方向 持續受到 -20 的力，造成向左的運動。Y ： -5 。 粒子會向 負 Y 方向 持續加速，模擬下墜或重力效果。Z ： 0 。 表示粒子在 Z 軸方向 不受任何外力影響。Space ： World 。 表示所有的力都基於 世界空間，而非粒子系統的局部空間。 Color over Lifetime 模組Color ： 將後段設為透明，讓粒子發射後逐漸變透明。 Size over Lifetime 模組Size ： 指定粒子的大小如何隨著其生命週期從生成到消亡逐漸改變，將它設為一開始小後面變大的曲線， Collision 模組Type ： World 。 讓粒子會與世界空間中的物理對象（如場景中的碰撞器）發生碰撞，而不是局限於粒子系統本身。Mode ： 2D Render 模組Material ： 用於指定粒子的材質，從而決定粒子的顯示樣式。 需要建立一個 Material ，然後選擇 Sprite-Lit-Default","link":"/2025/01/23/2025-01-23-particle-system-collision/"},{"title":"Shader Graph 筆記大綱","text":"Shader Graph 的 Space：在 Shader Graph 中，Space（空間）是指資料在不同坐標系統中的表示方式。不同的空間決定了資料如何被處理和顯示，對於著色器的效果有著重要的影響。Shader Graph 中常見的空間類型有：Object Space、World Space、View/Camera Space、Tangent Space 和 Clip Space。 Shader Graph Block Nodes：在 Shader Graph 中，Block Nodes（區塊節點）是組成著色器的基本元素。每個區塊節點代表著一個特定的資料處理功能，這些區塊節點可以在 Master Stack 中組合，最終輸出到著色器的結果。這些節點會處理像是頂點、法線、顏色、光照等屬性，並控制著色器的行為。 Shader Graph Properties ： 在 Shader Graph 中，Properties （屬性）是用來設定和控制著色器的外部變量，這些變量可以從 Unity 的材質面板中進行調整，並影響著色器的輸出。這些屬性讓你在不修改 Shader Graph 設定的情況下，動態改變材質的外觀。它們通常用來創建可調整的材質效果，並且可以進行繫結到 Shader Graph 中的不同節點，以控制最終渲染結果。 Shader Graph Nodes ：Shader Graph Nodes 是 Shader Graph 中的組件，每個節點都有特定的功能，並且可以連接到其他節點來實現所需的效果。這些節點提供了創建圖形效果所需的數學計算、變換、顏色處理、貼圖采樣等操作。 Shader Graph 入門 ： 這篇教學使用 Shader Graph 建立了一個簡單的 Shader，讓 Sprite Renderer 在使用 Material 的時候，仍然可以用 Color 影響顏色。","link":"/2025/02/13/2025-02-13-shader-graph-outline/"},{"title":"Shader Graph Block Node 筆記","text":"Block Node 是一種特殊類型的節點，用於 Master Stack 中。每個 Block 代表了 Shader Graph 在最終著色器輸出中使用的單一表面(surface)（或頂點(vertex)）描述資料。 內建的 Block 節點 始終可用， 但特定渲染管線的節點僅在該管線中可用。例如， Universal Block 節點 只在 Universal Render Pipeline（URP） 中可用， 而 High Definition Block 節點 只在 High Definition Render Pipeline（HDRP） 中可用。 某些 Block 只有在特定的 Graph Settings 下才會兼容，並且可能會根據你選擇的圖表設置變為啟用或禁用。 你無法對 Block 進行剪切、複製或粘貼操作。 而某些節點只能在 頂點階段（Vertex Stage） 或 片段階段（Fragment Stage） 使用。 Vertex Stage Blocks在 頂點階段（Vertex Stage），著色器(shader)會對網格 (mesh) 上的每個頂點(vertex)進行處理，並將它們移動到螢幕(screen)上的正確位置。我們可以對頂點進行操作，例如移動它們，或改變光照與它們的互動方式。 Position (Block)： Position（位置）區塊 定義了 網格（Mesh）上每個頂點的位置。 如果不進行修改，頂點的位置將與 建模軟體中的原始位置 相同。 我們可以調整這個 Vector3 來改變頂點的位置，使網格實際發生形變，例如海浪效果。 但要注意，我們無法修改單獨的像素（Pixels）或片段（Fragments）的位置，只能操作頂點（Vertices）。 Normal (Block)： Normal（法線）區塊 定義了 頂點法線(vertex normal points)的方向(direction)。 這個方向對許多 光照計算 來說非常重要，因此修改它可能會影響 物件與光線的互動方式。 與 Position Block 不同，我們可以在 片段階段（Fragment Stage） 透過其他區塊節點來 逐像素（Per-Pixel）修改法線，而不只是修改頂點的法線。 Normal 也是一個 Vector3，用來表示法線的方向。 Tangent (Block) ： Tangent（切線）區塊 可以用來 修改切線向量。 切線向量(Tangent vector) 與 頂點法線（Vertex Normal）垂直(perpendicular)，在平坦的表面上，它通常會沿著物件的表面方向。 如果你更改了頂點法線（Vertex Normal），建議你也調整切線（Tangent），以確保它仍然與法線保持垂直關係。 Tangent 也是一個 Vector3，表示方向。 Fragment Stage Blocks 當 頂點階段（Vertex Stage）完成頂點的變換並確定它們的新位置後，畫面會進行 光柵化（Rasterization），將 3D 資訊轉換成一個片段（Fragment）陣列。 通常，每個片段(Fragment)對應到一個像素（Pixel），但在某些情況下，片段的大小可能會小於像素（例如抗鋸齒技術）。 為了簡化討論，這裡我們將「片段」與「像素」視為相同的概念。片段階段（Fragment Stage） 中的區塊（Block Nodes）會對每個像素進行操作，例如決定顏色、透明度、光照等效果。 Base Color (Block) 在某些版本的 Shader Graph 中，這個屬性被稱為 Albedo（反照率）。Base Color（基礎顏色） 是物件的純顏色，如果忽略所有光照、透明度與其他效果，物件將會顯示這個顏色。 Normal (Tangent/Object/World) (Block) 在頂點階段（Vertex Stage） 有自己的 Normal（法線）區塊。在這個片段階段（Fragment Stage），我們可以存取這個法線資訊，進一步修改每個像素的法線向量，並將修改後的法線傳回 Unity 的內建光照計算系統。 Shader Graph 中有 三種 Normal（法線）區塊，它們的差別在於所使用的座標空間： Tangent Space（切線空間） Object Space（物件空間） World Space（世界空間） 在 Shader 設定中，同一時間只能啟用一種法線空間，你可以在 Graph Settings（圖形設定）中透過 Fragment Normal Space（片段法線空間） 選擇要使用的空間類型。 Emission (Block) 自發光（Emissive）光源 是一種非常適合用來 創建物件周圍的輝光（Bloom）效果 的技術。可以想像像是 霓虹燈、發光火焰 或 魔法咒語 等效果。 Emission（發光）區塊 接受 HDR 顏色（高動態範圍顏色），這讓我們能夠將光源的強度 提高到遠超過一般顏色的範圍，產生更亮、更強烈的光效。 Metallic (Block) Metallic（金屬性）區塊 接受一個 浮點數（float） 值。當數值為 0 時，物體的光照效果會像是 完全非金屬（non-metallic），而當數值為 1 時，物體會呈現 完全金屬(totally metallic)。 這個屬性只有在使用 金屬性工作流（Metallic workflow） 時才會生效。你可以在 Graph Settings（圖形設定） 中，使用 Workflow 選項來選擇使用金屬性工作流還是 鏡面反射工作流（Specular workflow），且只有在材質設定為 Lit（有光照） 時，這個選項才會出現。 Specular (Block) 與 Metallic（金屬性） 區塊不同，Specular（鏡面反射） 區塊接收的是 顏色 作為輸入，因為鏡面反射高光（Specular Highlights）可以有不同的顏色。顏色越亮、越接近白色，鏡面反射的高光就越強。 Smoothness (Block) 物體表面越光滑，光照高光的顯示就越明顯。當 Smoothness（光滑度） 為 0 時，物體表面的光照會顯得粗糙且無光澤；而當 Smoothness 為 1 時，物體表面會像 鏡面一樣光滑，反射出明亮的高光。 Ambient Occlusion (Block)環境遮蔽（Ambient Occlusion，簡稱 AO） 是一種測量像素受到其他場景物體（如牆壁）遮擋，從而減少光源照射的程度。這是一個 浮點數（float） 值，當值為 0 時，該像素應該完全根據照射到它的光源來顯示照明效果；當值為 1 時，光照會被人為減少到最小值。 Alpha (Block)Alpha 是衡量像素透明度的數值，它的範圍從 0 到 1，其中 0 代表完全透明(totally transparent)，而 1 代表完全不透明(fully opaque)。渲染透明物體比渲染不透明物體更消耗計算資源，因此在 Unity 中，我們需要在 Graph Settings 中選擇 Transparent Surface 選項，讓 Unity 正確處理這個著色器。 Alpha Clip Threshold (Block)Alpha 剪裁（Alpha Clipping），當像素的 alpha 值低於特定閾值時，這些像素會被剔除（culling）。我們可以通過在 Graph Settings 中勾選 Alpha Clip 選項來啟用 Alpha Clip Threshold 區塊。這項技術無論是物體表面設置為透明（Transparent）還是完全不透明（Opaque）都可以使用，因此 Alpha 區塊在不透明材質上也不一定是完全無用的！這在模擬透明效果時非常有用，通常會使用不透明渲染，但會根據一定模式剔除像素，從而創造出透明的假象。 參考 https://danielilett.com/2021-05-20-every-shader-graph-node/ https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Block-Node.html","link":"/2025/02/13/2025-02-13-shader-graph-block-node/"},{"title":"Shader Graph Properties","text":"在 Shader Graph 中，Properties（屬性）是用來設定和控制著色器的外部變量，這些變量可以從 Unity 的材質面板中進行調整，並影響著色器的輸出。這些屬性讓你在不修改 Shader Graph 設定的情況下，動態改變材質的外觀。它們通常用來創建可調整的材質效果，並且可以進行繫結到 Shader Graph 中的不同節點，以控制最終渲染結果。 在 Unity 中，屬性有 Name 和 Reference 兩種名稱，其中 Name 這是人類可讀的屬性名稱，會在 Unity Editor 的 Inspector 視窗中顯示，供設計師或開發者查看和修改。 Reference 這是 C# 腳本 中引用該屬性的名稱。在編寫腳本時，會使用這個名稱來取得和設置該屬性的值。 命名規範一般為 Name ： Main Tex Reference ： _MainTex Shader Graph Properties 的種類 Float (浮點數) ： 這是一個單一的數值屬性，用來控制各種數值參數，如金屬度、光滑度、透明度等。 Vector2、Vector3 和 Vector4 ： 這是一個具有多個分量的數值屬性，常見的有 Vector2、Vector3 和 Vector4。 Color (顏色) ： 顏色屬性通常表示為 Vector4，其中四個分量分別對應紅色 (R)、綠色 (G)、藍色 (B) 和透明度（Alpha）。 Boolean (布林)： 用來表示一個開(True)/關(False)狀態，通常是用來控制某些效果的開啟或關閉。 Gradient (漸變)： 用來控制顏色漸變，在 Gradient Window 中添加或移除控制點（handles），來設定漸變中某個位置的顏色（底部標記設定顏色）或透明度（上部標誌設定透明度）。 Texture 2D (2D 紋理) ： 此屬性用來將圖像或紋理資料傳遞給著色器，並可以用來改變物體的外觀。 Texture 2D Array (2D 紋理陣列) ： Texture 2D Array 是一組具有相同大小和格式的 2D 紋理，這些紋理被打包在一起，讓 GPU 可以將它們當作一個單一的紋理來讀取，從而提高效能。 Texture 3D (3D 紋理) ： Texture 3D 類似於 Texture 2D，但它多了一個維度，因此它是一個 3D 顏色數據的區塊。簡單來說，Texture 3D 是一個包含多層紋理的三維紋理，每一層就像是 2D 紋理，但它們在第三個維度中有不同的深度。 Cubemap ： Cubemap 是一種特殊的紋理類型，概念上就像是立方體的網格（網格展開圖）。可以將它理解為六個紋理被拼接在一起，形成一個立方體的外表面。這使得 Cubemap 在處理一些三維效果時非常有用，特別是對於天空盒和反射映射。 Virtual Texture ： 虛擬紋理（Virtual Textures） 可用於減少高解析度紋理的記憶體佔用，這對於使用多個高解析度紋理的情況特別有用。不過，虛擬紋理目前僅在 HDRP（高畫質渲染管線）中受支持。 Matrix (矩陣) ： 這些屬性用來描述坐標轉換，通常是用來處理模型、視圖和投影矩陣。 Matrix 2 ： 2x2 浮點數矩陣，當你創建一個這種類型的屬性時，預設值會是 2x2 單位矩陣（identity matrix），該矩陣的對角線上是 1，其餘位置是 0。 Matrix 3 ： 3x3 浮點數矩陣。 Matrix 4 ： 4x4 浮點數矩陣。 矩陣類型（Matrix 2、Matrix 3 和 Matrix 4）都無法暴露到 Inspector 面板中。 Sampler State ： Sampler State 用來控制如何取樣一個紋理（Texture）。這些屬性可以幫助我們定義紋理在渲染過程中的取樣行為，包括濾鏡（Filter）和包裹模式（Wrap Mode）等。這些設置決定了當紋理的 UV 坐標超過紋理邊界時的行為，以及紋理如何進行平滑處理。 Sampler State 無法暴露到 Inspector 面板中 Filter（濾鏡）：控制紋理的平滑方式，通常用於當紋理縮放時進行處理。 Point：不進行平滑處理，使用最接近的像素顏色，通常稱為最近鄰取樣，適合小尺寸紋理。 Linear：對相鄰的像素進行平滑過渡，這是一種常見的紋理過渡方式，適用於中等解析度的紋理。 Trilinear：除了在像素間進行平滑處理，還會在不同的 mipmap 層級之間進行平滑過渡，這對於大範圍的紋理變換來說更為平滑。 Wrap Mode（包裹模式）：控制當紋理的 UV 坐標超出範圍時的處理方式。 Repeat：紋理會在超出範圍的區域重複顯示，無縫平鋪。 Clamp：UV 坐標會被限制在紋理邊界內，超出範圍的部分會使用紋理的邊緣顏色。 Mirror：類似於 Repeat，但每次穿越邊界時會鏡像反射紋理，會創建一種鏡像效果。 MirrorOnce：與 Mirror 類似，但超出範圍的 UV 坐標會被限制在第一次反射後的區域。 Keyword使用 Keyword 創建不同的 Shader Graph 變體 (variants)，這些特性可以根據需求開啟或關閉，並可以針對不同的平台或條件進行調整。這些變體可以增加 Shader 的複雜度，也能根據設定的條件進行縮放。 在 Keyword 面板中，會有一個 Scope 屬性，選擇 Local 的話，表示是只在該 Shader Graph 私有(private) ， 選擇 Global 則表示在整個專案中所有 Shaders 皆可使用此屬性。 Boolean (Keyword) ： 值為 true 或 false，使用它會導致生成兩個不同的著色器變體（shader variants）。根據定義的不同，這些變體的行為會有所不同。這類關鍵字常用於啟用或禁用某些功能，或根據條件選擇不同的著色器邏輯。 Enum (Keyword) ： Enum 關鍵字類型 允許我們添加一組字符串，這些字符串是該枚舉可以取的值，並可以設置其中一個為預設值。這使得我們能夠根據這個枚舉的值來改變 Shader Graph 的行為。 Material Quality (Keyword) ： 是一個內建的枚舉關鍵字，根據您的項目中的品質設置，自動由 Unity 或特定的渲染管線添加。這個關鍵字基於遊戲的圖形質量設定來調整 Shader Graph 的行為。例如，您可能會選擇在較低的材質品質設置下，使用較低的 LOD（細節層級）來減少渲染負擔，從而提高遊戲的運行效能。 – 參考 https://danielilett.com/2021-05-20-every-shader-graph-node/ https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Keywords.html","link":"/2025/02/13/2025-02-13-shader-graph-properties/"},{"title":"Shader Graph 入門","text":"以下將使用 Shader Graph 建立一個簡單的 Shader ， 這個 Shader 能夠正常接收 Sprite Renderer 的 Sprite，並允許透過 Sprite Renderer 的 Color 來調整顏色。 建立 Shader Graph ： 在 Unity，前往 Assets 資料夾，右鍵點擊 → Create → Shader Graph → Unlit Shader Graph。命名 為 Color Shader Graph。並雙擊打開 Shader Graph 編輯器。 在 Shader Graph 中，我們需要一個 Texture2D 屬性 在左側的面板上，找到 + ， 點擊 + 並選擇 Texture2D，將其命名(Name)為 MainTex。 命名為 MainTex ， 會發現 Reference 變為 _MainTex。這樣當這個 Shader 被應用到 Sprite Renderer 的 Material 上時，Sprite Renderer 會自動把它的 Sprite 貼圖傳遞給 _MainTex。這樣 Shader 就能正確使用 Sprite 的貼圖，而不需要手動指定 Texture。 在 Shader Graph 中，我們需要三個 Node Sample Texture 2D ： 把建立好的 Texture2D 屬性 (_MainTex) 輸入到這個 Sample Texture 2D 節點的 Texture 2D 。 Vertex Color ： 這個節點會讀取 Sprite Renderer 設定的 Color 。 Multiply ： 建立一個 後。 將 Sample Texture 2D 的輸出（RGBA） 連接到 Multiply（A 輸入） 將 Vertex Color 的輸出（RGBA） 連接到 Multiply（B 輸入） 最後將 Multiply 的輸出 連接到 Fragment Output 的 Base Color。 建立一個 Material ， 將他的 Shader 設為在上面的 Shader Graph 。 建立一個 Sprite Renderer ， 指定一個 Sprite ， 並賦予剛剛建立的 Material 調整 Sprite Renderer 中的 Color 看看是否有變更顏色。 可以發現當 Sprite Renderer Color 為白色的時候，呈現的是材質本身的顏色。這就是我們為何使用相乘 (Multiply) 的原因。 為什麼需要建立一個 Vertex Color ？ 這是因為 Sprite Renderer 的 Color 其實是「頂點顏色（Vertex Color）」，Unity 會把它當作一個 Color 傳進 Shader。 如果你的 Shader 沒有讀取 Vertex Color，那麼 Sprite Renderer 改變 Color 也不會影響最終顯示的顏色。 為什麼要用相乘 (Multiply)? 因為 Sprite Renderer 的 Color 本質上是「顏色的縮放因子」，影響材質的最終顏色。 所以，Shader 必須把 Texture 的顏色與 Vertex Color 相乘，這樣才能讓 Color 正確影響結果！ 假設： Texture Color 是 (1, 1, 1, 1)（白色） Vertex Color 是 (1, 0, 0, 1)（紅色） 那麼，最終顏色 = 𝑇𝑒𝑥𝑡𝑢𝑟𝑒𝐶𝑜𝑙𝑜𝑟 × 𝑉𝑒𝑟𝑡𝑒𝑥𝐶𝑜𝑙𝑜𝑟 = (1,1,1,1)×(1,0,0,1)=(1,0,0,1) → 結果變成紅色！ 同理： (0.5, 0.5, 0.5, 1) × (1, 0, 0, 1) = (0.5, 0, 0, 1) → 半透明紅色！ (1, 1, 1, 1) × (1, 1, 1, 1) = (1, 1, 1, 1) → 不變！ (1, 1, 1, 1) × (0.5, 0.5, 0.5, 1) = (0.5, 0.5, 0.5, 1) → 降低亮度！","link":"/2025/02/14/2025-02-14-shader-graph-simple-example/"},{"title":"Java 時間","text":"GMT（Greenwich Mean Time）： GMT 是格林威治標準時間，基於地球自轉，定義為通過倫敦格林威治天文台的子午線（本初子午線）的時間。UTC（Coordinated Universal Time）：UTC 是全球協調時間，基於原子鐘的精確計時，與 GMT 基本一致。在 Java 等程式語言中，通常使用 UTC 作為標準時間，如 Instant.now() 獲取的是 UTC 時間。 台灣的時區是 GMT+8，這表示台灣的時間比格林威治標準時間（GMT）快 8 小時而英國的時區為 GMT+0 ，這意味著英國的時間與 GMT 相同。而這兩個地區的時間差了 8 小時 。 如果在台灣的時間是 2025年2月19日 15:30（GMT+8），那麼同一個時間裡，在英國（GMT+0）看到的時間會是 2025年2月19日 15:30 - 8小時 = 2025年2月19日 07:30 Timestamp（時間戳） 是一個整數，代表著從 UTC 1970 年 1 月 1 日 0 時 0 分 0 秒 起至現在的總秒數。 在 Java 中使用 System.currentTimeMillis() 取得 Timestamp Java 8 以前， 使用 Date ，而 Date 有以下缺陷，不建議使用 是可變的（mutable），是執行緒不安全的 時區 和 Timestamp 混在一起，會因不同的電腦系統導致顯示不同時間。 若要處理時區需借助 SimpleDateFormat 或其他 Library 輔助。 SimpleDateFormat 是執行緒不安全的 日期與時間沒有分開，無法只單獨處理時間或是日期。 你只想要日期的話，在 Date 物件中仍然會有時間的部分，它會顯示為 2025-02-06 00:00:00 Java 8 推出了 java.time 。 無時區的日期時間LocalDate LocalDate 代表日期，只儲存了年、月、日。 是不可變的（immutable） 12345678910LocalDate date = LocalDate.now();System.out.println(date1); // 2025-02-06date = LocalDate.of(2025, 2, 6);// 由於是不可變的，因此透過重新賦值來更改。date = date.plusDays(5); // 增加 5 天System.out.println(date.getYear()); // 2025System.out.println(date.getMonth()); // FEBRUARYSystem.out.println(date.getMonthValue()); // 2System.out.println(date.getDayOfMonth()); // 11 LocalTime 代表時間，只儲存時間，時、分、秒，此外，也儲存奈秒。 是不可變的（immutable） 1234567LocalTime time = LocalTime.now();System.out.println(time); // 15:40:54.204743time = time.minusSeconds(5); // 減少 5 秒System.out.println(time.getHour()); // 15System.out.println(time.getMinute()); // 40System.out.println(time.getSecond()); // 49 LocalDateTime 封裝了 LocalDate 和 LocalTime 代表日期時間 是不可變的（immutable） 1234567891011LocalDateTime dateTime = LocalDateTime.now();System.out.println(dateTime); // 2025-02-19T15:43:26.124154dateTime = dateTime.plusDays(30);System.out.println(dateTime.getYear()); // 2025System.out.println(dateTime.getMonthValue()); // 3System.out.println(dateTime.getDayOfMonth()); // 21System.out.println(dateTime.getHour()); // 15System.out.println(dateTime.getMinute()); // 43System.out.println(dateTime.getSecond()); // 26 DateTimeFormatter 和 SimpleDateFormat 類似，用來進行日期時間物件，與字串之間的互換，但不用處理 ParseException 這個 checked exception。 12345var formatter = DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd HH:mm:ss&quot;);LocalDateTime dateTime = LocalDateTime.parse(&quot;2025/02/06 01:02:03&quot;, formatter);System.out.println(dateTime); // 2025-02-06T01:02:03System.out.println(formatter.format(dateTime)); // 2025/02/06 01:02:03 有時區的日期時間ZonedDateTime 有時區的日期時間 ZoneId 可以使用 ZoneId.getAvailableZoneIds() 取得支援的 key 值。 12345678ZonedDateTime now = ZonedDateTime.now();System.out.println(&quot;Current ZonedDateTime: &quot; + now); // Current ZonedDateTime: 2025-02-19T15:56:36.652708+08:00[Asia/Taipei]ZonedDateTime nowInUTC = ZonedDateTime.now(ZoneId.of(&quot;UTC&quot;));System.out.println(&quot;Current time in UTC: &quot; + nowInUTC); // Current time in UTC: 2025-02-19T07:56:36.652850Z[UTC]ZonedDateTime nowInTaipei = ZonedDateTime.now(ZoneId.of(&quot;Asia/Taipei&quot;));System.out.println(&quot;Current time in Taipei: &quot; + nowInTaipei); // Current time in Taipei: 2025-02-19T15:56:36.652881+08:00[Asia/Taipei] 亦可直接使用偏移量即 UTC/GMT，來定義 ZoneId 123456789101112131415var dateTime = LocalDateTime.now();// 定義東京的 ZoneId (UTC+9)var tokyoZoneId = ZoneId.of(&quot;+0900&quot;);var tokyoDateTime = ZonedDateTime.of(dateTime, tokyoZoneId);// 定義倫敦的 ZoneId (UTC+0)var londonZoneId = ZoneId.of(&quot;+0000&quot;);var londonDateTime = tokyoDateTime.withZoneSameInstant(londonZoneId);// 輸出東京時間System.out.println(tokyoDateTime); // 2025-02-19T16:04:38.833229+09:00// 輸出倫敦時間System.out.println(londonDateTime); // 2025-02-19T07:04:38.833229Z 參考 https://ithelp.ithome.com.tw/m/articles/10322592","link":"/2025/02/19/2025-02-19-java-time/"},{"title":"Spring Console Line App","text":"以下紀錄如何使用 Spring Boot 作為 Console Line AppSpring Boot 的版本是 3.4.2 在 application.properties 中加入 spring.main.web-application-type=NONE ， 告訴 Spring Boot 不啟動 Web 環境 1spring.main.web-application-type=NONE 新增一個實作 CommandLineRunner 的類，並標記上 @Component ，之後你就可以在這個類的 run() 方法中寫你的 Console Line App 邏輯並使用 Spring 的依賴注入了 123456789101112131415161718@Componentpublic class AppCommandLineRunner implements CommandLineRunner { Logger logger = LoggerFactory.getLogger(AppCommandLineRunner.class); @Autowired private SomeService service; @Override public void run(String... args) throws Exception { logger.info(&quot;run the app, args=&quot;+ Arrays.toString(args)); service.do(); } } 如果你每次在執行 Console Line App 時，不想要顯示 Spring banner 的訊息的話，可以在 application.properties 中加入 1spring.main.banner-mode=off","link":"/2025/02/19/2025-02-19-spring-console-line-app/"},{"title":"Mac 使用 ComfyUI","text":"以下紀錄在 Mac 上安裝 ComfyUI 的步驟 安裝 Homebrew /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; https://brew.sh/zh-tw/ 安裝 Python brew install cmake protobuf rust python@3.10 git wget 切換到你想放 ComfyUI 的位置，在執行 git clone git clone https://github.com/comfyanonymous/ComfyUI 切換到下載來 ConfyUI 的位置 cd ComfyUI 執行 Python python3 -m venv venv 執行以下指令安裝 ./venv/bin/pip install torch torchvision torchaudio ./venv/bin/pip install -r requirements.txt 下載模型 可以到 https://civitai.com 找模型下載 https://civitai.com/models/665657/flux1-dev-flux1-schnell-nf4-unet 下載下來的檔案副檔名可能是 .ckpt 或 .safetensors 把下載完畢的模型放到 ComfyUI 中的 /models/checkpoints 的路徑 /ComfyUI/models/checkpoints 啟動 ComfyUI ./venv/bin/python main.py 若想與 AUTOMATIC1111 Stable Diffusion WebUI 一起使用相同的模型的話，可以找到 extra_model_paths.yaml.example 這個檔案，他應該直接在 ComfyUI 的目錄下。將檔案複製一份，並更改檔名為 extra_model_paths.yaml打開後會看到 12a111: base_path: path/to/stable-diffusion-webui/ 把 base_path: 更改為你AUTOMATIC1111 Stable Diffusion WebUI的位置。 12a111: base_path: /Volumes/test/stable-diffusion-webui/ 最後重新啟動 ComfyUI 就可以了。 想更新的話，在資料夾中執行 git pull，然後在執行 ./venv/bin/python main.py 即可","link":"/2025/02/21/2025-02-21-mac-with-comfyui/"},{"title":"Actions","text":"Action是將裝置控制(device control)與輸入(input)分開的一個重要概念。舉例來說，某個遊戲中某些輸入(input)的目的是讓遊戲角色移動，而與該動作(Action)相關的裝置控制(device control)可能是左搖桿。將動作(action)與執行這個輸入的裝置控制(左搖桿)關聯起來的稱作綁定(Binding)。你可以在Action Editor中建立這種綁定，當在程式碼中使用Actons時，你不需要去指定特定的裝置，因為Binding定義了哪些裝置可以執行這個Action。 透過Action Editor你可以為Action建立多個設備的對應，例如下圖，Move對應了鍵盤與遊戲搖桿，之後你就可以在程式碼中取得這個Action的參考，並可以檢查它的值，或是為它附加callback方法 12// 透過InputSystem API可以找到Move，注意不要在Update loop中使用，因為它是基於字串搜尋，因此會影響效能InputAction moveAction = InputSystem.actions.FindAction(&quot;Move&quot;); 注意： Action只可在runtime使用，不可以在Edit Window code中使用。 也可以不使用Action和Binding來直接取得裝置控制的值var gamepad = Gamepad.current;，但是彈性會比較差。 Action Editor 中顯示的動作順序僅供視覺參考，並不代表實際程式碼執行的順序。多個動作可能在同一幀中執行，Input system的動作順序是不確定的。為了避免潛在問題，請勿在程式碼中假設動作會按特定順序執行。 當您在InputSystem中使用Action進行Script編寫時，可以利用以下一些重要的API， API 名稱 描述 InputAction 一個命名Action，它可以回傳與其綁定的裝置控制的值，或是觸發callback。這個API就是Action Editor中Action那一欄的值 InputActionMap 命名的Action集合。這個API持有的集合就是Action Editor中Action Map那一欄的值 InputSystem.actions 是一個專案範圍內動作集合(ProjectWideActions)的引用(reference) InputBinding 動作(Action)與其接收輸入的特定設備控制(device control)之間的關係，ActionBindings Action：每個Action都有一個名稱(InputAction.name)，在一個Action Map中，這個Action的名稱必須是獨一無二的，每個Action也會有一個獨一無二的ID(InputAction.id)，可以用它們來找到這個Action的引用。當ID產生之後，就算名稱改變ID也不會變。 Action Map：每個Action Map都有一個名稱(InputActionMap.name)，這個Action Map的名稱必須是獨一無二的，每個Action Map也會有一個獨一無二的ID(InputActionMap.id)，可以用它們來找到這個Action Map的引用。當ID產生之後，就算名稱改變ID也不會變。 建立Action建立Action有好幾種方式 方法一：使用Action Editor建立Action：最簡單的方式是使用Action Editor建立 方法二：在MonoBehaviours中宣告Action，此方法與方法一類似，差異在於它將Actions定義在GameObject的屬性中，並儲存為Scene或是Prefab。並且它不是project-wide action，因此在使用時需要手動的啟用，停用這些Action。12345678using UnityEngine;using UnityEngine.InputSystem;public class ExampleScript : MonoBehaviour{ public InputAction move; public InputAction jump;} 方法三：在JSON中載入12345// Load a set of action maps from JSON.var maps = InputActionMap.FromJson(json);// Load an entire InputActionAsset from JSON.var asset = InputActionAsset.FromJson(json); 方法四：使用程式碼123456789101112131415161718192021// Create free-standing Actions.var lookAction = new InputAction(&quot;look&quot;, binding: &quot;&lt;Gamepad&gt;/leftStick&quot;);var moveAction = new InputAction(&quot;move&quot;, binding: &quot;&lt;Gamepad&gt;/rightStick&quot;);lookAction.AddBinding(&quot;&lt;Mouse&gt;/delta&quot;);moveAction.AddCompositeBinding(&quot;Dpad&quot;) .With(&quot;Up&quot;, &quot;&lt;Keyboard&gt;/w&quot;) .With(&quot;Down&quot;, &quot;&lt;Keyboard&gt;/s&quot;) .With(&quot;Left&quot;, &quot;&lt;Keyboard&gt;/a&quot;) .With(&quot;Right&quot;, &quot;&lt;Keyboard&gt;/d&quot;);// Create an Action Map with Actions.var map = new InputActionMap(&quot;Gameplay&quot;);var lookAction = map.AddAction(&quot;look&quot;);lookAction.AddBinding(&quot;&lt;Gamepad&gt;/leftStick&quot;);// Create an Action Asset.var asset = ScriptableObject.CreateInstance&lt;InputActionAsset&gt;();var gameplayMap = new InputActionMap(&quot;gameplay&quot;);asset.AddActionMap(gameplayMap);var lookAction = gameplayMap.AddAction(&quot;look&quot;, &quot;&lt;Gamepad&gt;/leftStick&quot;); 對於非專案範圍(project-wide)的Actions，在使用前需要先啟用(Enable) 12345// 啟用單一actionlookAction.Enable();// 啟用整個action map.gameplayActions.Enable(); 當您啟用一個「動作」(Action)時，InputSystem會解析其綁定(bindings)。啟用後，「動作」會積極監控其綁定的「控件」(Control(s))。如果綁定的「控件」狀態改變，「動作」就會處理該變化。如果「控件」的變化代表「交互」(Interaction) 變化，則「動作」會創建一個響應。所有這些都發生在輸入系統的更新邏輯中。取決於輸入設置中選擇的「更新模式」，這可能每幀發生一次，每固定更新一次，或者如果更新設置為手動，則手動發生一次。 在「動作」啟用的情況下，有些配置無法更改，例如「動作綁定」。要停止Action或Action Map響應輸入，可以使用「停用」(Disable)方法。 上一篇：使用Action Editor編輯Action 下一篇：使用Action Reference: https://docs.unity3d.com/Packages/com.unity.inputsystem@1.8/manual/Actions.html","link":"/2024/04/25/Actions/"},{"title":"LTX-Video Test","text":"以下紀錄使用 LTX-Video 的筆記 https://github.com/Lightricks/LTX-Video 首先要將它從 GitHub 拉下來 1git clone https://github.com/Lightricks/LTX-Video.git 切換到他的資料夾下 1cd LTX-Video 建立 Python 虛擬環境 123python -m venv envsource env/bin/activatepython -m pip install -e .\\[inference-script\\] 前往 https://huggingface.co/Lightricks/LTX-Video 下載 Model 使用 文字生成影片 1python inference.py --ckpt_path /Volumes/test/video/ltx-video-2b-v0.9.1.safetensors --prompt &quot;A monkey dance&quot; --height 768 --width 1024 --num_frames 10 --seed 2 使用 圖片生成影片 1python inference.py --ckpt_path /Volumes/test/video/ltx-video-2b-v0.9.1.safetensors --prompt &quot;A monkey dance&quot; --input_image_path /Volumes/test/video/8e5352fc-70b0-41cd-9a9a-704445df7ab0.png --height 768 --width 1024 --num_frames 200 --frame_rate 20 --seed 3","link":"/2025/02/26/2025-02-26-ltxvideo-test/"},{"title":"Command Pattern","text":"命令模式(Command Pattern)：當你想要追蹤一系列特定動作時，可以使用命令模式（command pattern）。如果你玩過帶有撤銷(undo)/重做(redo)功能或是能夠在列表中保留輸入歷史的遊戲，你很可能已經見過命令模式。想像一個策略遊戲，玩家可以在實際執行之前計劃多個動作，這就是命令模式。 在設計模式中，命令模式有以下角色參與其中 Command：抽象命令，可能為一個介面(Interface)或是抽象類(Abstract Class)，例如ICommand ConcreteCommand：具體命令，即實作抽象命令的Class Invoker：命令的調用者，發起者，管理者 Receiver：接收者，實際執行命令者，被Command訪問與操作 使用命令的客戶端(Client) 命令模式特點： 命令模式不直接呼叫方法(method)而是會將單個或多個方法封裝為命令物件(command object)。 命令物件會存放到一個容器(像是Stack或是Queue)中，讓你可以在想要的時間點去執行或是撤銷這些命令物件。 新增命令不會影響其他地方，符合了開閉原則(Open-closed principle) 除了撤銷(undo)/重做(redo)功能，也可以用來實現回放(Play back)功能 接收者(Receiver)類：PlayerMover，在命令物件執行時真正執行動作。 123456789101112131415161718192021222324public class PlayerMover : MonoBehaviour{ [SerializeField] private LayerMask obstacleLayer; private const float boardSpacing = 1f; private PlayerPath playerPath; public PlayerPath PlayerPath =&gt; playerPath; private void Start() { playerPath = gameObject.GetComponent&lt;PlayerPath&gt;(); } public void Move(Vector3 movement) { Vector3 destination = transform.position + movement; transform.position = destination; } public bool IsValidMove(Vector3 movement) { return !Physics.Raycast(transform.position, movement, boardSpacing, obstacleLayer); }} 定義一個抽象命令介面(ICommand) 12345public interface ICommand{ void Execute(); void Undo();} 定義一個具體命令 1234567891011121314151617181920212223public class MoveCommand : ICommand{ private PlayerMover _playerMover; private Vector3 _movement; public MoveCommand(PlayerMover player, Vector3 moveVector) { this._playerMover = player; this._movement = moveVector; } public void Execute() { _playerMover?.PlayerPath.AddToPath(_playerMover.transform.position + _movement); _playerMover.Move(_movement); } public void Undo() { _playerMover.Move(-_movement); _playerMover?.PlayerPath.RemoveFromPath(); }} 定義一個使用命令的命令调用者類CommandInvoker，它只負責執行(ExecuteCommand())和撤銷(UndoCommand())命令。 它含有一個容器(undoStack)，用來儲存一系列的命令。 當執行命令時，從容器中取出一個命令物件執行方法(Execute) 當撤消命令時，從容器中取出一個命令物件，並執行撤銷方法(Undo)1234567891011121314151617181920212223242526272829303132public class CommandInvoker{ private static Stack&lt;ICommand&gt; _undoStack = new Stack&lt;ICommand&gt;(); private static Stack&lt;ICommand&gt; _redoStack = new Stack&lt;ICommand&gt;(); public static void ExecuteCommand(ICommand command) { command.Execute(); _undoStack.Push(command); _redoStack.Clear(); } public static void UndoCommand() { if (_undoStack.Count &gt; 0) { ICommand activeCommand = _undoStack.Pop(); _redoStack.Push(activeCommand); activeCommand.Undo(); } } public static void RedoCommand() { if (_redoStack.Count &gt; 0) { ICommand activeCommand = _redoStack.Pop(); _undoStack.Push(activeCommand); activeCommand.Execute(); } }} 使用命令的客戶端(Client)類，InputManager，它透過CommandInvoker執行命令 123456789101112131415161718192021222324252627282930313233343536373839public class InputManager : MonoBehaviour{ [Header(&quot;Button Controls&quot;)] [SerializeField] Button forwardButton; [SerializeField] Button backButton; [SerializeField] Button leftButton; [SerializeField] Button rightButton; [SerializeField] Button undoButton; [SerializeField] Button redoButton; [SerializeField] private PlayerMover player; private void Start() { forwardButton.onClick.AddListener(OnForwardInput); backButton.onClick.AddListener(OnBackInput); rightButton.onClick.AddListener(OnRightInput); leftButton.onClick.AddListener(OnLeftInput); undoButton.onClick.AddListener(OnUndoInput); redoButton.onClick.AddListener(OnRedoInput); } private void RunPlayerCommand(PlayerMover playerMover, Vector3 movement) { if (playerMover == null) return; if (playerMover.IsValidMove(movement)) { ICommand command = new MoveCommand(playerMover, movement); CommandInvoker.ExecuteCommand(command); } } private void OnLeftInput() { RunPlayerCommand(player, Vector3.left); } private void OnRightInput() { RunPlayerCommand(player, Vector3.right); } private void OnForwardInput() { RunPlayerCommand(player, Vector3.forward); } private void OnBackInput() { RunPlayerCommand(player, Vector3.back); } private void OnUndoInput() { CommandInvoker.UndoCommand(); } private void OnRedoInput() { CommandInvoker.RedoCommand(); }} Reference: https://github.com/Unity-Technologies/game-programming-patterns-demo/tree/main/Assets/9%20Command","link":"/2024/05/25/Command-Pattern/"},{"title":"DELETE與TRUNCATE的區別","text":"DELETE與TRUNCATE的區別 DELETE 是DML語句，可以ROLLBACK， 可以有條件的刪除 如果刪除較大量的資料，DELETE效率較差 TRUNCATE 是DDL語句，立即生效，無法ROLLBACK TRUNCATE將TABLE中的資料全部刪除 如果刪除較大量的資料TRUNCATE效率較好","link":"/2024/02/08/DELETE%E8%88%87TRUNCATE%E7%9A%84%E5%8D%80%E5%88%A5/"},{"title":"碰撞器(Collider)","text":"剛體(Rigidbody)賦予了物件可以接受力，而碰撞器(Collider)則賦予物件碰撞的形狀(edit collider)，以及是否可以會其他物件碰撞，越複雜形狀的碰撞器越耗效能。 參數簡介 Is Trigger：是否是觸發器，如果啟用則該collider將用於觸發事件，並被物理引擎忽略，主要用於進行沒物理效果的碰撞檢測 Material：物理材質，可以確定碰撞體和其他物件碰撞時的交互方式 Center：碰撞體在物件局部中的中心點位置","link":"/2024/04/03/Collider%E7%A2%B0%E6%92%9E%E5%99%A8/"},{"title":"C# 明確方式實作介面","text":"明確方式實作介面(Explicit Interface Implementation)如果一個class去實作兩個有相同方法的interface，會發生什麼事？程式如下，分別有兩個interface IControl 與 IAction都含有Move()方法，其中ExampleClass去實作這兩個Interface。 12345678910111213141516public interface IControl{ void Move();}public interface IAction{ void Move();}public class ExampleClass : IControl, IAction{ // Both IAction.Move and IControl.Move call this method. public void Move() { Console.WriteLine(&quot;Move method in ExampleClass&quot;); }} 執行 12345678910111213ExampleClass example = new ExampleClass();IControl control = example;IAction action = example;// The following lines all call the same method.example.Move();control.Move();action.Move();// Output:// Move method in ExampleClass// Move method in ExampleClass// Move method in ExampleClass 結果是都會呼叫同一個實作。 但是你可能希望個自Interface執行不同的實作，這時就可以使用Explicit Interface Implementation如下： 1234567891011public class ExampleClass2 : IControl, IAction{ void IControl.Move() { System.Console.WriteLine(&quot;IControl.Move&quot;); } void IAction.Move() { System.Console.WriteLine(&quot;IAction.Move&quot;); }} 執行 123456789101112ExampleClass2 example2 = new ExampleClass2();IControl control = example2;IAction action = example2;// The following lines all call the same method.//example2.Move(); // Compiler error.control.Move(); // Calls IControl.Move on ExampleClass2.action.Move(); // Calls IAction.Move on ExampleClass2.// Output:// IControl.Move// ISurface.Move 此時，不可以直接透過實作class的物件去直接呼叫，會出現編譯錯誤，必須要把該物件轉換為對應的interface，例如如果你想呼叫IControl的Move方法，那麼就把它轉換為IControl。 注意：Explicit Interface Implementation是沒有存取修飾詞的，因為它無法當做其定義類型的成員來存取。它只有在透過interface的執行個體呼叫時才能存取。 參考：https://learn.microsoft.com/zh-tw/dotnet/csharp/programming-guide/interfaces/explicit-interface-implementation","link":"/2024/02/05/C-%E6%98%8E%E7%A2%BA%E6%96%B9%E5%BC%8F%E5%AF%A6%E4%BD%9C%E4%BB%8B%E9%9D%A2/"},{"title":"Dependency inversion principle","text":"依賴倒置原則(Dependency inversion principle)有兩個主要部分： 高層模組不應該依賴於低層模組。兩者都應該依賴於抽象。 抽象不應該依賴於具體實現。具體實現應該依賴於抽象。 在軟體設計中，如果一個類(class)使用了另一個類稱為依賴(dependency 或 coupling)，每增加一點依賴，就會增加一些風險，因為當某個類A知道了另一個類B的內容太多的話(稱為高度耦合high degree of coupling)，當B更改的話，那麼A也會需要大量的修改，這樣很容易產生錯誤。 在設計中，有些類是high-level的，而有些類是low-level的，high-level的類會依靠low-level的類去完成某些工作。我們在設計時，要考慮依賴倒置原則，減少一些耦合度。 如果要建立一個遊戲，其中角色可以探索房間，並使用開關(switch)將門(dor)打開，在實作時，你可能會想到要建立一個Switch類與一個Door類，其中 Switch屬於high-level的類，它負責判斷角色是否移動到對應的位置，並是否觸發對應的行為 Door屬於low-level的類，它負責開關門的實際操作邏輯 如果沒有使用依賴倒置原則的話，可能會如下實作 Switch依賴於Door，當條件觸發時，呼叫door去開門1234567891011121314151617181920212223242526272829303132public class Switch{ public Door door; public bool isActivated; public void Toggle() { if (isActivated) { isActivated = false; door.Close(); } else { isActivated = true; door.Open(); } }}public class Door{ public void Open() { Debug.Log(&quot;The door is open.&quot;); } public void Close() { Debug.Log(&quot;The door is closed.&quot;); }} 這樣的實作沒有問題，但是如果開關(Switch)不只是開門，還可能會觸發一些陷阱的話，就不得不去修改Switch類，這樣違反了開閉原則(Open-closed principle) 你可以將開關這個動作抽象=&gt;ISwitchable。 123456public interface ISwitchable{ bool IsActive { get; } void Activate(); void Deactivate();} 讓Door去實作這個抽象ISwitchable 1234567891011121314151617public class Door : MonoBehaviour, ISwitchable{ private bool isActive; public bool IsActive =&gt; isActive; public void Activate() { isActive = true; Debug.Log(&quot;The door is open.&quot;); } public void Deactivate() { isActive = false; Debug.Log(&quot;The door is closed.&quot;); }} 而Switch則依賴這個抽象ISwitchable 12345678910111213141516public class Switch : MonoBehaviour{ public ISwitchable client; public void Toggle() { if (client.IsActive) { client.Deactivate(); } else { client.Activate(); } }} 透過這種方式將上層對底層的依賴剝離至抽象，讓上層可以不需更改程式碼，只需傳入不同的ISwitch實作便可以做到開關不同的物件。","link":"/2024/05/22/Dependency-inversion-principle/"},{"title":"Runtime DataBinding(使用UI Builder)","text":"以下將示範如何使用UI Builder與ScriptableObject來建立DataBinding 在Unity編輯器中，建立一個Script 建立一個名為ExampleObject的ScriptableObject(檔案會是 ExampleObject.cs)，它包含了 一個string vector3Label， 一個Vector3 vector3Value 一個float sumOfVector3Properties，這個sumOfVector3Properties是一個readonly的屬性其值來自於vector3Label中的x，y與z之和， 一個float dangerLevel是一個 0 ~ 1之間的數值。之後在UI Builder中更改使用Value To Progress設定，讓它可以根據ConverterGroup顯示對應的值1234567891011121314151617181920212223242526272829303132333435363738394041using Unity.Properties;using UnityEditor;using UnityEngine;using UnityEngine.UIElements;[CreateAssetMenu]public class ExampleObject : ScriptableObject{ [InitializeOnLoadMethod] public static void RegisterConverters() { // Create local Converters var group = new ConverterGroup(&quot;Value To Progress&quot;); // Converter groups can have multiple converters. This example converts a float to both a color and a string. group.AddConverter((ref float v) =&gt; new StyleColor(Color.Lerp(Color.red, Color.green, v))); group.AddConverter((ref float value) =&gt; { return value switch { &gt;= 0 and &lt; 1.0f / 3.0f =&gt; &quot;Danger&quot;, &gt;= 1.0f / 3.0f and &lt; 2.0f / 3.0f =&gt; &quot;Neutral&quot;, _ =&gt; &quot;Good&quot; }; }); // Register the converter group in InitializeOnLoadMethod to make it accessible from the UI Builder. ConverterGroups.RegisterConverterGroup(group); } [Header(&quot;Bind to multiple properties&quot;)] public string vector3Label; public Vector3 vector3Value; [CreateProperty] public float sumOfVector3Properties =&gt; vector3Value.x + vector3Value.y + vector3Value.z; [Header(&quot;Binding using a converter group&quot;)] [Range(0, 1)] public float dangerLevel;} 在Unity編輯器中，選擇 Create &gt; Example Object ，建立一個Example Object並命名為Object1 (檔案會是 Object1.asset) 建立一個UXML，命名為ExampleObject(檔案會是ExampleObject.uxml) 點擊剛剛建立的ExampleObject.uxml，開啟UI Builder 在Hierarchy panel中，加入一個VisualElement 在剛剛建立的VisualElement中加入Vector3Field，FloatField與Label 最後Hierarchy panel畫面為 選擇最上層的VisualElement UI Element，在右邊找到Data Source，選擇之前建立的Object1.asset，這樣做，會將它的Child Elements都預設綁定Object1 選擇Vector3Field UI Element，在右邊找到Label，對Label按一下滑鼠右鍵，點選Add binding...，在Data Source Path中找到並選擇vector3Label，Binding Mode選擇To Target 接下來，對Vector3Field的Value按一下滑鼠右鍵，點選Add binding...，在Data Source Path中找到並選擇vector3Value，Binding Mode選擇To Target 選擇Float UI Element，在右邊找到Value按一下滑鼠右鍵，點選Add binding...，在Data Source Path中找到並選擇sumOfVector3Properties，Binding Mode選擇To Target 選擇Label UI Element， 在右邊找到Text，對Text按一下滑鼠右鍵，點選Add binding...，在Data Source Path中找到並選擇dangerLevel，Binding Mode選擇To Target 接著打開Advanced Settings 找到 Converters &gt; To target property (UI) 選擇 Value To Progress 接下來，在右邊找到Color，對Color按一下滑鼠右鍵，點選Add binding...，在Data Source Path中勾選Show only compatible之後才會出現可以選擇的相容屬性，選擇dangerLevel，Binding Mode選擇To Target 接著打開Advanced Settings 找到 Converters &gt; To target property (UI) 選擇 Value To Progress 至此，這個UI與 ExampleObject的綁定就算完成了，UXML可能會為123456789101112131415161718192021222324&lt;engine:UXML xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:engine=&quot;UnityEngine.UIElements&quot; xmlns:editor=&quot;UnityEditor.UIElements&quot; noNamespaceSchemaLocation=&quot;../../../UIElementsSchema/UIElements.xsd&quot; editor-extension-mode=&quot;False&quot;&gt; &lt;engine:VisualElement data-source=&quot;project://database/Assets/UI/Custom/Object1.asset?fileID=11400000&amp;amp;guid=a0e72bbf894f04543b805067235fe91c&amp;amp;type=2#Object1&quot; style=&quot;flex-grow: 1;&quot;&gt; &lt;engine:Vector3Field name=&quot;Vector3Field&quot; focusable=&quot;false&quot;&gt; &lt;Bindings&gt; &lt;engine:DataBinding property=&quot;label&quot; binding-mode=&quot;ToTarget&quot; data-source-path=&quot;vector3Label&quot; /&gt; &lt;engine:DataBinding property=&quot;value&quot; binding-mode=&quot;ToTarget&quot; data-source-path=&quot;vector3Value&quot; /&gt; &lt;/Bindings&gt; &lt;/engine:Vector3Field&gt; &lt;engine:FloatField label=&quot;Float Field&quot; name=&quot;FloatField&quot;&gt; &lt;Bindings&gt; &lt;engine:DataBinding property=&quot;value&quot; binding-mode=&quot;ToTarget&quot; data-source-path=&quot;sumOfVector3Properties&quot; /&gt; &lt;engine:DataBinding property=&quot;text&quot; binding-mode=&quot;ToTarget&quot; data-source-path=&quot;dangerLevel&quot; source-to-ui-converters=&quot;Value To Progress&quot; /&gt; &lt;engine:DataBinding property=&quot;text&quot; binding-mode=&quot;ToTarget&quot; data-source-path=&quot;dangerLevel&quot; source-to-ui-converters=&quot;Value To Progress&quot; /&gt; &lt;/Bindings&gt; &lt;/engine:FloatField&gt; &lt;engine:Label text=&quot;Label&quot; name=&quot;Label&quot; enable-rich-text=&quot;false&quot; parse-escape-sequences=&quot;true&quot;&gt; &lt;Bindings&gt; &lt;engine:DataBinding property=&quot;value&quot; binding-mode=&quot;ToTarget&quot; data-source-path=&quot;sumOfVector3Properties&quot; /&gt; &lt;engine:DataBinding property=&quot;text&quot; binding-mode=&quot;ToTarget&quot; data-source-path=&quot;dangerLevel&quot; source-to-ui-converters=&quot;Value To Progress&quot; /&gt; &lt;engine:DataBinding property=&quot;text&quot; binding-mode=&quot;ToTarget&quot; data-source-path=&quot;dangerLevel&quot; source-to-ui-converters=&quot;Value To Progress&quot; /&gt; &lt;/Bindings&gt; &lt;/engine:Label&gt; &lt;/engine:VisualElement&gt;&lt;/engine:UXML&gt; 可以調整Object1來觀察UI的變化 結果 Reference: https://docs.unity3d.com/2023.2/Documentation/Manual/UIE-get-started-runtime-binding.html","link":"/2024/05/07/DataBinding-%E4%BD%BF%E7%94%A8UI-Builder/"},{"title":"分派事件(Dispatch event)","text":"事件分派器(Event Dispacther)UI Toolkit有一個Event System它負責監聽事件，這些事件可能來自OS或是Scripts，當事件發生時，EventDispatcher會使用最適合的分派策略(appropriate dispatching strategy)將事件分派給對應的visual elements。 Visual elements對於一些預設行為以實作多個事件，這些事件在建立，執行時可能會產生一些額外的事件，例如：MouseMoveEvent會連帶產生一個MouseEnterEvent與一個MouseLeaveEvent，這些事件會被放入一個Queue中，當目前的事件處理完之後在依序處理。(MouseMoveEvent處理完之後才處理連帶產生MouseEnterEvent與MouseLeaveEvent) 分派行為(Dispatch Behavior)每種Event類型都有它自己的分派行為(dispatch behavior)，這些行為(behavior)可以被分為三個階段(stage)： Trickles down: 事件會在這個Trickles down階段發送給element Bubbles up: 事件會在這個Bubble-up階段發送給element Cancellable: 事件取消(execution cancelled)，停止(stopped)或是阻止(prevented）自己原先的動作。 事件傳播(Event propagation)事件分派器(event dispatcher)在選好事件目標(event target)之後，就會開始計算這個事件的傳播路徑(propagation path)，傳播路徑是一個list，這個list為會收到該事件的Visual elements組成，且這些Elements是經過排序的。傳播路徑發生的順序： trickle-down phase：路徑從visual element tree的root visual element開始往下延伸(descends)，直到找到事件目標(event target)，這個過程稱為trickle-down phase 事件目標(event target)接收到事件 bubble-up phase：事件沿著tree往上延伸(ascends)直到root element，這個過程稱為bubble-up phase 事件傳播時，會根據不同的type有不同的行為， 例如有些event types會忽略bubble-up phase，有些event types只會發送給event target。 此外，假設有個element被隱藏(hide)或是(停用)disable，那麼這個element就不會收到事件，但是祖先(ancestors)與子孫(descendants)傳播 事件目標(Event Target)事件的目標是根據event type而定，例如滑鼠事件(mouse event)它的目標一般來說都是最上層被點擊的element；而鍵盤事件(keyboard event)它的目標則是有焦點(focus)的element。 Event.target：UI Toolkit的events都有一個target屬性，它持有事件發生element的參考(reference)，此外這個Event.target在分派處理(dispatch process)時是不會改變的。 Event.currentTarget：Event.currentTarget存放目前正在處理event的visual element 滑鼠事件PickingMode：大部分的mouse event會使用picking mode來決定它們的target，VisualElement class有一個pickingMode屬性來做這件事，其中 PickingMode.Position (預設): 根據位置矩形(position rectangle)來挑選 PickingMode.Ignore: 防止被mouse event選到 此外，你可以override VisualElement.ContainsPoint()來自定挑選邏輯 Capture events：在MouseDownEvent之後，一些elements必須捕獲指標位置(pointer position)，以確保它接收到所有後續的滑鼠事件，即使游標不再懸停(hovering over)在該element上。例如，當你點擊button、slider或scroll bar時。 element.CaptureMouse()或是MouseCaptureController.CaptureMouse()可以獲取滑鼠。 MouseCaptureController.ReleaseMouse()會釋放滑鼠。 當某個element持有滑鼠時，另外一個element呼叫CaptureMouse()的話，原先持有滑鼠的element會收一個MouseCaptureOutEvent並失去滑鼠 應用程式中一次只能有一個element捕獲滑鼠。當一個element捕獲了滑鼠時，除了滑鼠滾輪事件(mouse wheel event)之外，它將成為所有後續滑鼠事件的target。(這僅適用於那些尚未設定target且依賴於分派過程來確定targer的滑鼠事件。) Focus Order：每個UI Toolkit panel都會有一個 focus ring，用來決定elements的focus order，預設是使用depth-first search(DFS)來決定 下圖中的focus order為F，B，A，D，C，E，G，I，H 有些events會使用focus order來決定來決定哪些element持有focus，例如鍵盤事件(keyboard event)的目標(target)就是具有焦點(focus)的element focusable屬性決定一個visual element是否為可聚焦的(focusable)。預設中，VisualElement不是focusable的，但它的一些子類(subclass)如TextField預設是focusable。 tabIndex屬性可以控制focus order， 預設tabIndex為零， 如果tabIndex為負數，則無法使用tab鍵來聚焦在該element上。 如果tabIndex為零，則由focus ring algorithm決定。 如果tabIndex為正數，則比該element小的element會先被聚焦，之後才是該element。 Reference：https://docs.unity3d.com/Manual/UIE-Events-Dispatching.html","link":"/2024/04/17/Dispatch-event/"},{"title":"Eclipse 在開啟時卡在Maven build的解決方法","text":"如果開啟Eclipse時，發現會卡住，打不開，而關閉Eclipse時，顯示Maven build的訊息，卡住Eclipse，如圖：以下是處理步驟： 先將Eclipse關閉，如果關不掉，使用強制關閉的方式關閉。 然後移動到程式碼放置的位置，找到.metadata資料夾，把它移走，放到別的地方，（或者是直接刪除） 之後再開啟Eclipse，然後在重新import專案。 這時Eclipse會自動重新建立專案。","link":"/2024/02/08/Eclipse-%E5%9C%A8%E9%96%8B%E5%95%9F%E6%99%82%E5%8D%A1%E5%9C%A8Maven-build%E7%9A%84%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%B3%95/"},{"title":"HTML 編碼解碼小工具","text":"","link":"/2024/02/08/HTML%E7%B7%A8%E7%A2%BC%E8%A7%A3%E7%A2%BC%E5%B0%8F%E5%B7%A5%E5%85%B7/"},{"title":"Hexo添加Sitemap，讓Google能搜尋到自己的Hexo Blog","text":"以下是操作步驟： 安裝Hexo sitemap套件 1$ npm install hexo-generator-sitemap --save 為Hexo加入sitemap設定ˋ找到Hexo專案底下的 _config.yml12sitemap: path: sitemap.xml 測試是否有建立sitemap檔案，在終端機輸入 1$ hexo s 如果成功的話，可以在 /sitemap.xml 找到產生的sitemap 在本機端測試：http://localhost:4000/sitemap.xml 編譯並發布 hexo g -d 提交到Google Search Console 進入 Google Search Console 在網址前置字元那邊輸入Blog的網址，如圖： 在左側找到Sitemap，點擊進入，輸入sitemap.xml，並提交，就完成了。如圖： 如果網站沒有驗證擁有權的話，會需要驗證，可以在Hexo啟用Google analytics，或是使用HTML檔案的方式驗證。 使用HTML檔案的方式驗證的話，要先下載HTML檔案，放到Hexo Blog目錄下，可以參考：Hexo 加入自訂的 HTML頁面","link":"/2024/02/08/Hexo%E6%B7%BB%E5%8A%A0Sitemap/"},{"title":"Hexo 加入自訂的 HTML頁面","text":"有時候想要記錄一些javascript特效或是小工具時，在Hexo會需要自訂自己的HTML頁面，以下是操作步驟 在Hexo專案下面找到 source 資料夾，新建一個要放自訂HTML的資料夾。我這邊是放html/tools/html_encode 在配置檔案_config.yml中，設定跳過渲染 單個檔案12skip_render: - 'html/***.html' 跳過該資料夾下的所有檔案12skip_render: - 'html/*' 跳過該資料夾下所有檔案以及子資料夾12skip_render: - 'html/**' 之後使用指令清除暫存並開始Server 123hexo cleanhexo ghexo s 訪問網址驗證成果，它會以你資料夾的結構去建立URL，例如我的資料夾結構是html/tools/html_encode，因此在訪問時，就是訪問：http://localhost:4000/html/tools/html_encode/index.html 如果想要在原先的blog中加入這個自訂的HTML頁面，並使用Tag的話，推薦使用 iframe 的方式 12&lt;iframe src='/html/tools/html_encode/index.html' scrolling=&quot;no&quot; frameborder=&quot;0&quot; width='100%' height='800px' style='margin-top:12px'&gt;&lt;/iframe&gt; 結果如下：","link":"/2024/02/08/Hexo-%E5%8A%A0%E5%85%A5%E8%87%AA%E8%A8%82%E7%9A%84-HTML%E9%A0%81%E9%9D%A2/"},{"title":"Input System大綱","text":"Input System是Unity較新的輸入系統，目前版本為1.8 官方文件：https://docs.unity3d.com/Packages/com.unity.inputsystem@1.8/manual/ Input System基本概念 安裝Input System 將Action設為整個專案可用(Project-Wide Actions) 使用Action Editor編輯Action Actions概念 使用Action","link":"/2024/04/25/Input-System-outline/"},{"title":"安裝Input System","text":"Input System需要Unity 2019.4或更高版本以及.NET 4 runtime。 安裝Input System package 在編輯器中，找到 Window &gt; Package Manager 打開 Package Manager 更改為Unity Registry，並搜尋 Input System 安裝Input System 選擇是否在後端啟用Input System。Unity預設啟用的是InputManager(UnityEngine.Input)，在安裝Input System時會詢問你是否要啟用Input System，選擇Yes，這會讓編輯器重開。 此外你也可以在Edit &gt; Project Settings &gt; Player 中找到 Active Input Handling來更改 在C# script中，當Input System在後端被啟用時，C# #define 會加入一個ENABLE_INPUT_SYSTEM=1的定義；當原先的Input Manager在後端被啟用時，C# #define會加入一個ENABLE_LEGACY_INPUT_MANAGER=1，如果是同時啟用則ENABLE_INPUT_SYSTEM與ENABLE_LEGACY_INPUT_MANAGER皆會設為1。 上一篇：Input System基本概念 下一篇：將Action設為整個專案可用(Project-Wide Actions) Reference: https://docs.unity3d.com/Packages/com.unity.inputsystem@1.8/manual/ActionsEditor.html","link":"/2024/04/23/Input-System/"},{"title":"Eclipse常用快速鍵","text":"以下是Eclipse常用快速鍵(shortcuts) 格式化程式碼(auto-format code)： Windows 或是 Linux : Ctrl + Shift + f Mac : ⇧ + ⌘ + f 轉為大寫(Upper case) Windows 或是 Linux : Ctrl + Shift + x Mac : ⌘ + ⇧ + x 轉為小寫(Lower case) Windows 或是 Linux : Ctrl + Shift + y Mac : ⌘ + ⇧ + y Reference: https://www.shortcutfoo.com/app/dojos/eclipse-mac/cheatsheet","link":"/2024/05/06/Eclipse%E5%B8%B8%E7%94%A8%E5%BF%AB%E9%80%9F%E9%8D%B5/"},{"title":"Input System基本概念","text":"Input System 讓使用者可以透過設備(device)，觸控(touch)或手勢(gestures)控制你的App。若有跨平台開發的需求，或希望提供使用者可自行設定輸入的選項，可考慮使用 Input System。目前Input System是Unity較新的輸入系統，需要透過Project Manager去安裝。 概念 描述 User 就是使用你App的使用者，透過輸入裝置或觸控裝置提供輸入 Input Device 在輸入的環境(context of input)中，指的是實體裝置，例如：鍵盤(keyboard)，遊戲手把(gamepad),滑鼠(mouse)或是觸控螢幕等(touchscreen) Control 指的是輸入裝置的個別部件，各自會將自己的值發送到Unity中。例如：遊戲手把(gamepad)的control包含了多個按鈕(buttons)，搖桿(sticks)，板機(triggers)等；滑鼠的control包含了在底部的兩個X與Y感應器(sensors)與在上面的各種按鈕與滑鼠滾輪等。 Action Action是一個高層次的概念，用來描述在你的App中使用者可能想做的輸入動作，例如：在遊戲中跳躍(Jump)，在畫面上選擇(Select)，也就是說是使用者可以在你App中做出的輸入動作。Action一般會有一個概念名稱，你可以依據你專案使用合適的Action名稱，通常是一個動詞(verbs)，例如Run，Jump，Crouch， Use，Start，Quit Action Map Action Maps讓你可以將Action組織起來，你可以同時啟用或停用在一個Action Map中的action，對組織相關的Action非常有用，例如你可能會想要一個Action Map在裡面Action都與控制玩家相關，而另外一個都與UI互動相關。 Binding 一種將Action與特定控制裝置(specific device control)之間綁定的概念。例如：Move可能會與鍵盤上的WSAD與方向鍵(arrow keys)綁定，或者是遊戲手把(joypad)上的左側搖桿(left stick)綁定，以及VR控制器上的主要2D軸綁定。可以多個綁定，表示你的App可以接受框平台的輸入 Your Action Code 根據Action設定去操作的腳本(script)。在程式碼中，你可以透過Action的參考(reference)來讀取目前action的值或是狀態(此也稱為polling)，也可以設定callback來為這些action添加自己的方法 ActionAsset 是一個儲存了Action Maps與Bindings設定的asset type，你可以在專案中指定一個Action Asset為專案範圍的動作(project-wide actions) 讓你可以透過這樣可以通過使用InputSystem.actions在程式碼中輕鬆參考這些動作 下一篇：安裝Input System Reference: https://docs.unity3d.com/Packages/com.unity.inputsystem@1.8/manual/index.htmlhttps://docs.unity3d.com/Packages/com.unity.inputsystem@1.8/manual/Concepts.html","link":"/2024/04/23/Input-System%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"title":"Interface segregation principle","text":"介面隔離原則(Interface segregation principle)：不應該讓一個類(class)為了實作某個介面(interface)而去讓這個類實作用不到的方法，簡單的說就是要避免一個大型的介面(interface)。最簡單的思考方向是使用單一職責(singleresponsibility principle)去考慮，讓每個介面保持單一並簡單。 假設要製作一個策略遊戲，這個遊戲有多個角色單位，每個單位會有血量，速度，等狀態，可能會想將這些單位的狀態抽象為一個介面，如下： 1234567891011121314151617public interface IUnitStats{ float Health { get; set; } int Defense { get; set; } void Die(); void TakeDamage(); void RestoreHealth(); float MoveSpeed { get; set; } float Acceleration { get; set; } void GoForward(); void Reverse(); void TurnLeft(); void TurnRight(); int Strength { get; set; } int Dexterity { get; set; } int Endurance { get; set; }} 但是在遊戲中，有會有一些不可移動但是可以破壞的物件，這些物件也會需要生命值(Health)，但是不需要移動相關的方法(如GoForward)，因此這個介面太臃腫了。 可以考慮將這些行為切割為較小的介面，每個介面負責專一的職責 1234567891011121314151617181920212223public interface IMovable{ float MoveSpeed { get; set; } float Acceleration { get; set; } void GoForward(); void Reverse(); void TurnLeft(); void TurnRight();}public interface IDamageable{ float Health { get; set; } int Defense { get; set; } void Die(); void TakeDamage(); void RestoreHealth();}public interface IUnitStats{ int Strength { get; set; } int Dexterity { get; set; } int Endurance { get; set; }} 在實作時，敵人單位會移動，有狀態，並且是可損壞的 123456789101112131415161718public class EnemyUnit : MonoBehaviour, IDamageable, IMovable, IUnitStats{ public float Health { get; set; } public int Defense { get; set; } public float MoveSpeed { get; set; } public float Acceleration { get; set; } public int Strength { get; set; } public int Dexterity { get; set; } public int Endurance { get; set; } public void Die() { ... } public void TakeDamage() { ... } public void RestoreHealth() { ... } public void GoForward() { ... } public void Reverse() { ... } public void TurnLeft() { ... } public void TurnRight() { ... }} 箱子只能被損壞 123456789public class Box : MonoBehaviour, IDamageable{ public float Health { get; set; } public int Defense { get; set; } public void Die() { ... } public void TakeDamage() { ... } public void RestoreHealth() { ... }} 這樣，每個類只需要實作其所需的介面，避免了因為實作不必要的方法而增加的複雜性。","link":"/2024/05/22/Interface-segregation-principle/"},{"title":"Factory pattern","text":"工廠模式(Factory pattern)：讓一個特別的物件(工廠Factory)去建立其他物件(產品Product)。它封裝了生成其他物件(產品Product)的邏輯，最直接可見的好處是整理了你的程式碼。工廠物件可以有多種子類(subclass)，用來產生多種不同的產品。 優點 使用工廠模式的好處是當你增加產品時，你不需要修改先前的程式碼就可以增加產品 缺點 增加程式碼的複雜度 建立一個IProduct介面，訂立產品必須要有的規則 每個產品一定要有自己的名字(ProductName) 每個產品有初始化自己的方式(Initialize()) 產品種類比較不會有共用的邏輯，因此將其設計為介面12345public interface IProduct{ public string ProductName { get; set; } public void Initialize();} 以下建立一個抽象工廠，抽象工廠用來規定工廠必須要有的動作 每個工廠必須要能在對應的位置(Vector3 position)上生產產品(GetProduct())123456public abstract class Factory : MonoBehaviour{ public abstract IProduct GetProduct(Vector3 position); // shared method with all factories …} 建立一個產品A 它含有一個ParticleSystem，並在初始化方法(Initialize)中會播放此ParticleSystem1234567891011121314public class ProductA : MonoBehaviour, IProduct{ [SerializeField] private string productName = &quot;ProductA&quot;; public string ProductName { get =&gt; productName; set =&gt; productName = value ; } private ParticleSystem particleSystem; public void Initialize() { // any unique logic to this product gameObject.name = productName; particleSystem = GetComponentInChildren&lt;ParticleSystem&gt;(); particleSystem?.Stop(); particleSystem?.Play(); }} 建立一個工廠A 它含有一個產品A的依賴，在GetProduct()方法中建立產品A實體之後，會呼叫產品A實體上的Initialize()方法用來初始化該實體。12345678910111213public class ConcreteFactoryA : Factory{ [SerializeField] private ProductA productPrefab; public override IProduct GetProduct(Vector3 position) { // 使用Prefab在指定的position上建立一個instance GameObject instance = Instantiate(productPrefab.gameObject, position, Quaternion.identity); ProductA newProduct = instance.GetComponent&lt;ProductA&gt;(); // 初始化產品A newProduct.Initialize(); return newProduct; }} 建立一個產品B 它含有一個AudioSource，在初始化方法(Initialize)中會播放此AudioSource12345678910111213141516public class ProductB : MonoBehaviour, IProduct{ [SerializeField] private string productName = &quot;ProductB&quot;; public string ProductName { get =&gt; productName; set =&gt; productName = value; } private AudioSource audioSource; public void Initialize() { // do some logic here audioSource = GetComponent&lt;AudioSource&gt;(); audioSource?.Stop(); audioSource?.Play(); }} 建立一個工廠B 工廠B與工廠A類似，不過依賴換為產品B123456789101112131415161718192021public class ConcreteFactoryB : Factory{ // used to create a Prefab [SerializeField] private ProductB productPrefab; public override IProduct GetProduct(Vector3 position) { // create a Prefab instance and get the product component GameObject instance = Instantiate(productPrefab.gameObject, position, Quaternion.identity); ProductB newProduct = instance.GetComponent&lt;ProductB&gt;(); // each product contains its own logic newProduct.Initialize(); // add any unique behavior to this factory instance.name = newProduct.ProductName; Debug.Log(GetLog(newProduct)); return newProduct; }} 建立一個使用工廠的類 ClickToCreate這個類使用了工廠A與工廠B，1234567891011121314151617181920212223242526272829303132public class ClickToCreate : MonoBehaviour{ [SerializeField] private LayerMask layerToClick; [SerializeField] private Vector3 offset; [SerializeField] Factory[] factories; private Factory factory; private void Update() { GetProductAtClick(); } private void GetProductAtClick() { // check click with raycast if (Input.GetMouseButtonDown(0)) { // choose a random factory factory = factories[Random.Range(0, factories.Length)]; // instantiate product at raycast intersection Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hitInfo; if (Physics.Raycast(ray, out hitInfo, Mathf.Infinity, layerToClick) &amp;&amp; factory != null) { factory.GetProduct(hitInfo.point + offset); } } }}","link":"/2024/05/23/Factory-pattern/"},{"title":"JSON Pretty","text":"function resizeIframe(iframe) { iframe.height = iframe.contentWindow.document.body.scrollHeight + \"px\"; window.requestAnimationFrame(() => resizeIframe(iframe)); } Reference： https://github.com/pgrabovets/json-view https://stackoverflow.com/questions/4810841/pretty-print-json-using-javascript","link":"/2024/04/17/JSON-pretty/"},{"title":"Flexbox Layout","text":"UI Toolkit使用一個開源的Layout Engine： Yoga，Yoga是一個實作了Flexbox layout的HTML/CSS Layout system。 預設所有Visual Elements都是layout的一部份，在Layout中預設有以下行為 Container會將它的Children做垂直(vertically)分佈 Container矩形(rectangle)的位置包括其children rectangles 在計算尺寸(size calculation)時，若這個visual element有Text的話，會以這個Text的大小來計算 Flexbox基本 Flex Item：在Flexbox中會有一個含有多個元素的Container稱為Flex Container，在這個Flex Container中的element稱為Flex Item Flexbox的layout使用flex-flow directions的方式來做佈局，也就是說裡面的items會根據一個軸來從開頭到結尾做排列，如main axis的話從main-start到main-end排列；或cross axis的話從cross-start到cross-end排列。 Main axis：由main-start到main-end的方向。 預設是由左到右的方向與大部分語言文字方向相同的方向 注意：Main axis不一定是由左到右的方向，它會根據flex-direction改變。 Cross axis：由cross-start到cross-end的方向，也就是換行方向，如果Flex Item單行的數量多到超過Flex Container，需要換行時，預設會換到下一行的方向。 預設是由上到下 Flex direction：設定main axis的方向，有以下方向可以設置 row (預設): 在LRT佈局中是從左到右;在RTL佈局中是從右到左 row-reverse: 與row相反，在LRT佈局中是從右到左;在RTL佈局中是從左到右 column: 方向是從上到下 column-reverse: 與column相反，從下到上 以下是flex-direction為row的範例12345678910111213141516171819&lt;style&gt; .container { display: flex; flex-direction: row; background-color: yellow; } .item{ margin: 10px; width: 60px; height: 60px; background-color: blue; color: white; }&lt;/style&gt;&lt;div class=&quot;container1&quot;&gt; &lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;item2&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;item3&lt;/div&gt;&lt;/div&gt; .container1 { display: flex; flex-direction: row; background-color: yellow; } .item{ margin: 10px; width: 60px; height: 60px; background-color: blue; color: white; } item1 item2 item3 flex-wrap：設定Flex是否換行，預設會讓flex items保持在一行。 nowrap：所有flex items保持在一行 wrap：當flex items多到容不下時，會換到下一行，方向是從上到下 wrap-reverse：wrap的相反，當flex items多到容不下時，會換到上一行，方向是從下到上 以下是flex-wrap的的範例 .container2-1, .container2-2, .container2-3 { display: flex; flex-direction: row; background-color: yellow; } .red { background: red; } .green { background: green; } .blue { background: blue; } .container2-1 { width:200px; flex-wrap: nowrap; } .container2-2 { width:200px; flex-wrap: wrap; } .container2-3 { width:200px; flex-wrap: wrap-reverse; } nowrap 1234567891011121314&lt;style&gt;.container2-1 { display: flex; flex-direction: row; background-color: yellow; width:200px; flex-wrap: nowrap;}&lt;/style&gt;&lt;div class=&quot;container2-1&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 wrap 1234567891011121314&lt;style&gt;.container2-2 { display: flex; flex-direction: row; background-color: yellow; width:200px; flex-wrap: wrap;}&lt;/style&gt;&lt;div class=&quot;container2-2&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 wrap-reverse 1234567891011121314&lt;style&gt;.container2-3 { display: flex; flex-direction: row; background-color: yellow; width:200px; flex-wrap: wrap-reverse;}&lt;/style&gt;&lt;div class=&quot;container2-3&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 justify-content：定義Flex Items在Flex Container在main axis上空間分配的方式 flex-start：Items以flex-direction的開始爲方向排列。 flex-end：Items以flex-direction的尾部為方向排列。 center：Items在中心排列 space-between：Items在main axis上平均排列，但首尾Items貼邊。 space-around：Items在main axis上平均排列，Items之間使用相同的空間 以下是Justify Content的例子 .container3-1, .container3-2, .container3-3, .container3-4, .container3-5 { display: flex; flex-direction: row; background-color: yellow; } .container3-1 { justify-content: flex-start; } .container3-2 { justify-content: flex-end; } .container3-3 { justify-content: center; } .container3-4 { justify-content: space-between; } .container3-5 { justify-content: space-around; } flex-start 12345678910111213&lt;style&gt;.container3-1 { display: flex; flex-direction: row; background-color: yellow; justify-content: flex-start;}&lt;/style&gt;&lt;div class=&quot;container3-1&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 flex-end 12345678910111213&lt;style&gt;.container3-2 { display: flex; flex-direction: row; background-color: yellow; justify-content: flex-end;}&lt;/style&gt;&lt;div class=&quot;container3-2&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 center 1234567891011.container3-3 { display: flex; flex-direction: row; background-color: yellow; justify-content: center;}&lt;div class=&quot;container3-3&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 space-between 1234567891011.container3-4 { display: flex; flex-direction: row; background-color: yellow; justify-content: space-between;}&lt;div class=&quot;container3-4&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 space-around 12345678910111213&lt;style&gt;.container3-5 { display: flex; flex-direction: row; background-color: yellow; justify-content: space-around;}&lt;/style&gt;&lt;div class=&quot;container3-5&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 align-items：設定Flex Items對cross axis方向的排列方式 flex-start：Items會從cross axis的開始位置對齊 flex-end：Items會從cross axis的尾端位置對齊 stretch：當Items沒有設定高度時，Items會被拉伸填滿Container，(遵守最小寬度(min-width)/最大寬度(max-width)） center：Items會從cross axis的中心位置對齊 以下是align-items的例子 .container4-1, .container4-2, .container4-3, .container4-4 { display: flex; flex-direction: row; background-color: yellow; height: 200px; } .container4-1 { align-items: flex-start; } .container4-2 { align-items: flex-end; } .container4-3 { align-items: stretch; } .container4-4 { align-items: center; } flex-start 1234567891011121314&lt;style&gt;.container4-1 { display: flex; flex-direction: row; background-color: yellow; height: 200px; align-items: flex-start;}&lt;/style&gt;&lt;div class=&quot;container4-1&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 flex-end 1234567891011121314&lt;style&gt;.container4-2 { display: flex; flex-direction: row; background-color: yellow; height: 200px; align-items: flex-end;}&lt;/style&gt;&lt;div class=&quot;container4-2&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 stretch 1234567891011121314&lt;style&gt;.container4-3 { display: flex; flex-direction: row; background-color: yellow; height: 200px; align-items: stretch;}&lt;/style&gt;&lt;div class=&quot;container4-3&quot;&gt; &lt;div style=&quot;background-color:coral;min-height:30px;width:60px;&quot;&gt;1&lt;/div&gt; &lt;div style=&quot;background-color:lightblue;min-height:50px;width:60px;&quot;&gt;2&lt;/div&gt; &lt;div style=&quot;background-color:lightgreen;min-height:190px;width:60px;&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 center 1234567891011121314&lt;style&gt;.container4-4 { display: flex; flex-direction: row; background-color: yellow; height: 200px; align-items: center;}&lt;div class=&quot;container4-4&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt;&lt;/style&gt; 1 2 3 align-self：與align-items類似，但是只會應用到該Item上 flex-start：Item會從cross axis的開始位置對齊 flex-end：Item會從cross axis的尾端位置對齊 stretch：Item會被拉伸填滿Container，(遵守最小寬度(min-width)/最大寬度(min-width)） center：Item會從cross axis的中心位置對齊 flex-grow：設定item在容器中佔多少空間，或是分到多少剩餘空間。 以下舉例，容器的width為600px，紅色Item1的width為60px，綠色Item2的width為90px，藍色Item3的width為60px： .container5 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white; } 沒有設定 flex-grow 1234567891011121314&lt;style&gt;.container5 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white;}&lt;/style&gt;&lt;div class=&quot;container5&quot;&gt; &lt;div class=&quot;red&quot; style=&quot;width:60px;&quot;&gt;1(60)&lt;/div&gt; &lt;div class=&quot;green&quot; style=&quot;width:90px;&quot;&gt;2(90)&lt;/div&gt; &lt;div class=&quot;blue&quot; style=&quot;width:60px;&quot;&gt;3(60)&lt;/div&gt;&lt;/div&gt; 1(60) 2(90) 3(60) 紅色Item的flex-grow:1， 剩餘的空間為600-60-90-60=390，這會把剩餘的空間(390)全部分紅色Item 1234567891011121314&lt;style&gt;.container5 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white;}&lt;/style&gt;&lt;div class=&quot;container5&quot;&gt; &lt;div class=&quot;red item-a-5-1&quot; style=&quot;width:60px;&quot;&gt;1(60px+390px)&lt;/div&gt; &lt;div class=&quot;green&quot; style=&quot;width:90px;&quot;&gt;2(90px)&lt;/div&gt; &lt;div class=&quot;blue&quot; style=&quot;width:60px;&quot;&gt;3(60px)&lt;/div&gt;&lt;/div&gt; 1(60px+390px) 2(90px) 3(60px) 紅色Item的flex-grow:1， 綠色Item的flex-grow:2， 他們兩個會按比例分配剩餘空間390/3=130，紅色Item分配到130*1，綠色Item分到130*2 1234567891011121314&lt;style&gt;.container5 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white;}&lt;/style&gt;&lt;div class=&quot;container5&quot;&gt; &lt;div class=&quot;red item-a-5-1&quot; style=&quot;width:60px;&quot;&gt;1(60+130*1)&lt;/div&gt; &lt;div class=&quot;green item-a-5-2&quot; style=&quot;width:90px;&quot;&gt;2(90+130*2)&lt;/div&gt; &lt;div class=&quot;blue&quot; style=&quot;width:60px;&quot;&gt;3(60)&lt;/div&gt;&lt;/div&gt; 1(60+130*1) 2(90+130*2) 3(60) flex-grow的數值也可以是小數， 紅色Item的flex-grow:0.4， 綠色Item的flex-grow:0.6， 他們兩個按比例分配剩餘空間，紅色Item分配到390*0.4，綠色Item分到390*0.6 1234567891011121314&lt;style&gt;.container5 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white;}&lt;/style&gt;&lt;div class=&quot;container5&quot;&gt; &lt;div class=&quot;red&quot; style=&quot;width:60px; flex-grow:0.4;&quot;&gt;1(60+390*0.4)&lt;/div&gt; &lt;div class=&quot;green&quot; style=&quot;width:90px; flex-grow:0.6;&quot;&gt;2(90+390*0.6)&lt;/div&gt; &lt;div class=&quot;blue&quot; style=&quot;width:60px;&quot;&gt;3(60)&lt;/div&gt;&lt;/div&gt; 1(60+390*0.4) 2(90+390*0.6) 3(60) flex-shrink：在容器空間不足時，控制Item如何收縮 此方式計算較複雜，除了flex-shrink設定比例，還需要根據容器中Item超出多少寬度，以及Item它本身的寬度來計算出各個Item收縮的比例。 每個Item收縮的權重為其flex-shrink*寬度。 如果不希望被自動壓縮到，可以設定為0 以下舉例，容器的width為600px，紅色Item1的width為300px，綠色Item2的width為300px，藍色Item3的width為300px，紅色Item的flex-shrink:1，綠色Item的flex-shrink:1，藍色Item的flex-shrink:2 .container6 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white; } 計算超出多少寬度：600(容器) - 300(紅色) - 300(綠色) - 300(藍色) = 300 (超出300) 每個Item收縮的權重為其flex-shrink * 寬度：1*300 + 1*300 + 2*300 = 1200 每個Item要收縮的寬度為： 紅色：300(超出的寬度) * 1 (flex-shrink) * 300(Item的寬度) / 1200(權重) = 75 綠色：300(超出的寬度) * 1 (flex-shrink) * 300(Item的寬度) / 1200(權重) = 75 藍色：300(超出的寬度) * 2 (flex-shrink) * 300(Item的寬度) / 1200(權重) = 150 因此三個元素最終的寬度為： 紅色：300 - 75 = 225 綠色：300 - 75 = 225 藍色：300 - 150 = 150 1234567891011121314&lt;style&gt;.container6 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white;}&lt;/style&gt;&lt;div class=&quot;container6&quot;&gt; &lt;div class=&quot;red&quot; style=&quot;width:300px; flex-shrink:1;&quot;&gt;225&lt;/div&gt; &lt;div class=&quot;green&quot; style=&quot;width:300px; flex-shrink:1;&quot;&gt;225&lt;/div&gt; &lt;div class=&quot;blue&quot; style=&quot;width:300px; flex-shrink:2;&quot;&gt;150&lt;/div&gt;&lt;/div&gt; 225 225 150 再看另外一個例子：容器的width為600px，紅色Item的width為150px，綠色Item的width為300px，藍色Item的width為300px，紅色Item的flex-shrink:0，綠色Item的flex-shrink:2，藍色Item的flex-shrink:3 計算超出多少寬度：600(容器) - 150(紅色) - 300(綠色) - 300(藍色) = 150 (超出150) 每個Item收縮的權重為其flex-shrink * 寬度：0*150 + 2*300 + 3*300 = 1500 每個Item要收縮的寬度為： 紅色：150(超出的寬度) * 0 (flex-shrink) * 150(Item的寬度) / 1500(權重) = 0 綠色：150(超出的寬度) * 2 (flex-shrink) * 300(Item的寬度) / 1500(權重) = 60 藍色：150(超出的寬度) * 3 (flex-shrink) * 300(Item的寬度) / 1500(權重) = 90 因此三個元素最終的寬度為： 紅色：150 - 0 = 150 綠色：300 - 60 = 240 藍色：300 - 90 = 210 1234567891011121314&lt;style&gt;.container6 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white;}&lt;/style&gt;&lt;div class=&quot;container6 width:600px&quot;&gt; &lt;div class=&quot;red&quot; style=&quot;width:150px; flex-shrink:0;&quot;&gt;150&lt;/div&gt; &lt;div class=&quot;green&quot; style=&quot;width:300px; flex-shrink:2;&quot;&gt;240&lt;/div&gt; &lt;div class=&quot;blue&quot; style=&quot;width:300px; flex-shrink:3;&quot;&gt;210&lt;/div&gt;&lt;/div&gt; 150 240 210 flex-shrink也可以是小數：容器的width為600px，紅色Item的width為300px，綠色Item的width為300px，藍色Item的width為300px，紅色Item的flex-shrink:0.1，綠色Item的flex-shrink:0.4，藍色Item的flex-shrink:0.5 計算超出多少寬度：600(容器) - 300(紅色) - 300(綠色) - 300(藍色) = 300 (超出150) 每個Item收縮的權重為其flex-shrink * 寬度：0.1*300 + 0.4*300 + 0.5*300 = 300 每個Item要收縮的寬度為： 紅色：300(超出的寬度) * 0.1 (flex-shrink) * 300(Item的寬度) / 300(權重) = 30 綠色：300(超出的寬度) * 0.4 (flex-shrink) * 300(Item的寬度) / 300(權重) = 120 藍色：300(超出的寬度) * 0.5 (flex-shrink) * 300(Item的寬度) / 300(權重) = 150 因此三個元素最終的寬度為： 紅色：300 - 30 = 270 綠色：300 - 120 = 180 藍色：300 - 150 = 150 1234567891011121314&lt;style&gt;.container6 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white;}&lt;/style&gt;&lt;div class=&quot;container6 width:600px&quot;&gt; &lt;div class=&quot;red&quot; style=&quot;width:300px; flex-shrink:0.1;&quot;&gt;270&lt;/div&gt; &lt;div class=&quot;green&quot; style=&quot;width:300px; flex-shrink:0.4;&quot;&gt;180&lt;/div&gt; &lt;div class=&quot;blue&quot; style=&quot;width:300px; flex-shrink:0.5;&quot;&gt;150&lt;/div&gt;&lt;/div&gt; 270 180 150 flex-basis：設定Item佔用空間。如果沒設定或設為auto則Item的值為width(flex-direction:row)或是height(flex-direction:column)的值。 以下是範例： 紅色Item的style=\"width:300px; flex-basis:auto;\"。 綠色Item的style=\"width:300px; flex-basis:100px;\"。 藍色Item的style=\"width:300px;\"。 1234567891011121314&lt;style&gt;.container6 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white;}&lt;/style&gt;&lt;div class=&quot;container6 width:600px&quot;&gt; &lt;div class=&quot;red&quot; style=&quot;width:300px; flex-basis:auto;&quot;&gt;300&lt;/div&gt; &lt;div class=&quot;green&quot; style=&quot;width:300px; flex-basis:100px;&quot;&gt;100&lt;/div&gt; &lt;div class=&quot;blue&quot; style=&quot;width:300px;&quot;&gt;300&lt;/div&gt;&lt;/div&gt; 300 100 300 Reference: https://docs.unity3d.com/2020.1/Documentation/Manual/UIE-LayoutEngine.htmlhttps://discussions.unity.com/t/ui-toolkit-introduction-and-flexbox-layout/316856https://css-tricks.com/snippets/css/a-guide-to-flexbox/https://github.com/xieranmaya/blog/issues/9","link":"/2024/04/12/Layout-Engine/"},{"title":"Mac 截取螢幕圖片","text":"同時按下這三個按鍵：Shift+Command+4，就可以讓你使用滑鼠選擇擷取螢幕某個部分的圖片， Ｗindows中則是按下windows+Shift+s。 同時按下這三個按鍵：Shift+Command+3則是擷取整張桌面的圖。","link":"/2024/02/08/Mac-%E6%88%AA%E5%8F%96%E8%9E%A2%E5%B9%95%E5%9C%96%E7%89%87/"},{"title":"Linux檢查磁碟空間","text":"在Linux中，我們可以使用df指令檢查Linux磁碟空間的使用狀況 句法：df [options] [filesystems] options：可選參數，可以改變df輸出的格式，或是限定查看哪個Filesystem，等。 filesystems：可選的，可以指定特定的文件系統（掛載點（mount point））來檢查它們的使用情況，而不是獲取所有已掛載點的信息。 執行df指令時，將看到：Filesystem、Size（或blocks）、Used、Available、Use%和Mounted On，如下： 12345[root@host /]# dfFilesystem 1K-blocks Used Available Use% Mounted onoverlay 165455088 49616788 115821916 30% /tmpfs 65536 0 65536 0% /devtmpfs 16430216 0 16430216 0% /sys/fs/cgroup FileSystem ：顯示文件系統的名稱。 Size：顯示該文件系統的總容量。 Used：顯示該文件系統使用了多少磁碟空間。 Available：顯示該文件系統還剩下多少空間。 Use%： 顯示已使用空間的百分比。 Mounted On：顯示該文件系統的掛載點。 大部分都會加上 -h 參數，顯示人類比較容易暸解的容量方式，如下 12345[root@host /]# df -hFilesystem Size Used Avail Use% Mounted onoverlay 146G 39G 107G 27% /tmpfs 64M 0 64M 0% /devtmpfs 16G 0 16G 0% /sys/fs/cgroup 指定要顯示的文件系統 /dev 123[root@host /]# df -h /devFilesystem Size Used Avail Use% Mounted ontmpfs 64M 0 64M 0% /dev 以下是常用的參數： df -h ：以人類比較容易暸解的格式顯示結果。 df -m ：以MB為單位顯示結果。 df -k ：以KB為單位顯示結果。","link":"/2024/04/11/Linux%E6%AA%A2%E6%9F%A5%E7%A3%81%E7%A2%9F%E7%A9%BA%E9%96%93/"},{"title":"Liskov substitution principle","text":"里氏替換原則(Liskov substitution principle)：子類(Subclass)必須要可以替代父類(Super class)，即任何父類出現的地方，都可以使用其子類替換，而不影響程式的正確性。 在考慮里氏替換原則時，可以遵循以下幾點： 避免移除特性：如果在父類的行為中，如果子類中沒有這個特性的話，你可能違反了里氏替換原則(If you are removing features when subclassing, you are likely breaking Liskov substitution)。在設計時， 如果子類中出現了NotImplementedException，那你可能違反了里氏替換原則 如果出現只能是空白的方法也可能違反了里氏替換原則 保持抽象簡單：盡量讓抽象保持簡單(Keep abstractions simple)：如果在基類放入越多的邏輯，那你有很大的機率違反了里氏替換原則。基類應只包含子類可以共有的方法。 子類需要有與基類相同的公有成員(A subclass needs to have the same public members as the base class)：這些成員在呼叫時還需要具有相同的行為。 先考慮類的API再建立層次結構：在建立類的層次結構前先考慮它們的API(Consider the class API before establishing class hierarchies)：現實中的分類並不總能完全轉為類的結構，例如汽車(Car)與火車(Train)皆是車輛但它們不能直接繼承同一個父類，最好是將它們分開繼承 優先考慮組合而非繼承(Favor composition over inheritance)：在實作時，先考慮使用介面 (Interface) 或是將行為委託給其他類，而不是直接使用繼承。 例如：假設有一個交通工具 (Vehicle) 的類層次結構，會思考：汽車 (Car) 和卡車 (Truck) 繼承自交通工具 (Vehicle)， 12345678910111213141516171819202122232425public class Vehicle{ public float Speed { get; set; } public Vector3 Direction { get; set; } public virtual void GoForward() { // 移動向前的邏輯 } public virtual void Reverse() { // 倒車的邏輯 } public virtual void TurnRight() { // 右轉的邏輯 } public virtual void TurnLeft() { // 左轉的邏輯 }} 1234567891011public class Navigator{ public void Move(Vehicle vehicle) { vehicle.GoForward(); vehicle.TurnLeft(); vehicle.GoForward(); vehicle.TurnRight(); vehicle.GoForward(); }} 但若是將火車(Train)作為車輛(Vehicle)的子類則會違反里氏替換原則，這是因為火車沒有右轉(TurnRight)與左轉(TurnLeft)的行為，因此火車不能作為車輛(Vehicle)的子類。 為了修正，可以將轉彎(Turn)和移動(Move)動作抽象為介面可轉彎(ITurnable)和可移動(IMovable) 1234567891011public interface ITurnable{ void TurnRight(); void TurnLeft();}public interface IMovable{ void GoForward(); void Reverse();} 並將車輛分為可以在一般道路上行駛的車輛RoadVehicle，它實作可轉彎(ITurnable)和可移動(IMovable) 12345678910111213141516171819202122232425public class RoadVehicle : IMovable, ITurnable{ public float Speed { get; set; } public float TurnSpeed { get; set; } public virtual void GoForward() { // 移動向前的邏輯 } public virtual void Reverse() { // 倒車的邏輯 } public virtual void TurnLeft() { // 左轉的邏輯 } public virtual void TurnRight() { // 右轉的邏輯 }} 與需要在軌道上行駛的車輛RailVehicle，它只實作可移動(IMovable) 1234567891011121314public class RailVehicle : IMovable{ public float Speed { get; set; } public virtual void GoForward() { // 移動向前的邏輯 } public virtual void Reverse() { // 倒車的邏輯 }} 最後，定義汽車和火車的類： 123456789public class Car : RoadVehicle{ // Car特有的實作}public class Train : RailVehicle{ // Train特有的實作} 這樣，Navigator 類可以安全地操作所有可以移動的交通工具，而不需要關心它們是否能轉彎： 1234567891011121314public class Navigator{ public void Move(IMovable movable) { movable.GoForward(); movable.Reverse(); } public void Turn(ITurnable turnable) { turnable.TurnLeft(); turnable.TurnRight(); }}","link":"/2024/05/22/Liskov-substitution-principle/"},{"title":"Mac 顯示所有隱藏檔案","text":"在 Terminal 中輸入以下指令以顯示所有隱藏文件： 1defaults write com.apple.finder AppleShowAllFiles -bool true 然後，在 Terminal 中輸入以下指令以重新啟動 Finder： 1killall Finder 這樣就可以顯示所有隱藏文件了。","link":"/2024/02/08/Mac-%E9%A1%AF%E7%A4%BA%E6%89%80%E6%9C%89%E9%9A%B1%E8%97%8F%E6%AA%94%E6%A1%88/"},{"title":"Manipulators","text":"Manipulators是處理使用者與UI Element交互的State machine，它被用來儲存，註冊，取消註冊event callbacks。 建立與使用Manipulators你不需要自己撰寫管理callback的class，你只需要要繼承UI Toolkit提供的manipulators class就可以使用它們來管理callback與event，步驟如下： 建立一個class，這個class封裝了針對特定使用者互動所需的事件處理邏輯，並繼承了UI Toolkit提供的manipulators class。 在這個class中，實作方法(method)來回應相關的互動，例如滑鼠點擊或拖曳。這些方法捕獲並處理必要的資訊以執行這個互動行為(behavior)。 當你完成設計這個class之後，你就可以實體化它並將其附加到目標(target) UI Element上。這個附加使這個Manipulator class可以攔截和管理指定的事件，並協調使用者互動，同時與你的UI程式碼保持清晰的分離。 在Visual Element上使用AddManipulator將建立的Manipulator加入到這個Element 在Visual Element上使用RemoveManipulator為這個Element移除指定的的Manipulator 以下是UI Toolkit提供的Manipulator class Manipulator 繼承自 描述 Manipulator 所有manipulators的基類(Base class) KeyboardNavigationManipulator Manipulator 將特定設備輸入事件(device-specific input event)轉換為可以使用鍵盤進行的較高階導航操作(higher-level navigation operations) MouseManipulator Manipulator 處理滑鼠輸入，擁有一個啟用過濾器(ManipulatorActivationFilter)列表 ContextualMenuManipulator MouseManipulator 當使用者按下滑鼠右鍵或是menu鍵時，顯示內容選單(contextual menu) PointerManipulator MouseManipulator 處理指標(pointer)輸入，擁有一個啟用過濾器(ManipulatorActivationFilter)列表 Clickable PointerManipulator 追蹤element上的滑鼠事件並辨認是否發生點擊事件，也就是說在同一個element中是否有發生指標按下並放開 例子以下範例將示範 如何一個繼承PointerManipulator，來處理滑鼠輸入， 並使用activators list屬性來設定可以啟用這個manipulator的條件， 例如：當使用者點擊滑鼠左鍵時，啟用這個manipulator 要做到這個，你只要實體化一個ManipulatorActivationFilter，將其button屬性設為MouseButton.LeftMouse並加入到activators list即可 使用target屬性來存取附加這個manipulator的element， Override RegisterCallbacksOnTarget與UnregisterCallbacksFromTarget方法用以註冊和取消註冊event callbacks。 建立一個可以讓你拖動element的manipulator1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677using UnityEngine;using UnityEngine.UIElements;// 繼承PointerManipulatorpublic class ExampleDragger : PointerManipulator{ private Vector3 m_Start; protected bool m_Active; private int m_PointerId; private Vector2 m_StartSize; public ExampleDragger() { m_PointerId = -1; // 實體化一個`ManipulatorActivationFilter`，將其button屬性設為`MouseButton.LeftMouse`並加入到`activators` list activators.Add(new ManipulatorActivationFilter { button = MouseButton.LeftMouse }); m_Active = false; } // Override RegisterCallbacksOnTarget方法用以註冊event callbacks protected override void RegisterCallbacksOnTarget() { target.RegisterCallback&lt;PointerDownEvent&gt;(OnPointerDown); target.RegisterCallback&lt;PointerMoveEvent&gt;(OnPointerMove); target.RegisterCallback&lt;PointerUpEvent&gt;(OnPointerUp); } // Override UnregisterCallbacksFromTarget方法用以取消註冊event callbacks protected override void UnregisterCallbacksFromTarget() { target.UnregisterCallback&lt;PointerDownEvent&gt;(OnPointerDown); target.UnregisterCallback&lt;PointerMoveEvent&gt;(OnPointerMove); target.UnregisterCallback&lt;PointerUpEvent&gt;(OnPointerUp); } protected void OnPointerDown(PointerDownEvent e) { if (m_Active) { e.StopImmediatePropagation(); return; } if (CanStartManipulation(e)) { m_Start = e.localPosition; m_PointerId = e.pointerId; m_Active = true; target.CapturePointer(m_PointerId); e.StopPropagation(); } } protected void OnPointerMove(PointerMoveEvent e) { if (!m_Active || !target.HasPointerCapture(m_PointerId)) return; Vector2 diff = e.localPosition - m_Start; target.style.top = target.layout.y + diff.y; target.style.left = target.layout.x + diff.x; e.StopPropagation(); } protected void OnPointerUp(PointerUpEvent e) { if (!m_Active || !target.HasPointerCapture(m_PointerId) || !CanStopManipulation(e)) return; m_Active = false; target.ReleaseMouse(); e.StopPropagation(); }} 建立一個可以當拖動時，改變element大小的manipulator12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using UnityEngine;using UnityEngine.UIElements;public class ExampleResizer : PointerManipulator{ private Vector3 m_Start; protected bool m_Active; private int m_PointerId; private Vector2 m_StartSize; public ExampleResizer() { m_PointerId = -1; activators.Add(new ManipulatorActivationFilter { button = MouseButton.LeftMouse }); m_Active = false; } protected override void RegisterCallbacksOnTarget() { target.RegisterCallback&lt;PointerDownEvent&gt;(OnPointerDown); target.RegisterCallback&lt;PointerMoveEvent&gt;(OnPointerMove); target.RegisterCallback&lt;PointerUpEvent&gt;(OnPointerUp); } protected override void UnregisterCallbacksFromTarget() { target.UnregisterCallback&lt;PointerDownEvent&gt;(OnPointerDown); target.UnregisterCallback&lt;PointerMoveEvent&gt;(OnPointerMove); target.UnregisterCallback&lt;PointerUpEvent&gt;(OnPointerUp); } protected void OnPointerDown(PointerDownEvent e) { if (m_Active) { e.StopImmediatePropagation(); return; } if (CanStartManipulation(e)) { m_Start = e.localPosition; m_StartSize = target.layout.size; m_PointerId = e.pointerId; m_Active = true; target.CapturePointer(m_PointerId); e.StopPropagation(); } } protected void OnPointerMove(PointerMoveEvent e) { if (!m_Active || !target.HasPointerCapture(m_PointerId)) return; Vector2 diff = e.localPosition - m_Start; target.style.height = m_StartSize.y + diff.y; target.style.width = m_StartSize.x + diff.x; e.StopPropagation(); } protected void OnPointerUp(PointerUpEvent e) { if (!m_Active || !target.HasPointerCapture(m_PointerId) || !CanStopManipulation(e)) return; m_Active = false; target.ReleasePointer(m_PointerId); m_PointerId = -1; e.StopPropagation(); }} 加入manipulator1234var myElement = new VisualElement();// 加入manipulator到這個VisualElementmyElement.AddManipulator(new ExampleDragger()); 1234567891011121314var box = new VisualElement(){ style = { left = 100, top = 100, width = 100, height = 100, backgroundColor = Color.red }, pickingMode = PickingMode.Position,};box.AddManipulator(new ExampleResizer()); 移除manipulator12// 為這個VisualElement移除manipulatormyElement.RemoveManipulator&lt;ExampleDragger&gt;();","link":"/2024/04/18/Manipulators/"},{"title":"Physics Material實體材質","text":"實體材質，決定你的物體摩擦力與彈性，讓你的物件可以滑動或是反彈 在專案的畫面中使用滑鼠右鍵，找到Create -&gt; 如果是2D，選擇 -&gt; 2D -&gt; Physics Material 2D 如果是3D，選擇 -&gt; Material 參數簡介 Dynamic Friction：已在移動時使用的摩擦力，通常為0到1之間的值 值為0時，就像冰一樣，會滑動 值為1時，將使物件迅速靜止，除非使用很大的力或重力推動該物件 Static Friction：當物件靜止在表面上時的摩擦力，通常為0到1之間 值為0時，就像冰一樣，會滑動 值為1時，將使物件很難推動 Bounciness：表面的彈性， 值為0時，不會反彈 值為1時，在反彈時不會產生任何能量損失，可以一直反彈 Friction Combine：兩個碰撞物件的摩擦力的組合方式 Average：對兩個摩擦值求平均值 Minimum：使用兩個值中最小的值 Maximum：使用兩個值中最大的值 Multiply：兩個摩擦值相乘 Bounce Combine：兩個碰撞物件的彈性組合方式，其模式與Friction Combine相同","link":"/2024/04/03/Material%E7%A2%B0%E6%92%9E%E6%9D%90%E8%B3%AA/"},{"title":"Object Pool pattern","text":"物件池(Object Pool)：是一種減輕大量建立並銷毀物件時 CPU 負擔的設計模式。使用物件池時，物件會先被建立並放入池中等待，需要時應用程式不會新建物件，而是從物件池中取得並啟用它。當使用完畢後，物件不會被銷毀，而是被放回物件池中。 改進 可以在程式載入時建立物件池，這樣使用者就不會感到卡頓。 考慮將物件池設為static或是singleton的：這樣可以在所有情況下方便呼叫使用。 使用Dictionary來管理多個物件池：如果有多個物件池，可以使用 Key-Value 的資料結構（如 Dictionary）來管理，只需根據對應的 Key 就能方便地取得所需的物件池。 注意釋放物件池中的物件：確保物件在物件池中時不會被釋放，避免執行期間發生錯誤。 設定物件池上限：物件過多會消耗大量記憶體，因此需要為物件池設定一個上限，避免物件池中物件過多。 以下是一個簡單的物件池， 這個物件池使用Stack SetupPool()用來產生一些物件放到物件池中 GetPooledObject()用來啟用物件並取得，當物件不足(stack.Count == 0)時，會再產生一個新物件 ReturnToPool()用來將物件停用，並返回物件到物件池 注意不要直接使用，因為這個例子沒有設定Stack上限，可能會產生過多的物件1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ObjectPool : MonoBehaviour{ [SerializeField] private uint initPoolSize; [SerializeField] private PooledObject objectToPool; // 存儲物件池中的物件 private Stack&lt;PooledObject&gt; stack; private void Start() { SetupPool(); } // 建立物件池（在卡頓不明顯時調用） private void SetupPool() { stack = new Stack&lt;PooledObject&gt;(); PooledObject instance = null; for (int i = 0; i &lt; initPoolSize; i++) { instance = Instantiate(objectToPool); instance.Pool = this; instance.gameObject.SetActive(false); stack.Push(instance); } } // 從物件池中返回第一個可用的物件 public PooledObject GetPooledObject() { // 如果物件不夠，則實例化新的物件 if (stack.Count == 0) { PooledObject newInstance = Instantiate(objectToPool); newInstance.Pool = this; return newInstance; } // 否則，從物件池中取得下一個物件 PooledObject nextInstance = stack.Pop(); nextInstance.gameObject.SetActive(true); return nextInstance; } public void ReturnToPool(PooledObject pooledObject) { stack.Push(pooledObject); pooledObject.gameObject.SetActive(false); } } 建立一個 PooledObject 類別，讓它依賴 ObjectPool，這樣可以在使用完畢後返回物件池： 123456789public class PooledObject : MonoBehaviour{ private ObjectPool pool; public ObjectPool Pool { get =&gt; pool; set =&gt; pool = value; } public void Release() { pool.ReturnToPool(this); }} 在Unity 2021後，有內建 UnityEngine.Pool 物件池，它提供了多種容器的Pool，像是 ObjectPool：是一個Stack DictionaryPool&lt;T0,T1&gt; GenericPool HashSetPool LinkedPool ListPool使用內建 UnityEngine.Pool 物件池有許多好處，包含 可以快速的使用物件池，不需要重複造輪子 有多種容器供你選用 當到達最大物件數量後會摧毀該物件，不建立過多的物件 以下是UnityEngine.Pool的範例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using UnityEngine.Pool;public class RevisedGun : MonoBehaviour{ // 使用基於 Stack 的 ObjectPool private IObjectPool&lt;RevisedProjectile&gt; objectPool; // 如果嘗試返回已經存在於池中的物件，則拋出異常 [SerializeField] private bool collectionCheck = true; // 控制池的預設容量和最大大小 [SerializeField] private int defaultCapacity = 20; [SerializeField] private int maxSize = 100; private void Awake() { objectPool = new ObjectPool&lt;RevisedProjectile&gt;(CreateProjectile, OnGetFromPool, OnReleaseToPool, OnDestroyPooledObject, collectionCheck, defaultCapacity, maxSize); } // 在new ObjectPool建構子中使用，主要是先建立物件以填充物件池 private RevisedProjectile CreateProjectile() { RevisedProjectile projectileInstance = Instantiate(projectilePrefab); projectileInstance.ObjectPool = objectPool; return projectileInstance; } // 在new ObjectPool建構子中使用，告訴物件池在將物件返回時要做什麼動作 private void OnReleaseToPool(RevisedProjectile pooledObject) { pooledObject.gameObject.SetActive(false); } // 在new ObjectPool建構子中使用，告訴物件池在物件池中取出物件時要做什麼初始化動作 private void OnGetFromPool(RevisedProjectile pooledObject) { pooledObject.gameObject.SetActive(true); } // 在new ObjectPool建構子中使用，告訴物件池在超過最大物件數量時如何銷毀物件 private void OnDestroyPooledObject(RevisedProjectile pooledObject) { Destroy(pooledObject.gameObject); } private void FixedUpdate() { // 省略其他代碼 }} 與上面簡單的ObjectPool相同，讓RevisedProjectile依賴 IObjectPool&lt;RevisedProjectile&gt;，在使用完畢後呼叫objectPool.Release(this)返回物件池： 12345678910111213141516171819202122232425262728public class RevisedProjectile : MonoBehaviour{ // 延遲後停用 [SerializeField] private float timeoutDelay = 3f; private IObjectPool&lt;RevisedProjectile&gt; objectPool; // 公共屬性，用於給 projectile 一個 ObjectPool 的引用 public IObjectPool&lt;RevisedProjectile&gt; ObjectPool { set =&gt; objectPool = value; } public void Deactivate() { StartCoroutine(DeactivateRoutine(timeoutDelay)); } private IEnumerator DeactivateRoutine(float delay) { yield return new WaitForSeconds(delay); // 重置移動中的 Rigidbody Rigidbody rBody = GetComponent&lt;Rigidbody&gt;(); rBody.velocity = Vector3.zero; rBody.angularVelocity = Vector3.zero; // 將 projectile 返回到物件池 objectPool.Release(this); }} Reference: https://github.com/Unity-Technologies/game-programming-patterns-demo/tree/main/Assets/7%20Object%20Pool","link":"/2024/05/24/Object-Pool/"},{"title":"Observer pattern","text":"在遊戲中，會發生很多事，例如擊敗一個敵人，玩家升級等，如果直接將這些行為直接在各個物件中執行，會增加很多依賴，當程式碼成長到一定程度時，會變得很難維護。 觀察者模式(Observer pattern)通常會用來解決此問題。它使用一種one-to-many依賴(dependency)，讓你的物件之間的溝通可以保持在一種低耦合(loosely coupled)的關係，當一個物件的狀態改變時，會自動通知所有想要接收此訊息的物件。例如廣播系統，廣播會向外發送音樂給收聽者，廣播不需要知道誰在收聽，它只要使用固定的頻道發送音樂即可，而收聽者只需要將頻道調整到該廣播系統的頻道即可收到音樂。 發送消息的物件稱為subject 其他接收此消息的物件稱為observers 優點： 發送消息的物件(subject)與接收此消息的物件(observers)解耦(Loose coupling) 發送消息的物件不需要知道關於接收此消息的物件的資訊，它只需要負責將消息發送出去； 接收此消息的物件會有一個發送消息物件的依賴，但是接收此消息的物件之間互相不知道彼此 將observer需要對訊息做出反應的邏輯放到對應的observer中，讓他們各自維護。變得較容易測試與除錯 非常適合使用者介面(User Interface)，MVP與MVC patterns就是使用觀察者模式(Observer pattern) 缺點： 增加程式複雜度， 如果要刪除Subject的話會比較麻煩 Observer仍然會對Subject有依賴， 可以使用一個static EventManager除去 會消耗一些效能 在C#中已經有實作Observer pattern =&gt; Event publisher(即subject)：有一個或多個event，在執行時，會將訊息發送給註冊這些event的物件 observers：這些物件會有一些event handler的方法，當publisher發送訊息時，便會執行對應的event handler方法 以下是一個最簡單的例子Subject有一個 event ThingHappened，它暴露給其他物件讓它們可以註冊 123456789public class Subject{ public event Action ThingHappened; public void DoThing() { ThingHappened?.Invoke(); }} Observer有一個Subject依賴，用來註冊；並且有一個OnEventHandler，當Subject發送訊息時，便會執行這個方法 12345678910111213141516public class Observer{ private Subject subjectToObserve; public Observer(Subject subject) { subjectToObserve = subject; subjectToObserve.ThingHappened += OnEventHandle; } private void OnEventHandler() { // any logic that responds to event goes here Debug.Log(&quot;Observer responds&quot;); }} Reference: https://unity.com/how-to/create-modular-and-maintainable-code-observer-pattern","link":"/2024/05/22/Observer-pattern/"},{"title":"Open-closed principle","text":"開閉原則(Open-closed principle)：開閉原則指的是類(Class)要可以對外擴展(open for extension)，但是對內部修改封閉(closed for modification)。簡單的說就是可以為你的程式添加新的行為，但是不去修改現有程式碼。 一個經典的例子是計算體積，我們要建立一個 AreaCalculator 類，用來計算物體的體積， 下面是一個不遵守開閉原則的例子。 定義了一個AreaCalculator類，它含有GetRectangleArea與GetCircleArea方法，分別用來計算四邊形與圓形的體積 定義了一個Rectangle類，用來存放四邊形的寬和高 定義了一個Circle類，用來存放圓形半徑12345678910111213141516171819202122public class AreaCalculator{ public float GetRectangleArea(Rectangle rectangle) { return rectangle.width * rectangle.height; } public float GetCircleArea(Circle circle) { return circle.radius * circle.radius * Mathf.PI; }}public class Rectangle{ public float width; public float height;}public class Circle{ public float radius;} 這個AreaCalculator類是可以運作的如預期，但是如果添加更多計算體積的方法（例如三角形或五邊形），就會一直變更這個AreaCalculator類，這違反了開閉原則。 建立一個Shape基類， 1234public abstract class Shape{ public abstract float CalculateArea();} 所有物體皆繼承這個Shape基類 12345678910111213141516171819public class Rectangle : Shape{ public float width; public float height; public override float CalculateArea() { return width * height; }}public class Circle : Shape{ public float radius; public override float CalculateArea() { return radius * radius * Mathf.PI; }} AreaCalculator類更改為依賴Shape 1234567public class AreaCalculator{ public float GetArea(Shape shape) { return shape.CalculateArea(); }} 如此每當添加新物體時，也不用更改AreaCalculator類，只需要新增一個繼承Shape的類即可","link":"/2024/05/22/Open-closed-principle/"},{"title":"Project-Wide Actions","text":"Input System的project-wide actions功能讓你可以設定一個能夠在整個專案中使用的Action Asset，當Action Asset設為project-wide actions之後，那這個action就是個preloaded asset，也就是說當你的App啟動後就會載入，並且一直保持可用直到App關閉為止。 建立Project-Wide Actions Asset 找到 Edit &gt; Project Settings &gt; Input System Package 並按下 Create a new project-wide Action Asset 在專案中會建立一個名為InputSystem_Actions的Action Asset。 這個InputSystem_Actions中已經有一些預設的Action，像是Move，Jump等，符合大部分遊戲，並預設綁定大部分裝置如鍵盤，滑鼠，遊戲搖桿，觸控螢幕，XR等 在程式碼中使用InputSystem.actions去找到Action1InputSystem.actions.FindAction(&quot;Move&quot;); 上一篇：安裝Input System 下一篇：使用Action Editor編輯Action Reference: https://docs.unity3d.com/Packages/com.unity.inputsystem@1.8/manual/ProjectWideActions.html","link":"/2024/04/25/Project-Wide-Actions/"},{"title":"SOLID principles","text":"SOLID principles是程式設計師必須了解的五個原則 單一職責原則(Single responsibility)：確保類只負責一件事。 開閉原則(Open-closed)：在不更改現有程式碼的情況下，可以擴展一個類的功能。 里氏替換原則(Liskov substitution)：子類可以替代基類，而不影響程式的正確性。 介面隔離原則(Interface segregation)：讓介面(interface)盡可能簡單，確保實作類只需要實作其所需的介面方法。 依賴倒置原則(Dependency inversion)：高層模組不應依賴於低層模組，兩者都應依賴於抽象。具體實現應依賴於抽象，而不是抽象依賴於具體實現。 這些原則可以讓你的程式設計更具彈性和可維護性，但在不確定是否要使用它們時，請記住KISS（Keep It Simple, Stupid）原則，不要強迫將其應用於程式碼中。","link":"/2024/05/22/SOLID-principles/"},{"title":"Single-responsibility principle","text":"單一職責(Single-responsibility principle)：一個類(class)應該只因為它負責的那件事而被更改。 注意：在單一職責中，要取得平衡，不要過度的拆分，例如拆分到一個類中只有一個方法。 拆分時可以考慮以下因素： 可讀性(Readability)：簡短的類通常比較容易閱讀和理解。雖然“簡短”沒有明確的定義，但通常開發者認為200~300行的類是比較合適的。 擴展性(Extensibility)：類是否容易擴展，修改或替換這些類時不應該無意破壞其他部分。 可重用性(Reusability)：是否可以更方便地重新使用這些類 以下是一個將聲音，輸入，移動皆包含在一起的Player類，隨著專案的發展，這個類會越來愈難維護，例如更改聲音會動到這個類，更改移動輸入會動到這個類… 123456789101112131415161718192021222324public class UnrefactoredPlayer : MonoBehaviour{ [SerializeField] private string inputAxisName; [SerializeField] private float positionMultiplier; private float yPosition; private AudioSource bounceSfx; private void Start() { bounceSfx = GetComponent&lt;AudioSource&gt;(); } private void Update() { float delta = Input.GetAxis(inputAxisName) * Time.deltaTime; yPosition = Mathf.Clamp(yPosition + delta, -1, 1); transform.position = new Vector3(transform.position.x, yPosition * positionMultiplier, transform.position.z); } private void OnTriggerEnter(Collider other) { bounceSfx.Play(); }} 應考慮將這些行為拆分到各自的類，如 PlayerAudio、PlayerInput、PlayerMovement 等。Player 類仍然依賴這些行為，但這些行為已經被拆分到各自的類中。 1234567891011121314151617181920212223242526272829[RequireComponent(typeof(PlayerAudio), typeof(PlayerInput), typeof(PlayerMovement))]public class Player : MonoBehaviour{ private PlayerAudio playerAudio; private PlayerInput playerInput; private PlayerMovement playerMovement; private void Start() { playerAudio = GetComponent&lt;PlayerAudio&gt;(); playerInput = GetComponent&lt;PlayerInput&gt;(); playerMovement = GetComponent&lt;PlayerMovement&gt;(); }}public class PlayerAudio : MonoBehaviour{ // PlayerAudio specific implementation}public class PlayerInput : MonoBehaviour{ // PlayerInput specific implementation}public class PlayerMovement : MonoBehaviour{ // PlayerMovement specific implementation}","link":"/2024/05/22/Single-responsibility-principle/"},{"title":"Singleton pattern","text":"單例模式(Singleton pattern)：確保應用程式中只有一個實例，並且提供簡單的全局訪問方式。 然而，單例模式在一些設計模式中被認為弊大於利，被列為反模式(anti-pattern)，這是因為單例模式太容易使用了導致開發人員很容易設計出不必要的全域狀態或是全域依賴。 優點 使用簡單，單例是全域可存取的，很容易的就可以取道該單例並在程式中使用。 由於單例是全域可存取因此你不需要去想使否需要暫存它。 缺點 全局存取：單例是全域可存取的，違反了 SOLD原則。 測試困難：單例模式使得測試必須互相獨立變得困難，因為單例可以直接改變狀態。 強依賴性：單例造成的依賴性太強，如果你想更改某個單例，就需要更改所有有使用到它的地方。 以下是一個簡單的單例模式 public static Instance用來保存Sence中的單例實體 在Awake()中檢查是否已有這個實例，如果沒有則將其設為實例；如果有則表示有重複設定，需要將它銷毀，以確保在這個場景中只有一個實例。 這個SimpleSingleton有一些缺陷 當載入新Scene時會銷毀這個GameObject(可以使用 DontDestroyOnLoad 告訴Unity不要摧毀它) 在使用時需要將它附加到Scene結構中123456789101112131415161718using UnityEngine;public class SimpleSingleton : MonoBehaviour{ public static SimpleSingleton Instance; private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(gameObject); } }} 也可以使用延遲初始化(Lazy initialization)的方式，來建立單例，下面例子中 使用 DontDestroyOnLoad(gameObject) 告訴 Unity 不要銷毀它，因此即使切換場景也不會清除這個單例。 不需要手動附加到Scene結構中，因為使用了 SetupInstance()，如果目前還沒有建立這個單例，它會自動建立一個 GameObject 並附加到它身上。1234567891011121314151617181920212223242526272829303132333435363738394041public class Singleton : MonoBehaviour{ private static Singleton instance; public static Singleton Instance { get { if (instance == null) { SetupInstance(); } return instance; } } private void Awake() { if (instance == null) { instance = this; DontDestroyOnLoad(this.gameObject); } else { Destroy(gameObject); } } private static void SetupInstance() { instance = FindObjectOfType&lt;Singleton&gt;(); if (instance == null) { GameObject gameObj = new GameObject(); gameObj.name = &quot;Singleton&quot;; instance = gameObj.AddComponent&lt;Singleton&gt;(); DontDestroyOnLoad(gameObj); } }} 更進一步地將它一般化。在上面的單例模式中，如果需要多個不同的單例，例如 AudioManager 和 GameManager，那麼會複製很多相同的程式碼來建立單例。因此，可以將這個步驟一般化，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public abstract class MonoSingleton&lt;T&gt; : MonoBehaviour where T : MonoSingleton&lt;T&gt;{ private static T instance; public static T Instance { get { if (instance == null) { instance = FindFirstObjectByType&lt;T&gt;(); if (instance == null) { SetupInstance(); } } return instance; } } public virtual void Awake() { RemoveDuplicates(); } private static void SetupInstance() { instance = FindFirstObjectByType&lt;T&gt;(); if (instance == null) { GameObject gameObj = new(); gameObj.name = typeof(T).Name; instance = gameObj.AddComponent&lt;T&gt;(); DontDestroyOnLoad(gameObj); } } private void RemoveDuplicates() { if (instance == null) { instance = this as T; DontDestroyOnLoad(gameObject); } else { Destroy(gameObject); } }} 之後你在使用時，只需要繼承他即可 1234public class GameManager: Singleton&lt;GameManager&gt;{ // ...} Reference: https://github.com/Unity-Technologies/game-programming-patterns-demo/tree/main/Assets/8%20Singleton","link":"/2024/05/24/Singleton-pattern/"},{"title":"UI Builder - 2 （開始使用UI Builder）","text":"使用UI Builder建立UI的流程一般會是 建立一個新UI Document (UXML) 為你的UI結構加入element 在 Inspector 中調整element的attributes與style 如果有多個element使用相同的style，可以建立USS style sheets與selectors(類似網頁的css) 測試UI是否符合你的需求，並將inline style放到USS中 儲存UI Document (UXML) 以下範例將 建立一個root element作為background，這個root element會含有兩個containers。 一個container用來放角色名稱的list， 另外一個用來放角色的詳細資訊。 在這個角色的詳細資訊container中會加入background與foreground frames。 以及兩個label，用來顯示角色名稱 建立Root Element 首先建立一個Unity專案 開啟UI Builder， Window &gt; UI Toolkit &gt; UI Builder 在UI Builder的Viewpoint中左上角找到File &gt; New建立一個新的UXML document 選擇Save，儲存為MainView.uxml 在左下角Library中，找到VisualElement，將它拖入Viewport中（雙擊VisualElement也可以） 在右側``Inspector`中，找到Inlined Styled，可以在此處修改element的風格 找到Flex，將Grow設為1，這會把flex-grow的值設為1，讓它填滿整個螢幕 接著找到Align，將Align Items與Justify Content都設為Center 把Background的Color設為#732526，並將透明度設為255 建立Parent Container 在左下角Library中，將VisualElement拖入前面建立的rootVisualElement中。 將這個新建VisualElement它的Flex中的Direction設為row，並把它Size中的Height設為350 pixels 建立角色名稱List Container 在左下角Library中，找到ListView將它拖入前面建立的Parent ContainerVisualElement中 修改這個ListView的name，改為CharacterList 將這個ListView它Size中的Width設為230 pixels，並找到Margin &amp; Padding &gt; Margin &gt; Right把Right設為6 設定它的Background &gt; Color為#6E3925，並設定透明度為255 設定它的Border &gt; Color為#311A11，並設定透明度為255 設定它的Border &gt; Width設為4pixels，Radius設為15pixels。 此時你的UI看起來會長這樣 建立角色詳細訊息 Container 在Parent Container中再加入一個VisualElement， 將它 Align &gt; Align Items設為flex-end，並且把Align &gt; Justify Content設為space-between 將它Flex &gt; Basis &gt; Shrink設為0，並且把Flex &gt; Basis &gt; Grow也設為0 在這個VisualElement中加入一個VisualElement 為這個VisualElement設定Size &gt; Width為276pixels；Align &gt; Align Items為center；Align &gt; Justify Content為center；最後設定Margin &amp; Padding &gt; Padding為8 pixels。 為這個VisualElement設定Background &gt; Color為#AA5939，並設定透明度為255 為這個VisualElement設定Border &gt; Color為#311A11，透明度設為255 為這個VisualElement設定Border &gt; Width設為4pixels，Radius設為15pixels。 此時你的UI看起來會長這樣 建立角色詳細訊息框背景 在角色詳細訊息 Container中加入一個VisualElement 將它的Size的Width與Height設為120pixels 將它的Margin &amp; Padding &gt; Padding設為4pixels 將它的Background &gt; Color設為#FF8554，透明度設為255 將它的Border &gt; Color為#311A11，透明度設為255 將它的Border &gt; Width設為4pixels，Radius設為15pixels此時你的UI看起來會長這樣 建立USS來管理Style在建立UI時，可以發現Border的Style都是一樣的，因此我們可以把它們拿出來放到一個USS中方便管理 在StyleSheet選擇 + &gt; Create New USS 儲存為MainView.uss 點擊新建的MainView.uss，並在右側的Inspertor中Selector輸入框中輸入.border，之後在點擊Create New USS Selector 接著你可以在左側的StyleSheet中看到剛剛建立的.borderclass 點擊.borderclass後，在右側的Inspertor，將Border &gt; Color設為#311A11 將它的Border &gt; Width設為2pixels，Radius設為15pixels 將這個.borderclass拖動到角色詳細訊息 Container與角色詳細訊息框的VisualElement 點選角色詳細訊息 Container與角色詳細訊息框的VisualElement，在右側的Inspertor中找到Border，並對Border按下滑鼠右鍵，會跳出一個選單，選擇Unset將Border的inline style清除。 建立角色詳細訊息框前景 在角色詳細訊息框背景的VisualElement加入一個VisualElement並將它命名為CharacterPortrait 設定它的Flex &gt; Grow為1，這樣它裡面的圖片就可以充滿整個可用空間。 設定它的Background &gt; Scale Mode為scale-to-fit，這樣它的圖片就可以充滿element size，並且保持適當的長寬比(aspect ratio) 建立角色詳細訊息Labels 在角色詳細訊息框背景的VisualElement加入兩個Labels，並分別命名為CharacterName與CharacterClass 選擇#CharacterName，將它的Text &gt; Font Style改為B；Text &gt; Size改為18 pixels 在Attributes &gt; Text中可以更改顯示的字串 最後你的UI看起來會長這樣Reference: https://docs.unity3d.com/Manual/UIB-getting-started.html 上一篇：UI Builder - 1 （UI Builder介面簡介） 下一篇：UI Builder - 3 （使用C# Script操控UI)","link":"/2024/04/09/UI-Builder-2-%EF%BC%88%E9%96%8B%E5%A7%8B%E4%BD%BF%E7%94%A8UI-Builder%EF%BC%89/"},{"title":"UI Builder - 3 （使用C# Script操控UI）","text":"在UI-Builder-2-（開始使用UI-Builder）中以建立一個空白的UI，接下來我們要開始為這個UI添加內容。 建立空白UI 首先需要為這些Element命名，為了方便起見，先將這段UXML複製1234567891011121314151617&lt;ui:UXML xmlns:ui=&quot;UnityEngine.UIElements&quot; xmlns:uie=&quot;UnityEditor.UIElements&quot; editor-extension-mode=&quot;False&quot;&gt;&lt;Style src=&quot;MainView.uss&quot; /&gt;&lt;ui:VisualElement name=&quot;background&quot;&gt; &lt;ui:VisualElement name=&quot;main-container&quot;&gt; &lt;ui:ListView focusable=&quot;true&quot; name=&quot;character-list&quot; /&gt; &lt;ui:VisualElement name=&quot;right-container&quot;&gt; &lt;ui:VisualElement name=&quot;details-container&quot;&gt; &lt;ui:VisualElement name=&quot;details&quot;&gt; &lt;ui:VisualElement name=&quot;character-portrait&quot; /&gt; &lt;/ui:VisualElement&gt; &lt;ui:Label text=&quot;Label&quot; name=&quot;character-name&quot; /&gt; &lt;ui:Label text=&quot;Label&quot; display-tooltip-when-elided=&quot;true&quot; name=&quot;character-class&quot; /&gt; &lt;/ui:VisualElement&gt; &lt;/ui:VisualElement&gt; &lt;/ui:VisualElement&gt;&lt;/ui:VisualElement&gt;&lt;/ui:UXML&gt; 接著在專案中，找到MainView.uxml，滑鼠左鍵點選旁邊的小箭頭，把它點開，會出現會出現inlineStyle 對著inlineStyle滑鼠左鍵點兩下，就會用IDE開啟MainView.uxml 接著把上面的UXML內容複製進去，存檔。 再開啟MainView.uss，把下面這一段內容複製進去，存檔12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#background { flex-grow: 1; align-items: center; justify-content: center; background-color: rgb(115, 37, 38);}#main-container { flex-direction: row; height: 350px;}#character-list { width: 230px; border-color: rgb(49, 26, 17); border-width: 4px; background-color: rgb(110, 57, 37); border-radius: 15px; margin-right: 6px;}#character-name { -unity-font-style: bold; font-size: 18px;}#CharacterClass { margin-top: 2px; margin-bottom: 8px; padding-top: 0; padding-bottom: 0;}#right-container{ justify-content: space-between; align-items: flex-end;}#details-container{ align-items: center; background-color: rgb(170, 89, 57); border-width: 4px; border-color: rgb(49, 26, 17); border-radius: 15px; width: 252px; justify-content: center; padding: 8px; height: 163px;}#details{ border-color: rgb(49, 26, 17); border-width: 2px; height: 120px; width: 120px; border-radius: 13px; padding: 4px; background-color: rgb(255, 133, 84);}#character-portrait{ flex-grow: 1; -unity-background-scale-mode: scale-to-fit;} 接著再打開UI Builder，就可以看到一個空白的UI了。 建立一個List Enrty 在專案畫面，建立一個ListEntry.uxml，Create &gt; UI Toolkit &gt; UI Document 將以下內容貼上123456&lt;ui:UXML xmlns:ui=&quot;UnityEngine.UIElements&quot; xmlns:uie=&quot;UnityEditor.UIElements&quot; editor-extension-mode=&quot;False&quot;&gt;&lt;Style src=&quot;ListEntry.uss&quot; /&gt;&lt;ui:VisualElement name=&quot;list-entry&quot;&gt; &lt;ui:Label text=&quot;Label&quot; display-tooltip-when-elided=&quot;true&quot; name=&quot;character-name&quot; /&gt;&lt;/ui:VisualElement&gt;&lt;/ui:UXML&gt; 其中&lt;Style src=&quot;ListEntry.uss&quot; /&gt;會引用等一下建立的ListEntry.uss 使用類似的方式，Create &gt; UI Toolkit &gt; Style Sheet，建立一個ListEntry.uss，並將以下內容貼上12345678910111213141516#list-entry { height: 41px; align-items: flex-start; justify-content: center; padding-left: 10px; background-color: rgb(170, 89, 57); border-color: rgb(49, 26, 17); border-width: 2px; border-radius: 15px;}#character-name { -unity-font-style: bold; font-size: 18px; color: rgb(49, 26, 17);} 可以使用UI Builder打開這個ListEntry.uxml來觀看UI的樣貌 建立 C# Script與其互動 在Asset資料夾下面，建立一個Scripts資料夾 建立一個CharacterData.cs 將以下內容複製到CharacterData.cs 1234567891011121314using UnityEngine;public enum ECharacterClass{ Knight, Ranger, Wizard}[CreateAssetMenu] // 這個Attribute會在Create選單中加入這個CharacterDatapublic class CharacterData : ScriptableObject{ public string CharacterName; public ECharacterClass Class; public Sprite PortraitImage;} 在Asset資料夾下面，建立一個Resources資料夾 在Resources資料夾下面，建立一個Characters資料夾 Characters資料夾中，選擇Create &gt; Character Data建立一個ScriptableObject 將UI放到Sence中 在Scene選擇GameObject &gt; UI Toolkit &gt; UI Document，建立一個UI Document GameObject 在Hierarchy視窗中選擇UIDocument Game Object，將MainView.uxml拖放到右側的Source Asset中 建立Controllers在專案中建立兩個C# controller，與一個MainView CharacterListEntryController：負責更新ListEntry.uxml的Label CharacterListController：負責處理MainView.uxml MainView繼承MonoBehaviour，主要用來與UIDocument GameObject連結，取得UIDocument Game Object後，把它放入CharacterListController 123456789101112131415161718using UnityEngine.UIElements;public class CharacterListEntryController{ Label NameLabel; // 這個function用來設定VisualElement，讓這個controller可以更改label public void SetVisualElement(VisualElement visualElement) { NameLabel = visualElement.Q&lt;Label&gt;(&quot;character-name&quot;); } // 使用CharacterData設定Label的Text public void SetCharacterData(CharacterData characterData) { NameLabel.text = characterData.CharacterName; }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100using System.Collections.Generic;using UnityEngine;using UnityEngine.UIElements;public class CharacterListController{ // UXML template for list entries VisualTreeAsset ListEntryTemplate; // UI element references ListView CharacterList; Label CharClassLabel; Label CharNameLabel; VisualElement CharPortrait; public void InitializeCharacterList(VisualElement root, VisualTreeAsset listElementTemplate) { EnumerateAllCharacters(); // Store a reference to the template for the list entries ListEntryTemplate = listElementTemplate; // Store a reference to the character list element CharacterList = root.Q&lt;ListView&gt;(&quot;character-list&quot;); // Store references to the selected character info elements CharClassLabel = root.Q&lt;Label&gt;(&quot;character-class&quot;); CharNameLabel = root.Q&lt;Label&gt;(&quot;character-name&quot;); CharPortrait = root.Q&lt;VisualElement&gt;(&quot;character-portrait&quot;); FillCharacterList(); // Register to get a callback when an item is selected CharacterList.onSelectionChange += OnCharacterSelected; } List&lt;CharacterData&gt; AllCharacters; void EnumerateAllCharacters() { AllCharacters = new List&lt;CharacterData&gt;(); AllCharacters.AddRange(Resources.LoadAll&lt;CharacterData&gt;(&quot;Characters&quot;)); } void FillCharacterList() { // Set up a make item function for a list entry CharacterList.makeItem = () =&gt; { // Instantiate the UXML template for the entry var newListEntry = ListEntryTemplate.Instantiate(); // Instantiate a controller for the data var newListEntryLogic = new CharacterListEntryController(); // Assign the controller script to the visual element newListEntry.userData = newListEntryLogic; // Initialize the controller script newListEntryLogic.SetVisualElement(newListEntry); // Return the root of the instantiated visual tree return newListEntry; }; // Set up bind function for a specific list entry CharacterList.bindItem = (item, index) =&gt; { (item.userData as CharacterListEntryController).SetCharacterData(AllCharacters[index]); }; // Set a fixed item height CharacterList.fixedItemHeight = 45; // Set the actual item's source list/array CharacterList.itemsSource = AllCharacters; } void OnCharacterSelected(IEnumerable&lt;object&gt; selectedItems) { // Get the currently selected item directly from the ListView var selectedCharacter = CharacterList.selectedItem as CharacterData; // Handle none-selection (Escape to deselect everything) if (selectedCharacter == null) { // Clear CharClassLabel.text = &quot;&quot;; CharNameLabel.text = &quot;&quot;; CharPortrait.style.backgroundImage = null; return; } // Fill in character details CharClassLabel.text = selectedCharacter.Class.ToString(); CharNameLabel.text = selectedCharacter.CharacterName; CharPortrait.style.backgroundImage = new StyleBackground(selectedCharacter.PortraitImage); }} 123456789101112131415161718using UnityEngine;using UnityEngine.UIElements;public class MainView : MonoBehaviour{ [SerializeField] VisualTreeAsset ListEntryTemplate; void OnEnable() { // The UXML is already instantiated by the UIDocument component var uiDocument = GetComponent&lt;UIDocument&gt;(); // Initialize the character list controller var characterListController = new CharacterListController(); characterListController.InitializeCharacterList(uiDocument.rootVisualElement, ListEntryTemplate); }} 將MainView拖入UIDocument GameObject。 將ListEntry.uxml拖入ListEntryTemplate Reference：https://docs.unity3d.com/Manual/UIE-HowTo-CreateRuntimeUI.html 上一篇：UI-Builder-2-（開始使用UI-Builder）","link":"/2024/04/11/UI-Builder-3-%EF%BC%88%E8%88%87Element%E4%BA%92%E5%8B%95%EF%BC%89/"},{"title":"Visual Tree","text":"UI Toolkit是用於開發使用者介面 (UI) 功能、資源和工具的集合，UI Toolkit啟發於 web technologies。它是一個retained-mode UI system，支援stylesheets，dynamic與contextual event handling Visual element：在UI Toolkit中，組成UI的最基礎block為Visual element，在C#程式碼中，它繼承VisualElement，你可以設定它的風格(style)，定義它的行為，讓它作為UI的一部份顯示在screen上面。 Visual Tree：由Visual element組成的有序且具父子關係(parent-child relationships)的樹狀結構(hierarchy tree)。 一個簡單的 Visual Tree 所有在Visual Tree中的node都繼承VisualElement，VisualElement的子類定義了各種UI的功能如Button，Text input fields等，稱為Controls，Unity提供很多內建的Controls。 Panels：是一個visual tree的parent object，它擁有rootVisualElement，但是它不是visual element，panel也負責處理focus control與為visual tree分派事件(event dispatching)。 Draw order：visual tree是使用depth-first search，因此他的順序會是 最上面的visual element 這個visual element的第一個child element 這個child element的後代 座標(Coordinate)與位置(Position)系統：在UI Toolkit中，它使用style properties中的layout parameters去計算每個element的座標與位置，基於Flexbox。 相對(Relative)位置：相對於元素計算位置的座標，布局系統(layout system)計算元素的位置，然後將座標添加為偏移量。父元素可以影響子元素的大小和位置，因為布局引擎在計算元素位置時將它們考慮在內。子元素只能影響父元素的大小。 絕對(Absolute)位置：相對於父元素的座標，這繞過自動布局計算，直接設置元素的位置。在相同父元素下的同級元素(Sibling elements)對該元素的位置沒有影響。同樣地，該元素不影響相同父元素下其他同級元素的位置和大小。 Reference: https://docs.unity3d.com/Packages/com.unity.ui.builder@1.0/manual/uib-interface-overview.htmlhttps://docs.unity3d.com/Manual/UIElements.html","link":"/2024/04/06/UI-Toolkit/"},{"title":"UI Builder - 1 （UI Builder介面簡介）","text":"UI Builder，是一個可視化的UI編輯工具，讓你可以在使用UI Toolkit時可以編輯UI assets，如UI Documents(.uxml)與StyleSheets(.uss)，此外還可以安裝以下的package增加額外的功能 com.unity.vectorgraphics：讓你可以將VectorImage指定為元素(element)的background style com.unity.2d.sprite：讓你可以將 2D Sprite asset(或sub-asset)指定為元素的background style。安裝了此套件後，還可以直接從Inspector窗格中打開2D Sprite編輯器。 選擇 Window -&gt; UI Toolkit -&gt; UI Builder便可開啟UI Builder畫面 StyleSheets：讓你編輯目前UI Document(UXML)的StyleSheets(USS) Hierarchy：顯示目前UI Document的element結構樹 在這個Hierarchy中顯示的是element的name attribute，如果這個element沒有name則顯示它的C# type Library：顯示目前可以使用的elements，其中Standard為Unity內建的elements；Project則為專案中自訂的element (.uxml assets以及繼承VisualElement並有在UxmlFactory設定可以被UXML實體化的C# element )。 Viewport：會顯示UI Document (UXML) 的畫面，並會儲存目前UI Document (UXML)的平移(pan)和縮放(zoom)狀態 使用滑鼠中鍵(Middle-click)，或是使用Ctrl/Cmd + Alt/Option + 滑鼠左鍵可以拖動Viewport。 使用滑鼠滾輪可以縮放Viewport。 UXML Preview與USS Preview：此處可以預覽UI Builder產生的UXML與USS Inspector：與Unity原有的Inspector類似，根據選擇的element顯示對應的設定內容 下一篇：UI-Builder-2-（開始使用UI-Builder）","link":"/2024/04/08/UI-Builder/"},{"title":"Unity Extensible Markup Language(UXML)","text":"UXML啟發於HTML，XAML與XML，它定義並保存了UI的結構，可以使用Inline Style或是透過Unity Style Sheet來更改UI的風格(Style)。 UXML使用了類似樹狀的結構來保存UI，它存在父子關係(parent-child relationships)以及一個根元素(root element) 以下是UXML的範例 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;UXML ...&gt; &lt;Box&gt; &lt;Toggle name=&quot;boots&quot; label=&quot;Boots&quot; value=&quot;false&quot; /&gt; &lt;Toggle name=&quot;helmet&quot; label=&quot;Helmet&quot; value=&quot;false&quot; /&gt; &lt;Toggle name=&quot;cloak&quot; label=&quot;Cloak of invisibility&quot; value=&quot;false&quot;/&gt; &lt;/Box&gt; &lt;Box&gt; &lt;Button name=&quot;cancel&quot; text=&quot;Cancel&quot; /&gt; &lt;Button name=&quot;ok&quot; text=&quot;OK&quot; /&gt; &lt;/Box&gt;&lt;/UXML&gt; UXML declaration：在上面範例的第一行，是UXML declaration，它是可選的， 如果你使用UXML declaration的話，必須把它放在第一行， 使用UXML declaration的話，必須為它設定version； encoding則是可選的，但是如果使用encoding的話，必須指定它的編碼。 Document root：&lt;UXML&gt;為文件的根element，在此定義namespace與schema definition files的位置。 Namespace：在UI Toolkit中每個element的Namespace不是在UnityEngine.UIElements就是在UnityEditor.UIElements。 UnityEngine.UIElements：此命名空間下的elements會作為Unity runtime時的一部分 UnityEditor.UIElements：此命名空間下的elements可在Unity Editor使用 在使用時，你可以指定element的namespace，例如：&lt;UnityEngine.UIElements:Button /&gt; 或是在UXML declaration中指定它的prefix，如xmlns:engine=&quot;UnityEngine.UIElements&quot;，在使用時會變為&lt;engine:Button /&gt; 注意：不要把自訂的control class放到UnityEngine.UIElements與UnityEditor.UIElements不然UI Builder會把你自訂的control隱藏。 Schema definition：它指定了每個UXML element可以包含哪些attributes和子element。 所有Element都會繼承VisualElement，這個VisualElement提供了以下attributes name: 用來辨認這個element，它的名稱應該要唯一。 picking-mode: 設定為Position表示可以回應滑鼠事件，設定為Ignore表示忽略滑鼠事件 focus-index: (OBSOLETE過時了) Use tabIndex and focusable. tabindex: 一個整數，定義這個element的tabbing position focusable: 一個Boolean，表示這個element是focusable. class: 類似HTML的class，你可以為特定的element加上class，讓它們應用到指定的style；你也可以把它當做篩選element的工具，透過UQuery來找到特定class的elements。 tooltip: 當滑鼠指到該element時，會顯示提示字串 view-data-key : 一個字串，作為element序列化(serialization)時使用的Key 使用Unity建立UXML： 選擇Asset -&gt; Create -&gt; UI Toolkit -&gt; UI Document 預設它會幫你建立一個noNamespaceSchemaLocation 123&lt;ui:UXML xmlns:ui=&quot;UnityEngine.UIElements&quot; xmlns:uie=&quot;UnityEditor.UIElements&quot; xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; engine=&quot;UnityEngine.UIElements&quot; editor=&quot;UnityEditor.UIElements&quot; noNamespaceSchemaLocation=&quot;../../UIElementsSchema/UIElements.xsd&quot; editor-extension-mode=&quot;False&quot;&gt;&lt;/ui:UXML&gt; Reference: https://docs.unity3d.com/Manual/UIE-WritingUXMLTemplate.html","link":"/2024/04/09/UXML/"},{"title":"Unity Rigidbody","text":"Rigidbody（剛體）component：可將Rigidbody應用到你的遊戲物件(GameObject)上，讓這個GameObject可以被物理的方式控制，也將是說讓這個GameObject可以被physics forces(物理力，如推力，阻力等) 與 torque(扭力)作用。 另外在2D遊戲中，則是使用Rigidbody2D component它只會做用在2D環境，也就是說只能在XY plane上作用。 參數簡介 Body Type(Rigidbody2D) Dynamic（動態，預設值） 運動時受力影響，並且接受完全的物理模擬，包括重力、碰撞、施加力等，最耗效能。 Kinematic（運動學） 不受力影響但可移動，其運動行爲是被我們開發者完全限定的，可以碰撞，沒有設定質量(Mass)的參數 只會與Dynamic2D碰撞 Static（靜態） 不受力影響也不會動，會與動態類型剛體碰撞，最不消耗效能。 Mass：質量，預設為千克，質量越大慣性越大，質量越大越不容易被別的物體推動 Drag：空氣阻力，根據移動物件時影響物件的空氣阻力大小，0表示沒有空氣阻力 Angular Drag：根據樞紐旋轉物件時影響物件的空氣阻力大小，0表示沒有空氣阻力 Use Gravity：是否受重力影響 Is Kinematic：如果啟用此選項，則物件不會被物理引擎驅動，只能透過Transform對其進行操作， 對於移動平台，或者如果要動畫化附加了HingeJoint的剛體，此屬性非常有用 Interpolate：插值運算，讓剛體物體移動更平滑 None：不使用 Interpolate：根據前一幀的變換來平滑變換 Extrapolate：根據下一幀估計的變換來平滑變換 Collision Detection：碰撞檢測，用於防止快速移動的物體其他物體而不檢測碰撞 Discrete：預設值，離散檢測， 最不耗效能的檢測， 對場景中所有其他碰撞體使用離散碰撞檢測， 用於一般碰撞。 可能會出現當物體移動太快造成偵測不到與其他物體碰撞。 Continuous：連續檢測， 對動態碰撞體(具有剛體)，使用離散檢測 對靜態碰撞體(沒有剛體)，使用連續檢測 對於所有其他剛體碰撞使用離散檢測 較消耗物理效能 Continuous Dynamic：連續動態檢測 對動態碰撞體(具有剛體)與靜態碰撞體(沒有剛體)都使用連續碰撞檢測 對於所有其他剛體碰撞使用離散檢測 用於快速移動的物體 Continuous Speculative：連續推測檢測 對剛體和碰撞體使用推測性連續碰撞檢測， 一般比Continuous Dynamic的成本低 Constraints：約束，對剛體運動的限制 Freeze Position：有選擇地停止剛體沿世界X, Y, 和 Z軸的移動 Freeze Rotation：有選擇地停止剛體圍繞局部X, Y, 和 Z軸的轉動 Collision Detection的效能消耗為Continuous Dynamic &gt; Continuous Speculative &gt; Continuous &gt; Discrete 無剛體 Discrete Continuous Continuous Dynamic Continuous Speculative 無剛體 不檢測碰撞 Discrete Continuous Continuous Continuous Speculative Discrete Discrete Discrete Discrete Discrete Continuous Speculative Continuous Continuous Discrete Discrete Continuous Continuous Speculative Continuous Dynamic Continuous Discrete Continuous Continuous Continuous Speculative Continuous Speculative Continuous Speculative Continuous Speculative Continuous Speculative Continuous Speculative Continuous Speculative","link":"/2024/04/03/Unity-Rigidbody/"},{"title":"Unity Style Sheet (USS)","text":"USS檔案以.uss為副檔名，它是一個文字檔，可以定義UI共用的風格(style)，讓App更容易管理整體的風格。一個USS會包含以下 Style rules：一個style rule會有一個selector與一個declaration block。 Selector定義了哪些visual element會應用這個style rule Declaration block：使用角括弧(curly braces)，在其中可以定義多個style。 每個sytle都會有一個property與value，並在結尾要加上一個分號(semi-colon) 句法如下 1234selector { property1: value; property2: value;} 例子 123Button { width: 200px;} Type selector：會挑選符合對應C#或是visual element type的elements1234Button { border-radius: 8px; width: 100px; } 注意以下是不合法的Type selector 123UnityEngine.UIElements.Button { ... } Class selector：會挑選有指定該USS class的elements。在class的命名中： 在名字中不要有英文句號 假設一個class名為yellow.button，在建立USS規則(USS rule)的話會這樣使用.yellow.button{...}，這樣會被當成yellow和button兩個class 不可以以數字作為開頭 class名稱是大小寫敏感的(case-sensitive) 在USS中，class selector要以英文句號 . (period)開頭 在UXML中，只需設定class名稱，如：class=&quot;yellow&quot;即可 下面定義了一個 yellow class selector rule，注意它前面有一個英文句號(period)， 123.yellow { background-color: yellow;} 在UXML中要使用的話，使用class=&quot;名稱&quot;例如：&lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; 一個簡單的例子如下： 12345678&lt;UXML xmlns=&quot;UnityEngine.UIElements&quot;&gt; &lt;VisualElement name=&quot;container1&quot;&gt; &lt;VisualElement name=&quot;container2&quot; class=&quot;yellow&quot;&gt; &lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; &lt;Button name=&quot;Cancel&quot; text=&quot;Cancel&quot; /&gt; &lt;/VisualElement&gt; &lt;/VisualElement&gt;&lt;/UXML&gt; Name selector：會挑選name相符合的elements。(有點類似CSS中的ID selector)。name的使用： 為element設定name的方式有兩種 在C# script中使用 VisualElement.name 在UXML中使用 name 屬性，例如：&lt;VisualElement name=&quot;my-nameName&quot;&gt;. 為了避免意外，name必須唯一。 在USS中，name selector需要以 #(number sign) 開頭 例如#ElementName { ... } 在UXML中，只需設定class名稱，如：name=&quot;my-nameName&quot;即可 `&lt;Button name=&quot;#OK&quot; /&gt;`這個是不合法的。 下面定義一個name為Cancel的name selector rule 12345#Cancel { border-width: 2px; border-color: DarkRed; background-color: pink;} 在UXML中使用的話，使用name=&quot;名稱&quot;例如：&lt;Button name=&quot;Cancel&quot; text=&quot;Cancel&quot; /&gt; 12345678&lt;UXML xmlns=&quot;UnityEngine.UIElements&quot;&gt; &lt;VisualElement name=&quot;container1&quot;&gt; &lt;VisualElement name=&quot;container2&quot; class=&quot;yellow&quot;&gt; &lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; &lt;Button name=&quot;Cancel&quot; text=&quot;Cancel&quot; /&gt; &lt;/VisualElement&gt; &lt;/VisualElement&gt;&lt;/UXML&gt; Universal selector：也稱為wildcard selector，它會匹配所有的element。以 * (asterisk)為Universal selector 下面定義一個Universal selector 123* { background-color: yellow;} 以下的UXML的所有element都會應用這個background-color: yellowstyle 12345678&lt;UXML xmlns=&quot;UnityEngine.UIElements&quot;&gt; &lt;VisualElement name=&quot;container1&quot;&gt; &lt;VisualElement name=&quot;container2&quot; class=&quot;yellow&quot;&gt; &lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; &lt;Button name=&quot;Cancel&quot; text=&quot;Cancel&quot; /&gt; &lt;/VisualElement&gt; &lt;/VisualElement&gt;&lt;/UXML&gt; Descendant selector：會在visual tree中選出匹配的後代elements。注意，使用這個selector比較消耗效能語法如下： 1selector1 selector2 {...} 例子：這個例子會選擇#container1之下含有yellow class的所有child elements。 1234#container1 .yellow { background-color: yellow;} 在UXML中的設定如下，#container1有一個child element，#container2有class=&quot;yellow&quot;， 123456789&lt;UXML xmlns=&quot;UnityEngine.UIElements&quot;&gt; &lt;VisualElement name=&quot;container1&quot;&gt; &lt;VisualElement name=&quot;container2&quot; class=&quot;yellow&quot;&gt; &lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; &lt;Button name=&quot;Cancel&quot; text=&quot;Cancel&quot; /&gt; &lt;/VisualElement&gt; &lt;/VisualElement&gt;&lt;/UXML&gt; 結果如下圖，#container2與#OK以及#Cancel的背景色都被改變了，但#container1的背景沒有被改變 Child selector：會在visual tree中選出匹配的child elements。語法如下： 1selector1 &gt; selector2 {...} 例子：這個例子會選擇#container1的child中含有yellow class的所有child elements。 1234#container1 &gt; .yellow { background-color: yellow;} 在UXML中的設定如下， 12345678&lt;UXML xmlns=&quot;UnityEngine.UIElements&quot;&gt; &lt;VisualElement name=&quot;container1&quot;&gt; &lt;VisualElement name=&quot;container2&quot; class=&quot;yellow&quot;&gt; &lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; &lt;Button name=&quot;Cancel&quot; text=&quot;Cancel&quot; /&gt; &lt;/VisualElement&gt; &lt;/VisualElement&gt;&lt;/UXML&gt; 這個的child selector style rule 只會匹配到#container2， 這是因為#container2為#container1的child element，並且含有yellow class。 而#OK與#Cancel不匹配的原因是因為它們是屬於#container2的child而不直接的屬於#container1的child，所以匹配不到。 你也可以把wildcard selector使用在這些複雜的selector，例如以下這個selector rule，它會找出yellow class下的所有Button element 1.yellow &gt; * &gt; Button{..} Multiple selector：Multiple selector是組合多個simple selector它會選出符合simple selector的elements。以下是語法 1selector1selector2 {...} 如果Multiple selector區分不出selector的話，會把它們當作一個，例如ListView與Button這兩個type selector，若想使用Multiple selector會變成下面這樣 1ListViewButton{...} USS parser無法辨識出它是兩個selector，會把它當作一個ListViewButton。因為Class與Name selector有一個前綴詞(分別是.與#)，所以可以辨認出來，而Type selector沒有，所以在使用Multiple selector若是想要用Type selector的話，Type selector必須放到第一個。 1ListView.yellow#vertical-list{...} 在下面這個例子中，最後會選出來的是&lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; 123Button.yellow { background-color: yellow;} 12345678&lt;UXML xmlns=&quot;UnityEngine.UIElements&quot;&gt; &lt;VisualElement name=&quot;container1&quot;&gt; &lt;VisualElement name=&quot;container2&quot; class=&quot;yellow&quot;&gt; &lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; &lt;Button name=&quot;Cancel&quot; text=&quot;Cancel&quot; /&gt; &lt;/VisualElement&gt; &lt;/VisualElement&gt;&lt;/UXML&gt; Reference: https://docs.unity3d.com/Manual/UIE-about-uss.html","link":"/2024/04/09/Unity-Style-Sheet-USS/"},{"title":"Unity架構分層","text":"將專案分為四層 表現層：為ViewController 或是 MonoBehaviour腳本，在這一層主要與顯示相關 表現邏輯：指的是當Model資料變更之後，View顯示更新之後的資料，即Model -&gt; View；可以使用呼叫方法，委託，事件三種方式完成。 交互邏輯：為接收使用者輸入之後改變Model資料，即View -&gt; Model；可以使用Command pattern減輕Controller的負擔，注意：command是沒有狀態的，他類似一個方法，呼叫之後就不用了 Model層：管理資料，提供資料的增刪改查 Utility層：工具層，提供一些共用的工具，如資料儲存、網路連接、藍芽、序列化與反序列化等 System層：系統層，提供API且有狀態的物件，例如藍芽服務，計時器服務，網路服務等 這四層的交互 表現層改變Model層與System層的狀態會使用Command， System層與Model層通知表現層使用事件或是委託， 表現層查詢狀態時可以直接獲取System層和Model層 。 一般，表現層不會訪問到Utility層，Utility層也不會通知表現層","link":"/2024/02/05/Unity%E5%88%86%E5%B1%A4/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/02/05/hello-world/"},{"title":"Unity使用NuGet","text":"在Visual Studio下有方便的NuGet package manager 管理套件，所以可以很方便的安裝和管理NuGet套件，但是對Unity C# 專案來說，就不能直接使用NuGet package manager來管理套件。 幸好有第三方管理套件，NuGetForUnity 可以使用。 以下說明它的使用方式 進入Releas找到的它的unitypackage檔案下載（目前是NuGetForUnity.4.0.2.unitypackage這個版本）。 將下載好的unitypackage檔案拖入你的專案，按下import，便會開始匯入(import) NuGetForUnity到你的專案中。 之後你就可以在上方選單找到NuGet了","link":"/2024/04/01/Unity%E4%BD%BF%E7%94%A8NuGet/"},{"title":"JavaScript 事件傳遞(Event Bubbling)","text":"HTML結構HTML DOM elements是嵌套(nested)的結構，如下： 12345&lt;div onclick=&quot;alert('點擊最外層');&quot;&gt;First // 最外層 &lt;div onclick=&quot;alert('點擊第二層');&quot;&gt;Second &lt;div onclick=&quot;alert('點擊最內層');&quot;&gt;Third&lt;/div&gt; // 最內層 &lt;/div&gt;&lt;/div&gt; Event Bubbling使用JavaScript可以對HTML DOM element註冊(register)一些不同的event handlers，Event bubbling是HTML DOM API中事件傳播(event propagation)的一種方式。 Bubbling事件傳播的方式為：從事件發生的地方開始一層一層的向最外層傳遞 下面的例子（可以用滑鼠點點看）： 最外層 第二層 最內層 1234567891011&lt;div onclick=&quot;alert('點擊最外層');&quot; style=&quot;background: red; border: 3px dotted black; text-align: center; width: 400px;&quot;&gt; 最外層 &lt;br /&gt; &lt;div onclick=&quot;alert('點擊第二層');&quot; style=&quot;background: green; border: 4px dotted black; text-align: center; width:300px;&quot;&gt; 第二層 &lt;br /&gt; &lt;div onclick=&quot;alert('點擊最內層');&quot; style=&quot;background: blue; border: 5px dotted black; text-align: center; width: 250px;&quot;&gt; &lt;font color=&quot;white&quot;&gt;最內層&lt;/font&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 當你點下（也就是觸發onclick事件）最裡面藍色的那一層的時候，會彈出點擊最內層的字串，然後再彈出點擊第二層的字串，最後再彈出點擊最外層的字串。這就是Bubbling事件傳播 停止Event Bubbling有時候會想要停止bubbling傳遞事件，可以透過以下的方式來停止， event.stopPropagation(); event.cancelBubble = true; // IE&lt;9 例如下面的例子（可以用滑鼠點點看）： function disableBubbling(){ alert('點擊了' + event.srcElement.className); event.stopPropagation(); } 最外層 第二層 最內層 123456789101112131415&lt;script&gt;function disableBubbling(){ alert('點擊了' + event.srcElement.className); event.stopPropagation();}&lt;/script&gt;&lt;div class=&quot;最外層&quot; onclick=&quot;disableBubbling();&quot; style=&quot;background: red; border: 3px dotted black; text-align: center; width: 400px;&quot;&gt; 最外層&lt;br /&gt; &lt;div class=&quot;第二層&quot; onclick=&quot;disableBubbling();&quot; style=&quot;background: green; border: 4px dotted black; text-align: center; width: 300px;&quot;&gt; 第二層&lt;br /&gt; &lt;div class=&quot;最內層&quot; onclick=&quot;disableBubbling();&quot; style=&quot;background: blue; border: 5px dotted black; text-align: center; width: 250px;&quot;&gt; &lt;font color=&quot;white&quot;&gt;最內層&lt;/font&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;","link":"/2024/04/18/%E4%BB%80%E9%BA%BC%E6%98%AFbubbling%EF%BC%9F/"},{"title":"使用Action","text":"有兩種方式回應Action Polling(輪詢)：Polling方法是不斷的檢查你感興趣Action目前的狀態，通常會在MonoBehaviour script中的Update()方法去做輪詢。 Event-driven(事件驅動)：Event-driven則是建立要執行的方法，當Action執行時，就會自動呼叫並執行。 Polling在大部分的場景，特別是動作遊戲，使用者的輸入必須平滑順暢的控制遊戲中的角色，使用Polling通常是比較容易去實作。 使用InputAction提供的ReadValue&lt;&gt;()便可以取得目前Action的值 12345678910111213141516171819using UnityEngine;using UnityEngine.InputSystem;public class Example : MonoBehaviour{ InputAction moveAction; private void Start() { moveAction = InputSystem.actions.FindAction(&quot;Move&quot;); } void Update() { // 取得action的值 Vector2 moveValue = moveAction.ReadValue&lt;Vector2&gt;(); // 取得值之後，便可以將其應用到GameObject上，讓其移動。 }} 方法 描述 InputAction.WasPerformedThisFrame() 在當前幀的任何時間點，如果這個Action在InputAction.phase曾經變為「已執行」(Performed)，則為True。 InputAction.WasCompletedThisFrame() 在當前幀的任何時間點，如果這個Action在InputAction.phase曾經從「已執行」(Performed)更改為任何其他階段(phase)，則為True。這對於按鈕那些具有「按下」(Press) 或「按住」(Hold)等動作非常有用，當按住時，返回的為False。Pass-Through 以下程式碼使用了預設的Interact Action，它包含一個「按住」(Hold)交互(interaction)，使得只有綁定的控件被按住一段時間 (例如 0.4 秒) 後才會執行該動作。 12345678910111213141516171819202122232425using UnityEngine;using UnityEngine.InputSystem;public class Example : MonoBehaviour{ InputAction interactAction; private void Start() { interactAction = InputSystem.actions.FindAction(&quot;Interact&quot;); } void Update() { if (interactAction.WasPerformedThisFrame()) { // 在此執行的程式碼滿足：Interact action按住足夠長時間的第一幀 } if (interactAction.WasCompletedThisFrame()) { // 在此執行的程式碼滿足：Interact action被按住足夠長時間後釋放的那一幀 } }} 以下方法可以用來輪詢按鈕是否被按下或是釋放 方法 描述 InputAction.IsPressed() 如果Action的「動作水平(the level of actuation)」已經超過「按下壓力點(press point)」，並且尚未下降或低於「釋放臨界點(release threshold)」，則為True。 InputAction.WasPressedThisFrame() 如果Action的「動作水平(the level of actuation)」在當前幀的任何時間點達到或超過「按下壓力點(press point)」，則為True。 InputAction.WasReleasedThisFrame() 如果Action的「動作水平(the level of actuation)」在當前幀的任何時間點，在「按下壓力點(press point)」以上或是或低於「釋放臨界點(release threshold)」，則為True。 以下範例有三個Actions，分別為Shield，Teleport與Submit(它們不是預設的action) 123456789101112131415161718192021222324252627282930313233using UnityEngine;using UnityEngine.InputSystem;public class Example : MonoBehaviour{ InputAction shieldAction; InputAction teleportAction; InputAction submitAction; private void Start() { shieldAction = InputSystem.actions.FindAction(&quot;Shield&quot;); teleportAction = InputSystem.actions.FindAction(&quot;Teleport&quot;); submitAction = InputSystem.actions.FindAction(&quot;Submit&quot;); } void Update() { if (shieldAction.IsPressed()) { // shield會在shield action被按下的每一幀都處於激活狀態 if (teleportAction.WasPressedThisFrame()) { // teleport會在 按下動作的第一幀 發生，直到 按鈕釋放 後才會再次生效。 } if (submit.WasReleasedThisFrame()) { // submit會在 動作釋放的幀 發生，這是一種常用于 UI 控制按鈕的常見技巧。 } }} Event-driven可以為Action註冊一些callback，當某些輸入發生時，Action就會通知你，讓你可以做出相應的回應。有以下方式可以使用callback 透過PlayerInput Component註冊callback 使用Action的started，performed與canceled callback 使用ActionMap的actionTriggered callback 使用Input System的全域InputSystem.onActionChange callback InputActionTrace可以記錄Actions上的改變 PlayerInput Component使用PlayerInput component可以在inspector中直接設定callback。此外也可以透過程式碼來設定 Phase(階段) 描述 Disabled 此Action已停用且無法接收輸入 Waiting 此Action已啟用且等待輸入 Started Input System已接收到輸入並開始與Action互動 Performed 與Action的互動已經完成 Canceled 與Action的互動已經被取消 Action callbacks可以透過 InputAction.phase 來取得目前的階段，Started，Performed與Canceled階段各有與之關聯的callback函數 12345var action = new InputAction();action.started += context =&gt; {/* Action已經開始 */};action.performed += context =&gt; {/* Action已經執行 */};action.canceled += context =&gt; {/* Action已經取消 */}; 每個callback都會接收一個InputAction.CallbackContext結構，該結構包含上下文信息，您可以利用它來查詢Action的當前狀態，以及讀取觸發該動作的裝置控制的值。 注意：此結構的內容只在callback期間中有效，請勿把它暫存並在callback之外使用。 callback函數的觸發時機和方式取決於綁定中存在的交互 (Interactions)。如果綁定沒有適用的交互，則會應用預設的交互(Default Interaction)。 除了監聽個別Action，你也可以使用InputActionMap.actionTriggered監聽該Map中的全部Action，使用這種方式，該單一個callback會收到started，performed與canceled，且其InputAction.CallbackContext結構與使用個別started，performed與canceled的結構相同。 123456var actionMap = new InputActionMap();actionMap.AddAction(&quot;action1&quot;, &quot;&lt;Gamepad&gt;/buttonSouth&quot;);actionMap.AddAction(&quot;action2&quot;, &quot;&lt;Gamepad&gt;/buttonNorth&quot;);actionMap.actionTriggered += context =&gt; { ... }; InputSystem.onActionChange與InputSystem.onDeviceChange類似，讓你可以全域(globally)監聽任何與Action相關的變更 12345678910111213InputSystem.onActionChange += (obj, change) =&gt; { // obj可能是InputAction或是InputMap，需要依靠change去判斷 switch (change) { case InputActionChange.ActionStarted: case InputActionChange.ActionPerformed: case InputActionChange.ActionCanceled: Debug.Log($&quot;{((InputAction)obj).name} {change}&quot;); break; } } InputActionTrace，你可以使用InputActionTrace為某些特定Action集合建立日誌(log)，讓你可以追蹤它們。 注意：InputActionTrace會使用不受管理的記憶體，因此在使用後要去處理(disposed)它，避免造成記憶體洩漏(memory leak) 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 實體化一個 InputActionTracevar trace = new InputActionTrace();// 為這個Action訂閱trace。// 取消訂閱的話，使用UnsubscribeFrom方法trace.SubscribeTo(myAction);// 為整個Action Map訂閱trace// 取消訂閱的話，使用UnsubscribeFrom方法trace.SubscribeTo(myActionMap);// 為所有在系統中的Action訂閱tracetrace.SubscribeToAll();// 為這個Action紀錄一個觸發myAction.performed += ctx =&gt; { if (ctx.ReadValue&lt;float&gt;() &gt; 0.5f) trace.RecordAction(ctx); };// 輸出這個traceDebug.Log(string.Join(&quot;,\\n&quot;, trace));// 拜訪所有Action的trace紀錄，之後清除trace。foreach (var record in trace){ Debug.Log($&quot;{record.action} was {record.phase} by control {record.control}&quot;); // 讀取這個紀錄的值，你需要知道它的類型是什麼，否則你可以把它讀為一般的Byte。此處假設他是float Debug.Log(&quot;Value: &quot; + record.ReadValue&lt;float&gt;()); // 如果願意接受GC負擔，也可以將值讀取為物件(object)。 // 此時，你可以不需要知道它的類型 Debug.Log(&quot;Value: &quot; + record.ReadValueAsObject());}trace.Clear();// 取消所有追蹤的訂閱。trace.UnsubscribeFromAll();// 釋放trace使用的記憶體trace.Dispose(); 一旦紀錄完成，只要不同時進行寫入操作，並且主線程上不會同時變更Action設置，則trace可以安全地從多個線程讀取。 Action typesAction有三種類型，這些類型會影響Input System如何處理操作Action的狀態。 Action Type 描述 Value 預設的Action Type。適用於任何需要追踪控制項(Control)狀態連續變化的輸入。Value action Type 會持續監控所有綁定到該動作(Action)的控制項(Control)，然後選擇最活躍(actuated)的控制項作為驅動該動作的控制項，並在值發生變化時觸發回調函式(callback)報告該控制項的值。如果另一個綁定控制項的活躍程度更高，那麼該控制項就會成為驅動動作的控制項，動作會開始報告該控制項的值。這個過程稱為 衝突解決 (conflict resolution)。如果您希望允許遊戲中不同的控制項控制一個動作，但僅同時從一個控制項接收輸入，那麼這將非常有用。當動作(action)首次啟用時，它會對所有綁定控制項(Control)執行 初始狀態檢查(initial state check)。如果任何一個控制項被激活，則動作會觸發一個回調，傳遞當前值。 Button Button類型非常類似於Value類型，但有以下幾點不同：Button類型的動作只能綁定到「按鈕控制項」(ButtonControl)。與Value類型的動作不同，Button類型的動作不會執行初始狀態檢查。「按鈕」類型的動作適用於每次按下時觸發一次操作的輸入。在這種情況下，初始狀態檢查通常沒有用，因為它可能會在啟用動作時，因之前按住按鈕而觸發動作 (即按鈕仍然處於按下狀態)。 PassThrough PassThrough類型的動作與上面描述的Value動作不同，它繞過了衝突解決。PassThrough類型的動作不會選擇一個特定的控制項作為驅動動作的來源。 相反，任何綁定的控制項會變更都會觸發一個回調，並將該控制項的目前值傳遞給回調函數。PassThrough類型的動作適用於您想要處理來自一組控制項的所有輸入的情況。 使用Input Debugger，可以觀察目前啟用的Action以及與他們綁定的Control。也可以使用InputActionVisualizer在螢幕上即時可視化動作的值和交互狀態。 上一篇：Actions概念 Reference: https://docs.unity3d.com/Packages/com.unity.inputsystem@1.8/manual/RespondingToActions.html","link":"/2024/04/26/%E4%BD%BF%E7%94%A8Action/"},{"title":"事務( Transaction )","text":"事務(Transaction)事務或是交易(Transaction)是指資料庫中邏輯上的一系列操作(operation)，這組操作要就全部成功，要就全部不成功。 start transaction;或是begin;：為開啟事務，在這條SQL語句之後的SQL都將處於同一個事務中，這些SQL語句不會立刻執行。 commit;：為提交事務，一旦提交，事務中所有的SQL才會執行。 rollback;：回滾事務，回復在此事務內所有的動作。 資料庫如果沒有自己去控制事務，預設是一條SQL就處在自己單獨的事務中。 事務的特性(ACID)原子性(Atomicity)：一個事務中的所有操作，要麼全部完成，要麼全部不完成，不會結束在中間某個環節。事務在執行過程中發生錯誤，會被回滾（Rollback）到事務開始前的狀態，就像這個事務從來沒有執行過一樣。 例如：銀行帳戶存款和取款操作。每次存款或取款操作都應該是原子性的，即要麼全部成功，要麼全部失敗。 用戶A要取款300元。在這個操作中，銀行應該首先檢查用戶A的帳戶餘額是否足夠，然後從帳戶餘額上減去取款金額。這個操作是原子性的，要麼成功從用戶A的帳戶中扣除300元，要麼失敗，不會出現只減少部分金額的情況。 一致性(Consistency)：在事務開始之前和事務結束以後，資料庫的完整性沒有被破壞。這表示寫入的資料必須完全符合所有的預設規則，這包含資料的精確度、串聯性以及後續資料庫可以自發性地完成預定的工作。簡單來說就是在事務前後，資料必須保持一致，但在過程中不一定會保持一致性。 例如：A將1000元轉帳至B的帳戶，此事務包含兩個步驟， 銀行從A的帳戶中扣除1000元。 銀行將1000元存入B的帳戶中。 在事務前的A與B的帳戶金額總和一定會和事務後的A與B帳戶內的金額總相同 =&gt; 這就是事務前後，資料必須保持一致 但是在各操作時，資料不一致，例如銀行從A的帳戶中扣除1000元這一個操作做完之後，銀行資料庫的金額會處於不一致狀態(少了1000元)，等到第二操作(銀行將1000元存入B的帳戶)之後資料庫才會保持一致性的狀態。 隔離性(Isolation)：資料庫允許多個併發事務同時對其資料進行讀寫和修改的能力，隔離性可以防止多個事務併發執行時由於交叉執行而導致資料數據的不一致。事務隔離分為不同級別，包括 讀未提交（Read uncommitted）：允許讀取其他事務尚未提交的資料。因此，可能發生髒讀、不可重複讀和幻讀。 讀提交（Read committed）：只能讀取已經提交的資料。因此，可能發生不可重複讀和幻讀，但不會發生髒讀。 可重複讀（Repeatable read）：在同一個事務中多次讀取相同資料時，保證資料的一致性。因此，可能發生幻讀，但不會發生髒讀和不可重複讀。 串行化（Serializable）：最高的隔離級別，確保並發事務之間的串行執行，避免任何並發問題。因此，不會發生髒讀、不可重複讀和幻讀。 持久性(Durability)：事務處理結束後，對資料的修改就是永久的，即便系統故障也不會丟失。 事務隔離性導致的問題：髒讀：髒讀發生在一個事務允許讀取另一個事務修改但未提交的資料時。 例如，當一個事務A正在讀取資料並且對資料進行了修改，但這個修改還沒有被提交到資料庫中。此時，另一個事務B可能會讀取到這個未提交的修改，這就是髒讀的情況。 不可重複讀：在一次事務中，當一行資料獲取兩遍得到不同的結果表示發生了「不可重複讀」。例如，在一個事務A中多次讀取同一筆資料，在事務A還未結束時，另一個事務B也訪問了這個資料，並且修改這個資料並且commit，那麼事務A在多次讀取這筆資料時可能會讀到不同的資料。 不可重複讀的重點是修改：同樣的條件，你讀取過的資料，再次讀取出來發現值不一樣了 例如： 在交易A中，使用SELECT語句讀取賬戶餘額為1000元，然後執行其他操作。 在交易B中，進行了一次轉賬操作，將賬戶餘額從1000元減少到900元。 再次在交易A中，使用相同的SELECT語句讀取賬戶餘額，發現餘額為900元，與之前的餘額不一致。 這是因為在兩次讀取之間，資料表中的資料已經被修改 幻讀：在事務執行過程中，當兩個完全相同的查詢語句執行得到不同的結果集。這種現象稱為「幻讀（phantom read）」。 幻讀的重點在於新增或者刪除：同樣的條件，第1次和第2次讀出來的記錄數目不一幻讀。 例如：目前工資為1000的員工有10人。 使用 SELECT count(*) FROM employee WHERE salary=1000; SQL，讀取所有工資為1000的員工。 事務A，讀取所有工資為1000的員工，共讀取到了10條記錄。 這時事務B向employee表插入了一條員工記錄，工資也為1000 事務A，使用相同的SQL再次讀取所有工資為1000的員工，此時共讀取到了11條記錄。 隔離級別 髒讀 不可重複讀 幻影讀 未提交讀 可能發生 可能發生 可能發生 提交讀 - 可能發生 可能發生 可重複讀 - - 可能發生 可序列化 - - - 一般情況下，大多數資料庫系統的預設隔離級別是可重複讀（Repeatable Read）。這意味著在同一個事務中，多次讀取相同的資料時，保證資料的一致性，並且防止不可重複讀取的情況發生。","link":"/2024/04/19/%E4%BA%8B%E5%8B%99-Transaction/"},{"title":"使用LiteDB","text":"LiteDB是一個簡單且快速的NoSQL Database，它特色有 輕巧，&lt; 450kb並且完全由.NET C#受控程式碼(managed code)編寫 可以使用NuGet套件管理器安裝 跨平台 單一存放檔案 支援LINQ query 以下是簡易的使用方式 使用NuGet管理套件搜尋LiteDB並安裝 接下來便可以使用LiteDatabase建立或是開啟database 123456string dbPath = @&quot;./MyData.db&quot;;// Open database (or create if doesn't exist)using (var db = new LiteDatabase(dbPath)){ ...} 建立一個POCO class 123456789public class Customer{ public int Id { get; set; } public string Name { get; set; } public int Age { get; set; } public string[] Phones { get; set; } public bool IsActive { get; set; }} 使用 db.GetCollection&lt;Customer&gt;(&quot;customers&quot;) 去取得customer collection collection的Insert方法插入資料 以下是完整的例子（來自LiteDB） 1234567891011121314151617181920212223242526272829303132string dbPath = @&quot;./MyData.db&quot;;// Open database (or create if doesn't exist)using (var db = new LiteDatabase(dbPath)){ // Get customer collection var col = db.GetCollection&lt;Customer&gt;(&quot;customers&quot;); // Create your new customer instance var customer = new Customer { Name = &quot;John Doe&quot;, Phones = new string[] { &quot;8000-0000&quot;, &quot;9000-0000&quot; }, Age = 39, IsActive = true }; // Create unique index in Name field col.EnsureIndex(x =&gt; x.Name, true); // Insert new customer document (Id will be auto-incremented) col.Insert(customer); // Update a document inside a collection customer.Name = &quot;123John Doe212&quot;; col.Update(customer); // Use LINQ to query documents (with no index) var results = col.Find(x =&gt; x.Age &gt; 20);} 以下是方便你操作DB的GUI介面工具 OneBella：跨平台的GUI工具，支援修改和查詢，需要LiteDB 5+ 使用方式非常簡單，進入OneBella的 Release選擇下載對應平台的zip檔案即可 LiteDB.Studio 一樣去Release下載最新版本即可，目前似乎只有Windows版本。","link":"/2024/04/01/%E4%BD%BF%E7%94%A8LiteDB/"},{"title":"使用Hexo Admin","text":"透過 hexo-admin 這套插件，就能透過GUI介面進行後台管理，如新增或編輯markdown文件，簡化了發布文章的流程。 安裝套件 使用終端機，並移動到Hexo專案位置下，之後執行以下指令1$ npm install --save hexo-admin 安裝完成之後，啟動本地端Server就可以進入後台管理，如下 bash $ hexo server -d 進入 http://localhost:4000/admin 可進入後台管理 注意： Hexo Admin已經不維護了","link":"/2024/02/05/%E4%BD%BF%E7%94%A8Hexo-Admin/"},{"title":"使用UQuery來查找element","text":"UQuery受到JQuery與Linq啟發，UQuery被設計為會限制動態記憶體分配(dynamic memory allocation)，讓手機平台上可以擁有最佳化的效能。可以使用Query和Q(Q是Query&lt;T&gt;.First()的縮寫)這兩個extension method來使用UQuery。 Q與Query實際上是使用UQueryBuilder來建構一個query，這些extension method可以減少在建立UQueryBuilder時需要撰寫的模板程式碼。 在使用UQuery之前，你必須要先載入並實體化UXML，然後才能用Q或Query建立選取規則(selection rules) 透過選擇規則返回的elements你還可以使用UQueryBuilder上的First，Last， AtIndex，Children與Where公開方法(public method)來更進一步的過濾它們。 可以透過element的name，USS class，element type (C# type)來找到想要的element。 也可以使用predicate或是組合[複雜結構的query](#Complex hierarchical queries)來找到想要的element UQuery會在初始化時Cache這些選出來的Elements。 UI Toolkit不會自行銷毀沒用到的visual elements，它是使用C# garbage collector 來處理，因此最好不要在UIDocuments或Window之外建立這些elements的引用，避免讓C# garbage collector無法回收。 以下使用一個UXML來說明 1234567891011121314&lt;UXML xmlns=&quot;UnityEngine.UIElements&quot;&gt; &lt;VisualElement name=&quot;container1&quot;&gt; &lt;Button name=&quot;OK&quot; text=&quot;OK&quot; /&gt; &lt;Button name=&quot;Cancel&quot; text=&quot;Cancel&quot; /&gt; &lt;/VisualElement&gt; &lt;VisualElement name=&quot;container2&quot;&gt; &lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; &lt;Button name=&quot;Cancel&quot; text=&quot;Cancel&quot; /&gt; &lt;/VisualElement&gt; &lt;VisualElement name=&quot;container3&quot;&gt; &lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; &lt;Button name=&quot;Cancel&quot; class=&quot;yellow&quot; text=&quot;Cancel&quot; /&gt; &lt;/VisualElement&gt;&lt;/UXML&gt; Query by name語法為： Query(name: &quot;element-name&quot;) 或是 Q(name: &quot;element-name&quot;) ；你也可以省略參數名稱name，直接使用Query(&quot;element-name&quot;) 12// 這句會回傳所有name為OK的element。List&lt;VisualElement&gt; result = root.Query(&quot;OK&quot;).ToList(); 1234// 這句會回傳找到name為OK的第一個element。VisualElement result = root.Query(&quot;OK&quot;).First();// 你也可以直接寫QVisualElement result = root.Q(&quot;OK&quot;); 12// 這句是選name為OK的第二個element（第一個element的index是0）VisualElement result3 = root.Query(&quot;OK&quot;).AtIndex(1); 12// 這句是選name為OK的最後一個elementVisualElement result4 = root.Query(&quot;OK&quot;).Last(); Query by USS class語法為：Query(className: &quot;class-name&quot;) 或是 Q(className: &quot;class-name&quot;) 12// 這句會選出所有class name為yellow的elementList&lt;VisualElement&gt; result = root.Query(className: &quot;yellow&quot;).ToList(); 12// 這句會選class name為yellow的第一個elementVisualElement result = root.Q(className: &quot;yellow&quot;); Query by element type語法為：Query&lt;Type&gt;() 或是 Q&lt;Type&gt;() 注意：你只能使用actual type來選出Element，而不能使用base type。 1234// 這句會選出第一個Button elementVisualElement result = root.Q&lt;Button&gt;();// 將這個button的tooltip更改result.tooltip = &quot;This is a tooltip!&quot;; 12// 這句會選出第三個Button elementVisualElement result = root.Query&lt;Button&gt;().AtIndex(2); Query with a predicate除了可以使用name，class-name，type來選出element以外，還可以搭配Where做更進一步的篩選，Where的參數是一個VisualElement。 12// 這句會選出所有class name為yellow的element，然後在找出tooltip為空字串的elementList&lt;VisualElement&gt; result = root.Query(className: &quot;yellow&quot;).Where(elem =&gt; elem.tooltip == &quot;&quot;).ToList(); Complex hierarchical queries可以將name，class-name，type等組合在一起，做更複雜的選擇。 12// 這句將name，type，class-name做組合，選出class-name為yellow，name為OK的Button elementVisualElement result = root.Query&lt;Button&gt;(className: &quot;yellow&quot;, name: &quot;OK&quot;).First(); 12// 這句將選出container2中所有name為Cancel的Button elementVisualElement result = root.Query&lt;VisualElement&gt;(&quot;container2&quot;).Children&lt;Button&gt;(&quot;Cancel&quot;).First();","link":"/2024/04/12/%E4%BD%BF%E7%94%A8UQuery%E4%BE%86%E6%9F%A5%E6%89%BEelement/"},{"title":"使用grep在多個檔案中找出含有某個字串的檔案","text":"有時候會想在很多個檔案中找出是否含有某個字串，這時可以使用grep 會找 /etc/ 目錄下檔案內容含有 like 的檔案，例如：like與liked。 1grep -nr &quot;like&quot; /etc/ 會找 /etc/目錄下檔案內容含有 like 單字 的檔案，與上面的差異為加上-w之後，只匹配單詞like，而不是像liked這樣的子字串。 1grep -rnw '/like' /etc/ 加上-i之後，會忽略大小寫。可以匹配到LIKE，Liked，或是like…等 1grep -rni '/like' /etc/ 以下是常用的參數 12345-n 會印出關鍵字在檔案的行數-r 會遞迴的找子資料夾-w 只匹配一個單字-y 忽略大小寫-i 忽略大小寫","link":"/2024/04/19/%E4%BD%BF%E7%94%A8grep%E5%9C%A8%E5%A4%9A%E5%80%8B%E6%AA%94%E6%A1%88%E4%B8%AD%E6%89%BE%E5%87%BA%E5%90%AB%E6%9C%89%E6%9F%90%E5%80%8B%E5%AD%97%E4%B8%B2%E7%9A%84%E6%AA%94%E6%A1%88/"},{"title":"依賴(dependency)","text":"依賴（Dependency）：通常指的是一個類別依賴於另一個類別或介面來完成其功能。 依賴使得類別之間的耦合度增加，讓系統變得難以維護和測試。 依賴關係的方向性可以分為單向依賴(Unidirectional Dependency)和雙向依賴(Bidirectional Dependency)。 單向依賴(Unidirectional Dependency)：是指一個類別或模組依賴於另一個類別或模組，但相反的依賴關係不存在。這種依賴關係是單向的，即依賴的方向是單一的，這種依賴的程式碼較容易維護和擴展。 在下面例子中，Car 類別依賴於 Engine 類別，但 Engine 類別並不依賴 Car 類別。這就是一個單向依賴的例子。12345678910111213141516171819202122public class Engine{ public void Start() { Console.WriteLine(&quot;Engine started.&quot;); }}public class Car{ private Engine _engine; public Car(Engine engine) { _engine = engine; } public void Start() { _engine.Start(); }} 雙向依賴(Bidirectional Dependency)：是指兩個類別或模組互相依賴，形成了雙向的依賴關係。這種依賴關係會增加系統的耦合度，使得程式碼難以維護和測試。 通常在設計中應該盡量避免雙向依賴，或者使用依賴注入和接口等技術來減少耦合度。 在這個例子中，Engine 類別依賴於 Car 類別，並且 Car 類別也依賴於 Engine 類別，形成了雙向依賴。這種設計會使得類別之間的關係變得複雜，難以維護和測試。1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Engine{ private Car _car; public Engine(Car car) { _car = car; } public void Start() { Console.WriteLine(&quot;Engine started.&quot;); _car.NotifyEngineStarted(); }}public class Car{ private Engine _engine; public Car() { _engine = new Engine(this); } public void Start() { _engine.Start(); } public void NotifyEngineStarted() { Console.WriteLine(&quot;Car notified: Engine started.&quot;); }}public class Program{ public static void Main(string[] args) { Car car = new Car(); car.Start(); }}","link":"/2024/05/25/%E4%BE%9D%E8%B3%B4-dependency/"},{"title":"合成並發送事件(Synthesize and send events)","text":"事件系統使用一個事件池(pool of events)，以避免重複分配事件物件(event object)。要合成並發送自己的事件需要： 建立一個UnityEngine.Event用來持有初始化的資料 從事件池中獲取一個事件物件。 填寫事件的屬性(event properties)。 將事件封裝在using區塊中，以確保它被返回到事件池。 將事件傳遞給panel.visualTree.SendEvent()。 下面的例子中會發送一個KeyDownEvent 1234567891011121314151617void SynthesizeAndSendKeyDownEvent(IPanel panel, KeyCode code, char character = '\\0', EventModifiers modifiers = EventModifiers.None){ // 建立一個UnityEngine.Event用來持有初始化的資料 var evt = new Event() { type = EventType.KeyDownEvent, keyCode = code, character = character, modifiers = modifiers }; // 將事件封裝在`using`區塊中，以確保它被返回到事件池 using (KeyDownEvent keyDownEvent = KeyDownEvent.GetPooled(evt)) { panel.visualTree.SendEvent(keyDownEvent); }} 注意： 不能發送不是來自OS(operating system)的事件， 不能發送不在UnityEngine.Event types中的事件 某些事件是由UI Toolkit作為對內部狀態變化的反應而發送的，不應由外部過程發送。例如，如果您發送PointerCaptureEvent，visual elements會假定該事件的底層條件已滿足，並且不會為它們設置指針捕獲(pointer capture)。這可能會破壞visual elements的內部配置(configurations)並導致未定義的行為。 Event reference Reference: https://docs.unity3d.com/Manual/UIE-Events-Synthesizing.html","link":"/2024/04/19/%E5%90%88%E6%88%90%E4%B8%A6%E7%99%BC%E9%80%81%E4%BA%8B%E4%BB%B6-Synthesize-and-send-events/"},{"title":"焦點事件(Focus events)","text":"當你需要把焦點移到某個visual element或移開時，可以使用Focus event。 Focus events分為兩種不同的類型： FocusOutEvent與FocusInEvent：在焦點發生變化之前，焦點離開事件（FocusOutEvent）和焦點進入事件（FocusInEvent）會沿著事件傳播路徑(propagation path)發送。 FocusEvent與BlurEvent：焦點事件（FocusEvent）和失焦事件（BlurEvent）會在焦點發生變化後立即發送到事件目標(event target) Event 描述 Trickles down Bubbles up Cancellable FocusOutEvent 在失去焦點之前，會發送一個FocusOutEvent ✔ ✔ FocusInEvent 在element取得焦點之前，會發送一個FocusInEvent ✔ ✔ BlurEvent 在失去焦點之後，會發送一個BlurEvent ✔ FocusEvent 在element取得焦點之後，會發送一個FocusEvent ✔ 專屬於Focus Event的屬性 relatedTarget：在焦點事件中參與的第二個target element。 對於FocusOutEvent與BlurEvent，這個屬性為聚焦的element。 對於FocusInEvent與FocusEvent，這個屬性為失去焦點的element。 Event target relatedTarget BlurEvent 失去焦點的element 取得焦點的element FocusEvent 取得焦點的element 失去焦點的element FocusInEvent 取得焦點的element 失去焦點的element FocusOutEvent 失去焦點的element 取得焦點的element 例子：使用FocusInEvent與FocusOutEvent為TextField實現placeholder text功能 在Assets &gt; Scripts &gt; Editor 下建立一個 C# Script PlaceHolderExample.cs 將以下程式碼複製到剛剛建立的C# Script中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using UnityEditor;using UnityEngine;using UnityEngine.UIElements;public class PlaceHolderExample : EditorWindow{ // 這個Attributes會在 Windows -&gt; UI Tollkit 下加入一個 PlaceHolderExample [MenuItem(&quot;Window/UI Toolkit/PlaceHolderExample&quot;)] public static void ShowExample() { PlaceHolderExample wnd = GetWindow&lt;PlaceHolderExample&gt;(); wnd.titleContent = new GUIContent(&quot;PlaceHolderExample&quot;); } private bool placeHolderMode = true; private const string placeHolderText = &quot;Write here&quot;; public void CreateGUI() { // 建立 TextField TextField textField = new TextField(); textField.value = placeHolderText; rootVisualElement.Add(textField); // 註冊FocusInEvent與FocusOutEvent textField.RegisterCallback&lt;FocusInEvent&gt;(OnFocusInTextField); textField.RegisterCallback&lt;FocusOutEvent&gt;(OnFocusOutTextField); } private void OnFocusInTextField(FocusInEvent evt) { // 如果這個 text field 收到聚焦，表示使用者想要輸入字串，因此要將placeholder文字清空 if (placeHolderMode) { var textField = evt.target as TextField; textField.value = &quot;&quot;; } } private void OnFocusOutTextField(FocusOutEvent evt) { // 如果這個 text field 失焦，表示使用者已經完成輸入，但如果text field為空字串，則要將placeholder文字填回去。 var textField = evt.target as TextField; placeHolderMode = string.IsNullOrEmpty(textField.value); if (placeHolderMode) textField.value = placeHolderText; }} 在Unity編輯器中找到 Window &gt; UI Toolkit &gt; PlaceHolderExample Reference: https://docs.unity3d.com/Manual/UIE-Focus-Events.html","link":"/2024/04/22/%E5%91%BD%E4%BB%A4%E4%BA%8B%E4%BB%B6-Command-events/"},{"title":"在Chrome中抓取整個網頁截圖","text":"打開 DevTools，在右邊找到 Run command。點擊之後，輸入Capture full size screenshot就可以抓取該網頁的截圖了","link":"/2024/02/08/%E5%9C%A8Chrome%E4%B8%AD%E6%8A%93%E5%8F%96%E6%95%B4%E5%80%8B%E7%B6%B2%E9%A0%81%E6%88%AA%E5%9C%96/"},{"title":"事件捕捉(Capture events)","text":"事件捕捉(Capture events)通知你滑鼠捕捉狀態(mouse capture state)的變化，在UI Toolkit中的事件有兩捕捉種類型： 滑鼠捕捉事件(Mouse capture events) 指標捕捉事件(Pointer capture events) 當一個element捕捉了滑鼠或指標，它是唯一接收來自點擊裝置(Pointing device，如滑鼠)事件的element，直到該裝置釋放或失去捕捉為止。例如：假設你使用滑鼠點擊了一個文字框(text box)，這個文字框會捕捉這個滑鼠，此時滑鼠仍然可以移動，但是它不會觸發文字框之外的事件；只要這個文字框正在捕捉你的滑鼠，那麼它就不會觸發其他事件。當你在文字框之外按下滑鼠上的按鈕時，文字框會釋放其滑鼠捕捉。 捕捉滑鼠(Mouse capture)滑鼠捕捉事件(Mouse capture events)是實體滑鼠或是模擬滑鼠的虛擬滑鼠上的事件。捕捉到滑鼠時，也會產生一個滑鼠指標的PointerCaptureEvent。當一個element釋放捕捉滑鼠時，會觸發相應的MouseCaptureOutEvent。 注意：不會發生同時有兩個elements同時捕捉滑鼠的情況，如果另外一個Visual Element觸發了MouseCaptureEvent那麼原先捕捉滑鼠的Element就會釋滑鼠並收到一個MouseCaptureOutEvent 捕捉指標(Pointer capture)在UI Toolkit中，指標事件優先於滑鼠事件。如果指標的類型是滑鼠的話，在捕捉到指標事件時也會觸發滑鼠事件。 Event 描述 Trickles down Bubbles up Cancellable MouseCaptureEvent 當某個Element被滑鼠捕捉時會發送這個事件，此時target為這個Element ✔ ✔ MouseCaptureOutEvent 當某個Element捕捉的滑鼠被釋放或是某些其他原因是放時，會發送這個事件，此時target為這個失去滑鼠捕捉的Element ✔ ✔ PointerCaptureEvent 當某個Element捕捉指標時會發送這個事件，此時target為這個Element ✔ ✔ PointerCaptureOutEvent 當某個Element捕捉的指標被釋放時，會發送這個事件，此時target為這個失去指標捕捉的Element ✔ ✔ 例子以下例子為示範捕捉與釋放的行為 在Assets &gt; Scripts &gt; Editor 下建立一個 C# Script CaptureEventsTestWindow.cs 將以下程式碼複製到剛剛建立的C# Script中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using UnityEditor;using UnityEngine;using UnityEngine.UIElements;public class CaptureEventsTestWindow : EditorWindow{ // 這個Attributes會在 Windows -&gt; UI Tollkit 下加入一個 Capture Events Test Window [MenuItem(&quot;Window/UI Toolkit/Capture Events Test Window&quot;)] public static void ShowExample() { var wnd = GetWindow&lt;CaptureEventsTestWindow&gt;(); wnd.titleContent = new GUIContent(&quot;Capture Events Test Window&quot;); } private bool m_IsCapturing = false; public void CreateGUI() { for (int i = 0; i &lt; 4; i++) { // 建立一個 Label 的Visual Element Label clickableLabel = new Label($&quot;Label {i} - Click Me!&quot;); // 為這個Label Element註冊 MouseDownEvent clickableLabel.RegisterCallback&lt;MouseDownEvent&gt;((evt) =&gt; { // 這個匿名Callback會在Console中印出 Clicked on label *** 的字串 Debug.Log($&quot;Clicked on label '{(evt.target as Label).text}'&quot;); }); rootVisualElement.Add(clickableLabel); } // 建立一個 Label 的Visual Element Label capturingLabel = new Label(&quot;Click here to capture mouse&quot;); // 為這個Label Element註冊 MouseDownEvent capturingLabel.RegisterCallback&lt;MouseDownEvent&gt;((evt) =&gt; { if (!m_IsCapturing) { capturingLabel.text = &quot;Click here to release mouse&quot;; // 捕捉滑鼠 MouseCaptureController.CaptureMouse(capturingLabel); m_IsCapturing = true; } else { capturingLabel.text = &quot;Click here to capture mouse&quot;; // 釋放捕捉 MouseCaptureController.ReleaseMouse(capturingLabel); m_IsCapturing = false; } }); rootVisualElement.Add(capturingLabel); // 註冊捕捉滑鼠事件 rootVisualElement.RegisterCallback&lt;MouseCaptureEvent&gt;((evt) =&gt; { Debug.Log(&quot;Mouse captured&quot;); }); // 註冊滑鼠釋放捕捉事件 rootVisualElement.RegisterCallback&lt;MouseCaptureOutEvent&gt;((evt) =&gt; { Debug.Log(&quot;Mouse captured released&quot;); }); }} 在Unity編輯器中找到 Window &gt; UI Toolkit &gt; Capture Events Test Window 點擊Test Window上面的Label來觀看結果 Reference： https://docs.unity3d.com/Manual/UIE-Change-Events.html","link":"/2024/04/20/%E6%8D%95%E6%8D%89%E4%BA%8B%E4%BB%B6-Capture-events/"},{"title":"委派 Delegate","text":"委派：delegate 它的本質上是一個Class，主要用來定義method的類型 可以把它想像為一個定義method容器，用來儲存要傳遞的method。 使用委派讓你可以在呼叫method先處理一些邏輯，當這些邏輯處理完之後，在傳入這些method。 以下是他的語法 1存取修飾詞 delegate 返回值 委派名(參數列表); 如果沒寫存取修飾詞的話，預設為public的， 若取修飾詞寫為private的話，則其他namespace不可以使用 委派的method參數必須要對應 宣告範例 12345// 定義了一個無參無返回值容器 MyFundelegate void MyFun();// 定義了一個返回值為int，有一個int參數的委派容器delegate int MyFun2(int a); 使用範例 123456789101112131415161718192021222324252627282930313233delegate void MyFun();delegate int MyFun2(int a);class Program{ static void Main() { Console.WriteLine(&quot;委派&quot;); // 裝載method的容器 MyFun f = new MyFun(Fun); // 呼叫容器裡面的method f.Invoke(); // 簡化寫法，與f的方式一樣 MyFun f2 = Fun; f2(); // 容器與委派的method參數必須要對應 MyFunc2 f3 = Fun2; f3(1); } static void Fun() { Console.WriteLine(&quot;123456&quot;); } static int Fun2(int value) { Console.WriteLine(value); return value; }} C#預設先定義的委派 Action：是一個無參無返回值的委派 Func：一個無參數，但有一個返回泛型TResult的委派 Action(T obj)可以傳多個參數(最多有16個，是使用overload的方式)，無返回的委派 Func&lt;in T, out TResult&gt;(T arg); 可以傳多個參數，且有一個返回泛型TResult的委派 記憶方式：Func是有返回值的委託，而Action則是不會返回值的委託 Action例子 1234567Action&lt;int, string&gt; action = FunTest;static void FunTest(int a, string b) { // do something...} Func例子 1234567Func&lt;int, int&gt; func = FunTest2;static int FunTest2(int value) { Console.WriteLine(value); return value;}","link":"/2024/02/09/%E5%A7%94%E6%B4%BE-Delegate/"},{"title":"將Animator包裝起來避免使用String輸入錯誤","text":"在Unity中，使用Animator時，有時候會打錯字，造成找不到動畫，因此可以使用一個包裝類，將其包裝起來。 首先建立一個抽象類，AnimatorWrapper，在其中加入Animator依賴。 123456789namespace Test{ public abstract class AnimatorWrapper { protected Animator _animator; public Animator Animator =&gt; _animator; public AnimatorWrapper(Animator animator) =&gt; _animator = animator; }} 接著再需要播放動畫的物件實作對應的AnimatorWrapper類，將string參數放到這邊。 123456789namespace Test{ public class DoorAnimatorWrapper : AnimatorWrapper { public DoorAnimatorWrapper(Animator animator) : base(animator) { } public void IsOpen(bool isOpen) =&gt; _animator.SetBool(&quot;Open&quot;, isOpen); }} 在使用時，透過AnimatorWrapper類曝露出來的IsOpen去操作animator。 123456789private DoorAnimatorWrapper _animatorWrapper;private void Awake(){ var animator = GetComponent&lt;Animator&gt;(); _animatorWrapper = new DoorAnimatorWrapper(animator);}private void OpenDoor(bool isOpen) =&gt; _animatorWrapper.IsOpen(isOpen); 透過這種方式它能夠幫助減少因為打錯字符串而導致的錯誤，並提供了一個更加直觀、安全的介面來操作 Animator。 參考：Typos with string animation parameters","link":"/2024/04/02/%E5%B0%87Animator%E5%8C%85%E8%A3%9D%E8%B5%B7%E4%BE%86%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8String%E8%BC%B8%E5%85%A5%E9%8C%AF%E8%AA%A4/"},{"title":"暴露自訂control給UXML","text":"自訂control需要繼承VisualElement並且這個自訂control需要有一個預設constructor1234567891011class StatusBar : VisualElement{ // 需要有一個預設constructor public StatusBar() { m_Status = String.Empty; } string m_Status; public string status { get; set; }} 為了讓你自訂的control可以在UXML中使用，你需要定義一個factory class，如果沒有特殊的需求，可以直接繼承UxmlFactory&lt;T&gt;1234567class StatusBar : VisualElement{ // 建議直接將factory class放在自訂的control中 public new class UxmlFactory : UxmlFactory&lt;StatusBar&gt; {} // ...} UxmlTraits：定義在UXML中可以使用的特徵(UXML traits)， UxmlTraits的目的有 factory建立新物件時使用它們。 在schema產生時，會分析它們以取得關於該Element的資訊，之後將這些資訊轉換為XML schema directive。 以下範例 宣告了一個m_Status，用來定義一個XML attribute status uxmlChildElementsDescription回傳一個空IEnumerable，用來表明這個自訂的StatusBar沒有child。 Init()中，XML parser從property bag讀出的值設定給StatusBar.status UxmlTraits class定義在StatusBar class中，讓Init()可以存取StatusBar的私有變數。 UxmlTraits繼承了VisualElement.UxmlTraits，它也擁有VisualElement.UxmlTraits的屬性 Init()會呼叫base.Init()以初始化base class的屬性 12345678910111213141516171819202122class StatusBar : VisualElement{ public new class UxmlFactory : UxmlFactory&lt;StatusBar, UxmlTraits&gt; {} public new class UxmlTraits : VisualElement.UxmlTraits { UxmlStringAttributeDescription m_Status = new UxmlStringAttributeDescription { name = &quot;status&quot; }; public override IEnumerable&lt;UxmlChildElementDescription&gt; uxmlChildElementsDescription { get { yield break; } } public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc) { base.Init(ve, bag, cc); ((StatusBar)ve).status = m_Status.GetValueFromBag(bag, cc); } } // ...} - 注意：在UI Builder中創作時，UI Builder可能會多次呼叫`UxmlTraits.Init()`來同步UXML檔案中的值，建議使用`GetValueFromBag`而不是`TryGetValueFromBag`以確保當UI Builder取消設定(unset)element的值時，這個element不會殘留先前的值。 若想要有child的話，需要override uxmlChildElementsDescription，1234567public override IEnumerable&lt;UxmlChildElementDescription&gt; uxmlChildElementsDescription{ get { yield return new UxmlChildElementDescription(typeof(VisualElement)); }} 可以將你自訂的control放到namespace中來分類它們12[assembly: UxmlNamespacePrefix(&quot;My.First.Namespace&quot;, &quot;first&quot;)][assembly: UxmlNamespacePrefix(&quot;My.Second.Namespace&quot;, &quot;second&quot;)] Reference:https://docs.unity3d.com/Manual/UIE-expose-custom-control-to-uxml.html#define-a-factory","link":"/2024/05/01/%E6%9A%B4%E9%9C%B2%E8%87%AA%E8%A8%82control%E7%B5%A6UXML/"},{"title":"泛型約束","text":"泛型約束是使用where關鍵字讓泛型的類型有一定的限制 where T:struct ：結構類型的約束，只能接收結構類型作為泛型 12345678910class Test1&lt;T&gt; where T:struct{ public T value; public void TestFun&lt;K&gt;(K v) where K: struct}// 這句會報錯，因為他不是結構類型//-- Test1&lt;object&gt; t = new Test1&lt;object&gt;();// 這句可以Test1&lt;int&gt; t2 = new Test1&lt;int&gt;(); where T:class ：引用類型約束 1234567891011class Test2&lt;T&gt; where T : class{ public T value; public void TestFun&lt;K&gt;(K k) where K : class {}}// 這句可以Test2&lt;object&gt; t = new Test2&lt;object&gt;();// 這句會報錯，因為 int 不是引用類型//-- Test2&lt;int&gt; t2 = new Test2&lt;int&gt;(); where T: new() ：這個泛型一定要有一個無參數public的建構子(constructor)，此外若是組合使用的話new()要放到最後 12345678910111213141516class Test3&lt;T&gt; where T : new(){ public T value;}class PubC1 {}class PubC2{ public PubC2(int i) {}}// 這句可以Test3&lt;PubC1&gt; t = new Test3&lt;PubC1&gt;();// 這句不可以，因為 PubC2 沒有無參數的 public 建構子//-- Test3&lt;PubC2&gt; t2 = new Test3&lt;PubC2&gt;(); where T: 類名 ：泛型參數必須要是其類或者是其子類 where T: 介面名 ：泛型參數必須要是其介面的衍伸類型 where T:U：泛型參數為另一個泛型本身或是其衍伸類型 123class Test6&lt;T,U&gt; where T:U{ public T value;} 多個泛型皆有約束 1class Test8&lt;K,V&gt; where K:class,new() where K:struct{}","link":"/2024/05/25/%E6%B3%9B%E5%9E%8B%E7%B4%84%E6%9D%9F/"},{"title":"自訂control","text":"建立自訂的Control需要建立一個control C# class，然後將它暴露給UXML 建立一個繼承VisualElement的Class 若是要建立可綁定(Binding)的自訂Control，可以繼承自BaseField基底類別，而非 BindableElement。繼承BaseField有以下好處 有實作一個泛型的INotifyValueChanged 預設focusable 提供一個水平佈局(horizontal layout)，左側為label element，右側為input element VisualElement不會綁定到GameObject的生命週期函數，也就是說它不會收到以下callbacks Awake() OnEnable() OnDisable() OnDestroy() 可以在自訂control中的constructor做初始化的動作，但是如果你想要將初始化的動作延遲到這個自訂的control被加到UI之後，可以把初始化的動作加到AttachToPanelEvent callback 使用DetachFromPanelEvent callback可以偵測你自訂的control是否已經從UI上移除 12345678public CustomControl(){ var myCustomElement = rootVisualElement.Q(className: &quot;my-custom-element&quot;); myCustomElement.RegisterCallback&lt;AttachToPanelEvent&gt;(e =&gt; { /* 此處放置當這個elemenet被加入到UI上要做的事 */ }); myCustomElement.RegisterCallback&lt;DetachFromPanelEvent&gt;(e =&gt; { /* 此處放置當這個elemenet從UI上移除後要做的事 */ });} UI Toolkit會分派這兩個事件(AttachToPanelEvent與DetachFromPanelEvent)給所有element 要讓UXML與UI Builder使用你自訂的control，需要定義一個繼承UxmlFactory&lt;T&gt;的factory class將你自訂的control暴露給他們。 綁定資料需要實作INotifyValueChanged並根據需要監聽ChangeEvent。繼承BindableElement或是實作IBindable。 你可以創建USS custom properties以設定自訂控制項的樣式。 Reference: https://docs.unity3d.com/Manual/UIE-create-custom-controls.html","link":"/2024/04/28/%E8%87%AA%E8%A8%82control/"},{"title":"處理事件(Handle Event)","text":"UI Toolkit Events類似於HTML Events，當事件(Event)發生時，該事件就會發送給target visual element以及在事件傳播路徑(propagation path)上的visual elements。 處理事件的順序如下： 由root element往下直到目標(target)的parent element，都會執行event callback，稱為trickle-down phase 在事件目標執行event callback，稱為target phase 在事件目標上面呼叫ExecuteDefaultActionAtTarget() 由事件目標的parent element往上直到root element都會執行event callbacks，稱為bubble-up phase 在事件目標上面呼叫ExecuteDefaultAction() 註冊Event Callbacks(Register an event callback)可以在class中註冊callback，為個別的instance自訂行為(behavior)，例如滑鼠點擊text label時作出反應。除了目標(target)以外，沿著傳播路徑經過的element都會接收到兩次event 一次是在trickle-down phase 另外一次是bubble-up phase 使用element的RegisterCallback方法來註冊一個event callback element.RegisterCallback&lt;MouseDownEvent&gt;(CallbackMethod); 此例中把CallbackMethod註冊到MouseDownEvent 1myElement.RegisterCallback&lt;MouseDownEvent&gt;(MyCallback); 預設中，註冊的event callback會在target phase與bubble-up phase的時候執行，這樣可以確保父element會在子element之後做出反應。 如果你想要父element在子element之前做出反應可以在註冊event時，將其設定為TrickleDown.TrickleDown 12345678910111213using UnityEngine;using UnityEngine.UIElements;...VisualElement myElement = new VisualElement();// 為這個myElement註冊一個trickle-down phase的callback， // 這會讓dispatcher在target phase與trickle-down phase時執行此MyCallbackmyElement.RegisterCallback&lt;MouseDownEvent&gt;(MyCallback, TrickleDown.TrickleDown);// 定義一個callbackvoid MyCallback(MouseDownEvent evt) { /* ... */ }... 在一個element中，你可以對同一個event註冊多個callback，但是你只能在同一事件和傳播階段註冊一次相同的callback。 有參數的callback12345// 此將會向MyCallbackWithData傳送一個MyType的參數myElement.RegisterCallback&lt;MouseDownEvent, MyType&gt;(MyCallbackWithData, myData);// 定義一個有參數的callbackvoid MyCallbackWithData(MouseDownEvent evt, MyType data) { /* ... */ } 移除註冊的callback使用myElement.UnregisterCallback()移除註冊的callback。 監聽valueUI controls會使用value屬性來存放資料，例如 Toggle會持有一個boolean屬性，當Toggle關閉(off)時設為false，開啟(on)時設為true。 IntegerField會持有一個integer屬性，用來保存該field的值。 int val = myIntegerField.value; 透過RegisterValueChangedCallback你可以註冊一個監聽ChangeEvent事件的callback RegisterValueChangedCallback是RegisterCallback&lt;ChangeEvent&gt;的簡寫，它是透過INotifyValueChange interface來為VisualElement推測正確的Type T 12345// 為myIntegerField註冊一個監聽值改變的OnIntegerFieldChange callbackmyIntegerField.RegisterValueChangedCallback(OnIntegerFieldChange); // 定義一個callbackvoid OnIntegerFieldChange(ChangeEvent&lt;int&gt; evt) { /* ... */ } 更改Value有以下方式 直接更改value屬性，這會觸發一個新的ChangeEvent myControl.value = myNewValue; 使用該element的SetValueWithoutNotify()更改，這不會觸發一個新的ChangeEvent myControl.SetValueWithoutNotify(myNewValue); 獲取Pointer當visual element獲取一個Pointer時，Unity會向這個visual element發送所有與這個Pointer相關的Events，而不管是否這個Pointer懸停(hovers over)在這個visual element上，舉例來說，假設你建立了一個control，他會接收drag events並獲取pointer，不論pointer的位置為何，這個control都會接收drag events Event與自訂Control當自訂Control時，有兩種方式回應UI Toolkit events 註冊一個event callback 實作一個default action callbacks與default action的差異 callback必須要註冊在一個實體物件上；default action則是類似在class上的virtual functions 所有在傳播路徑(propagation path)上的visual element都會執行callback；Default actions只會在event target上執行。 callbacks可能會需要額外檢查是否是需要做出反應的event；default actions可以省略這個步驟 callbacks效能可能較差，default actions會好一些 因為callbacks在propagation phase時需要在註冊表(callback registry)裡面搜尋，而default actions則不需要 實作Default Action若要實作Default Action的話，需要繼承VisualElement，並實作ExecuteDefaultActionAtTarget()或是ExecuteDefaultAction()，或兩個方法都實作。如果實作了Default Action，會應用到該class的所有實體(instances) 如果你想要在parent callback之前執行default action可以把default action放到ExecuteDefaultActionAtTarget() 應該將default actions視為該element type要有的行為(behaviors)，例如：chcekbox觸發click event更新它的狀態時應override default action，而不是為所有checkbox註冊一個callback 123456789101112131415override void ExecuteDefaultActionAtTarget(EventBase evt){ // Call the base function. base.ExecuteDefaultActionAtTarget(evt); if (evt.eventTypeId == MouseDownEvent.TypeId()) { // ... } else if (evt.eventTypeId == MouseUpEvent.TypeId()) { // ... } // More event types} custom controls的最佳實踐 如果是element有的行為(behaviors)，你應該實作在default action 在callback中，你可以使用PreventDefault()來取消該element的 default action。 若一個instance沒有callback，那麼它不會進入propagation process 在事件分派過程(event dispatch process)中，有兩個時段可以執行你的default action 若想在trickle-down與bubble-up之間，在target callbacks之後立刻執行的話，override這個ExecuteDefaultActionsAtTarget()方法 在事件分派過程(event dispatch process)結束時，override這個ExecuteDefaultActions()方法 如果可能的話，盡量將default action寫在ExecuteDefaultActions()，在事件傳播過程(event propagation process)中的trickle-down階段或是bubble-up階段，可以透過PreventDefault()來覆蓋預設的操作。 如果一個事件不應該傳播到parent element的話，你必須要把傳播停下 例如：一個TextField在收到一個KeyDownEvent去修改它的值時，不應該讓這個事件傳播到它的parent visual element 使用ExecuteDefaultActionsAtTarget()實作default action時，可以呼叫StopPropagation()這可以確保event在bubble-up階段時不會處理 Default actions僅針對event target執行，要讓class對target的child element或parent element的事件作出反應，則必須在event的trickle-down或是bubble-up傳播階段之一註冊callback以接收該事件。 為了提高性能，盡量避免在的class中註冊回調函式。 一個parent panel可以在trickle-down階段停止傳播，避免事件傳到它的children 你無法在event class本身中阻止EventBase.PreDispatch()和EventBase.PostDispatch()方法的執行 可以透過以下方法事件傳播(event propagation) StopImmediatePropagation()：立刻停止事件傳播，其他callback不會執行這個event，但是ExecuteDefaultActionAtTarget()與ExecuteDefaultAction() default actions 仍然會執行。 StopPropagation()：在這個element上的最後一個callback執行完之後，停止傳播。這可以確保所有在這個element上的callback都執行完，不會有更多element去對這個事件做出反應。ExecuteDefaultActionAtTarget()與ExecuteDefaultAction() default actions 仍然會執行。 PreventDefault()：在事件傳播過程(event propagation process)時，避免呼叫ExecuteDefaultActionAtTarget()與ExecuteDefaultAction()。 PreventDefault()不會阻止其他callback的執行。 在bubble-up階段時，PreventDefault()不會影響ExecuteDefaultActionAtTarget() action。 Reference：https://docs.unity3d.com/Manual/UIE-Events-Handling.html","link":"/2024/04/17/%E8%99%95%E7%90%86%E4%BA%8B%E4%BB%B6-Handle-Event/"},{"title":"使用Action Editor編輯Input","text":"在Project-Wide Actions中可以建立一個整個專案可用的Action Asset，此外你也可以自己再額外建立更多的Action Asset，在編輯器中，選擇Create &gt; Input Actions 便可建立一個Action Asset。 滑鼠左鍵點擊兩次剛剛建立的Action檔案，便可以打開編輯畫面(Actions Editor) Name 描述 Action Maps 顯示目前定義的Action Maps Actions 顯示目前選中的Action Map擁有的Action以及Binding Properties 顯示目前選中Action或是Binding的屬性(properties) 設定Action Maps：在Action Maps旁邊的+可以添加Action Map，對新增的Action Map按下兩次滑鼠左鍵可以對它命名， 注意Action Map的名稱不可以包含 / (slashes)， 設定Action：在Action旁邊的+可以添加Action，對新增的Action按下兩次滑鼠左鍵可以對它命名 Action的屬性 Action Type：可以選擇Button，Value或是PassThrough 若你的Action為鍵盤按鈕，滑鼠點擊或是搖桿按鈕控制的話，選擇Button，如果有多個裝置接上，那麼只會選擇一個最活躍的輸入裝置的輸入(稱為Conflicting inputs) 若是滑鼠移動或是搖桿移動這種屬於連續不斷改變的輸入的話，選擇Value PassThrough和Value相同，差別在於不處理衝突，即會發送所有綁定此Action裝置的輸入。 Control Type：讓你選擇此Action期望的控制類型，這可以限制哪些控制設備可以顯示在UI上，例如選擇了2D axis，那麼在選擇綁定時只有那些支援2D vector的控制設備會顯示在選項上。 Binding：在添加的自訂Action旁邊的+可以為這個Action新增Binding。可以在一個Action上添加多個Binding以支援多個類型的輸入裝置。 Composite Bindings：為多個Binding組成， 例如Up/Down/Left/Right Composite就是在模擬2D搖桿(2D stick input)的輸入 可以透過Duplicate添加不同的 Binding 在Action Editor左上角可以找到Control Schemes，讓你可以根據不同的裝置啟用或是停用Action的Bindings 上一篇：將Action設為整個專案可用(Project-Wide Actions) 下一篇：Actions概念","link":"/2024/04/25/%E8%A8%AD%E5%AE%9AAction/"},{"title":"身分證字號產生器","text":"","link":"/2024/04/10/%E8%BA%AB%E5%88%86%E8%AD%89%E5%AD%97%E8%99%9F%E7%94%A2%E7%94%9F%E5%99%A8/"},{"title":"變更事件(Change events)","text":"當一個Element的值改變時，就會發送一個Change Event，例如使用者切換了(toggles)一個核取方塊(Checkbox)，Change Event是一個帶有類型的事件(Typed Event)，它含有這個Element先前的值和新值。由於Change Event是在新的值被賦值後才觸發，因此你無法透過取消Change Event的方式去來避免值的改變。 Event 描述 Trickles down Bubbles up Cancellable ChangeEvent 當一個Element的值改變時，就會發送一個Change Event ✔ ✔ 專屬於Change Event的屬性 previousValue: 存放該Element先前的值 The previous value of the target control. newValue: 存放該Element該要改變的新值 Change Event是一個通知事件(notification event)讓你可以在visual element的值改變時做出反應，例如：當使用者按下音樂核取方塊(Checkbox)那麼遊戲的音樂就應該都被關閉。 Change Event應用到所有有實作INotifyValueChanged&lt;T&gt;的controls其中&lt;T&gt;就是ChangeEvent，此外這個也被在內部使用，透過Data binding的方式來更新實體物件的屬性 避免觸發Change Event如果你是透過程式碼更改control的值而觸發control的Change Event，你可以透過呼叫INotifyValueChange&lt;T&gt;中的SetValueWithoutNotify來更改control的值，並避免觸發Change Event 註冊Change Event 呼叫在Visual Element上的RegisterCallback&lt;&gt;() 如果你想要在一個Element中監聽它的子Elements中是否有發生改變的話，可以使用12345678// 使用RegisterCallback註冊callbackrootVisualElement.RegisterCallback&lt;ChangeEvent&lt;bool&gt;&gt;(OnBoolChangedEvent);// callback方法，它會監聽bool值是否發生改變private void OnBoolChangedEvent(ChangeEvent&lt;bool&gt; evt) { // Handling code} 呼叫有實作INotifyValueChange的Visual Element上的RegisterValueChangedCallback() 使用RegisterValueChangedCallback會比較方便因為它已經內建(build-in)好要傳值得類型 取消註冊可以使用UnregisterValueChangedCallback123456var newToggle = new Toggle(&quot;Test Toggle&quot;);newToggle.RegisterValueChangedCallback(OnTestToggleChanged);private void OnTestToggleChanged(ChangeEvent&lt;bool&gt; evt){ // Handling code} 例子一：註冊兩個ChangeEvent，一個在toggle element上使用RegisterValueChangedCallback，另外一個在root element使用RegisterCallback以下例子為示範如何使用ChangeEvent 在Assets &gt; Scripts &gt; Editor 下建立一個 C# Script ChangeEventTestWindow.cs 將以下程式碼複製到剛剛建立的C# Script中123456789101112131415161718192021222324252627282930313233343536373839using UnityEditor;using UnityEngine;using UnityEngine.UIElements;public class ChangeEventTestWindow : EditorWindow{ private Toggle m_MyToggle; // 這個Attributes會在 Windows -&gt; UI Tollkit 下加入一個 Change Event Test Window [MenuItem(&quot;Window/UI Toolkit/Change Event Test Window&quot;)] public static void ShowExample() { ChangeEventTestWindow wnd = GetWindow&lt;ChangeEventTestWindow&gt;(); wnd.titleContent = new GUIContent(&quot;Change Event Test Window&quot;); } public void CreateGUI() { // 建立一個 toggle control m_MyToggle = new Toggle(&quot;Test Toggle&quot;) { name = &quot;My Toggle&quot; }; rootVisualElement.Add(m_MyToggle); // 使用RegisterValueChangedCallback為這個 toggle control註冊OnTestToggleChanged m_MyToggle.RegisterValueChangedCallback(OnTestToggleChanged); // 使用RegisterCallback在root element註冊OnBoolChangedEvent，它必須要指定泛型 rootVisualElement.RegisterCallback&lt;ChangeEvent&lt;bool&gt;&gt;(OnBoolChangedEvent); } private void OnBoolChangedEvent(ChangeEvent&lt;bool&gt; evt) { Debug.Log($&quot;Toggle changed. Old value: {evt.previousValue}, new value: {evt.newValue}&quot;); } private void OnTestToggleChanged(ChangeEvent&lt;bool&gt; evt) { Debug.Log($&quot;A bool value changed. Old value: {evt.previousValue}, new value: {evt.newValue}&quot;); }} 在Unity編輯器中找到 Window &gt; UI Toolkit &gt; Change Events Test Window 觀看結果 例子二：使用程式碼觸發事件的話，可以透過element上的SetValueWithoutNotify避免觸發Change Event 將以下程式碼覆蓋到ChangeEventTestWindow.cs Script中12345678910111213141516171819202122232425262728293031323334353637383940using UnityEditor;using UnityEngine;using UnityEngine.UIElements;public class ChangeEventTestWindow : EditorWindow{ private Toggle m_MyToggle; [MenuItem(&quot;Window/UI Toolkit/Change Event Test Window&quot;)] public static void ShowExample() { GetWindow&lt;ChangeEventTestWindow&gt;().titleContent = new GUIContent(&quot;Change Event Test Window&quot;); } public void CreateGUI() { // 建立一個toggle並為其註冊callback m_MyToggle = new Toggle(&quot;Test Toggle&quot;) { name = &quot;My Toggle&quot; }; m_MyToggle.RegisterValueChangedCallback((evt) =&gt; { Debug.Log(&quot;Change Event received&quot;); }); rootVisualElement.Add(m_MyToggle); // 建立一個button來更改toggle的值 Button button01 = new Button() { text = &quot;Toggle&quot; }; button01.clicked += () =&gt; { // 這個會觸發Change Event m_MyToggle.value = !m_MyToggle.value; }; rootVisualElement.Add(button01); // 建立另外一個button，但是使用SetValueWithoutNotify更改toggle的值， Button button02 = new Button() { text = &quot;Toggle without notification&quot; }; button02.clicked += () =&gt; { // 使用SetValueWithoutNotify()不會觸發Change Event m_MyToggle.SetValueWithoutNotify(!m_MyToggle.value); }; rootVisualElement.Add(button02); }} 觀看結果 Reference: https://docs.unity3d.com/Manual/UIE-Change-Events.html","link":"/2024/04/21/%E8%AE%8A%E6%9B%B4%E4%BA%8B%E4%BB%B6-Change-events/"},{"title":"輸入事件(Input events)","text":"當字串透過使用者輸入到Text field時，便會觸發InputEvent，與觸碰螢幕的PointerCaptureOutEvent類似。對於預設的鍵盤輸入，每次按一下鍵(keystroke)都會觸發InputEvent。但是對於間接來源(indirect source)的輸入，將不會觸發InputEvent，例如自動化腳本(automated script)。 專屬於Input Event的屬性 previousData: 存放先前的資料 newData: 存放新的資料 當資料輸入到繼承了TextInputBaseField的control便會發送InputEvent，InputEvent不同於ChangeEvent的地方在於，即使輸入到control的資料沒改變，它也會發送InputEvent。 例子：下面例子為一個TextField註冊一個InputEvent，每當觸發便會印出輸出的的值 在Assets &gt; Scripts &gt; Editor 下建立一個 C# Script InputEventExample.cs 將以下程式碼複製到剛剛建立的C# Script中123456789101112131415161718192021222324252627282930using UnityEditor;using UnityEngine;using UnityEngine.UIElements;public class InputEventExample : EditorWindow{ // 這個Attributes會在 Windows -&gt; UI Tollkit 下加入一個 InputEventExample [MenuItem(&quot;Window/UI Toolkit/InputEventExample&quot;)] public static void ShowExample() { var wnd = GetWindow&lt;InputEventExample&gt;(); wnd.titleContent = new GUIContent(&quot;Input Event Example&quot;); } public void CreateGUI() { // 建立 TextField TextField textField = new TextField(); rootVisualElement.Add(textField); // 註冊InputEvent textField.RegisterCallback&lt;InputEvent&gt;(OnInput); } private void OnInput(InputEvent evt) { // 印出InputEvent中的newData與previousData Debug.Log(&quot;newData=&quot; + evt.newData + &quot; previousData=&quot; + evt.previousData); }} 在Unity編輯器中找到 Window &gt; UI Toolkit &gt; InputEventExample 顯示結果 Reference: https://docs.unity3d.com/Manual/UIE-Input-Events.html","link":"/2024/04/22/%E8%BC%B8%E5%85%A5%E4%BA%8B%E4%BB%B6-Input-events/"},{"title":"點擊事件(Click events)","text":"當一個Visual Element被滑鼠左鍵(或點擊裝置(pointing device)的第一個按鈕)點擊，將觸發一個Click Event。進行點擊操作的Visual Element會觸發Pointer Down Event與Pointer up Event。此外Click Event也可以檢測到非按鈕Visual Element的點擊，例如Toggle control便是使用了Click Event來處理顯示，隱藏勾號(check mask)並改變control的值。 Event 描述 Trickles down Bubbles up Cancellable ClickEvent 當滑鼠左鍵點擊時，就會觸發一個Click Event ✔ ✔ ✔ 註冊Click Event12345678// 使用RegisterCallback註冊ClickEvent，同時還傳入一個VisualElement參數// 這個asset是當click event被觸發之後，要關閉的elementbtnClose.RegisterCallback&lt;ClickEvent, VisualElement&gt;(Clicked, asset); private void Clicked(ClickEvent evt, VisualElement root){ root.ShowVisualElement(false); } 例子：以下例子示範如何使用Click Event讓一個visual element在被點擊之後將原有顏色，替換為另一個新的顏色。 在Assets &gt; Scripts &gt; Editor 下建立一個 C# Script ClickEventExampleWindow.cs 將以下程式碼複製到剛剛建立的C# Script中123456789101112131415161718192021222324252627282930313233343536373839404142434445using UnityEditor;using UnityEngine;using UnityEngine.UIElements;public class ClickEventExampleWindow : EditorWindow{ // 這個Attributes會在 Windows -&gt; UI Tollkit 下加入一個 ClickEventExample [MenuItem(&quot;Window/UI Toolkit/ClickEventExample&quot;)] public static void ShowExample() { var wnd = GetWindow&lt;ClickEventExampleWindow&gt;(); wnd.titleContent = new GUIContent(&quot;Click Event Example&quot;); } public void CreateGUI() { // 建立四個不同顏色的box for (int i = 0; i &lt; 4; i++) { // 為這些Visual Element設定隨機的background顏色 var newBox = new VisualElement() { style = { flexGrow = 1, backgroundColor = GetRandomColor() } }; rootVisualElement.Add(newBox); // 為這個Element註冊一個ClickEvent callback newBox.RegisterCallback&lt;ClickEvent&gt;(OnBoxClicked); } } // 這個callback會改變target的Background color。 private void OnBoxClicked(ClickEvent evt) { // 只在taget階段執行這個callback if (evt.propagationPhase != PropagationPhase.AtTarget) return; // 設定新的Background color var targetBox = evt.target as VisualElement; targetBox.style.backgroundColor = GetRandomColor(); } private Color GetRandomColor() { return new Color(Random.Range(0, 1f), Random.Range(0, 1f), Random.Range(0, 1f)); }} 在Unity編輯器中找到 Window &gt; UI Toolkit &gt; ClickEventExample 觀看結果 Reference: https://docs.unity3d.com/Manual/UIE-Click-Events.html","link":"/2024/04/22/%E9%BB%9E%E6%93%8A%E4%BA%8B%E4%BB%B6-Click-events/"}],"tags":[{"name":"Joint 2D","slug":"Joint-2D","link":"/tags/Joint-2D/"},{"name":"物理相關","slug":"物理相關","link":"/tags/%E7%89%A9%E7%90%86%E7%9B%B8%E9%97%9C/"},{"name":"Shader Graph","slug":"Shader-Graph","link":"/tags/Shader-Graph/"},{"name":"Unity Tips","slug":"Unity-Tips","link":"/tags/Unity-Tips/"},{"name":"ScriptableObject","slug":"ScriptableObject","link":"/tags/ScriptableObject/"},{"name":"數學相關","slug":"數學相關","link":"/tags/%E6%95%B8%E5%AD%B8%E7%9B%B8%E9%97%9C/"},{"name":"時間","slug":"時間","link":"/tags/%E6%99%82%E9%96%93/"},{"name":"UGUI","slug":"UGUI","link":"/tags/UGUI/"},{"name":"ParticleSystem","slug":"ParticleSystem","link":"/tags/ParticleSystem/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"Google API","slug":"Google-API","link":"/tags/Google-API/"},{"name":"Unit Test","slug":"Unit-Test","link":"/tags/Unit-Test/"},{"name":"Input System","slug":"Input-System","link":"/tags/Input-System/"},{"name":"SQL語法","slug":"SQL語法","link":"/tags/SQL%E8%AA%9E%E6%B3%95/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"UI Toolkit","slug":"UI-Toolkit","link":"/tags/UI-Toolkit/"},{"name":"Eclipse","slug":"Eclipse","link":"/tags/Eclipse/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"Google Search Console","slug":"Google-Search-Console","link":"/tags/Google-Search-Console/"},{"name":"sitemap","slug":"sitemap","link":"/tags/sitemap/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"JSON Pretty","slug":"JSON-Pretty","link":"/tags/JSON-Pretty/"},{"name":"JSON Formatter","slug":"JSON-Formatter","link":"/tags/JSON-Formatter/"},{"name":"Flex","slug":"Flex","link":"/tags/Flex/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"UI Builder","slug":"UI-Builder","link":"/tags/UI-Builder/"},{"name":"Unity架構","slug":"Unity架構","link":"/tags/Unity%E6%9E%B6%E6%A7%8B/"},{"name":"Unity package","slug":"Unity-package","link":"/tags/Unity-package/"},{"name":"Event","slug":"Event","link":"/tags/Event/"},{"name":"DB","slug":"DB","link":"/tags/DB/"},{"name":"Chrome","slug":"Chrome","link":"/tags/Chrome/"},{"name":"delegate","slug":"delegate","link":"/tags/delegate/"},{"name":"taiwan_id","slug":"taiwan-id","link":"/tags/taiwan-id/"}],"categories":[{"name":"Design Pattern","slug":"Design-Pattern","link":"/categories/Design-Pattern/"},{"name":"Unity","slug":"Unity","link":"/categories/Unity/"},{"name":"Chrome","slug":"Chrome","link":"/categories/Chrome/"},{"name":"AWS","slug":"AWS","link":"/categories/AWS/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"},{"name":"大綱","slug":"大綱","link":"/categories/%E5%A4%A7%E7%B6%B1/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"Mac","slug":"Mac","link":"/categories/Mac/"},{"name":"AI繪圖","slug":"AI繪圖","link":"/categories/AI%E7%B9%AA%E5%9C%96/"},{"name":"SQL","slug":"SQL","link":"/categories/SQL/"},{"name":"C# 語言","slug":"C-語言","link":"/categories/C-%E8%AA%9E%E8%A8%80/"},{"name":"IDE操作","slug":"IDE操作","link":"/categories/IDE%E6%93%8D%E4%BD%9C/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}],"pages":[]}